import { isPlatformServer } from '@angular/common';
import { NgxsBootstrapper } from '@ngxs/store/internals';
import { Observable, Subject, BehaviorSubject, of, forkJoin, empty, throwError, from } from 'rxjs';
import { map, filter, shareReplay, exhaustMap, take, catchError, defaultIfEmpty, mergeMap, takeUntil, tap, distinctUntilChanged } from 'rxjs/operators';
import { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, Optional, SkipSelf, ErrorHandler, getPlatform, COMPILER_OPTIONS, isDevMode, Injector, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DispatchOutsideZoneNgxsExecutionStrategy {
    /**
     * @param {?} _ngZone
     * @param {?} _platformId
     */
    constructor(_ngZone, _platformId) {
        this._ngZone = _ngZone;
        this._platformId = _platformId;
        this.verifyZoneIsNotNooped(this._ngZone);
    }
    /**
     * @template T
     * @param {?} func
     * @return {?}
     */
    enter(func) {
        if (isPlatformServer(this._platformId)) {
            return this.runInsideAngular(func);
        }
        return this.runOutsideAngular(func);
    }
    /**
     * @template T
     * @param {?} func
     * @return {?}
     */
    leave(func) {
        return this.runInsideAngular(func);
    }
    /**
     * @private
     * @template T
     * @param {?} func
     * @return {?}
     */
    runInsideAngular(func) {
        if (NgZone.isInAngularZone()) {
            return func();
        }
        return this._ngZone.run(func);
    }
    /**
     * @private
     * @template T
     * @param {?} func
     * @return {?}
     */
    runOutsideAngular(func) {
        if (NgZone.isInAngularZone()) {
            return this._ngZone.runOutsideAngular(func);
        }
        return func();
    }
    /**
     * @private
     * @param {?} ngZone
     * @return {?}
     */
    verifyZoneIsNotNooped(ngZone) {
        /* - Removed because unsafe for Angular 5 - investigate
        if (ngZone instanceof NoopNgZone) {
          console.warn(
            'Your application was bootstrapped with nooped zone and your execution strategy requires an ngZone'
          );
        }
        */
    }
}
DispatchOutsideZoneNgxsExecutionStrategy.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DispatchOutsideZoneNgxsExecutionStrategy.ctorParameters = () => [
    { type: NgZone },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
const FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
const META_KEY = 'NGXS_META';
/** @type {?} */
const META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
/** @type {?} */
const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/** @type {?} */
const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/**
 * The NGXS config settings.
 */
class NgxsConfig {
    constructor() {
        /**
         * Defining the default state before module initialization
         * This is convenient if we need to create a define our own set of states.
         * (default: {})
         */
        this.defaultsState = {};
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;
    }
}
NgxsConfig.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NgxsConfig.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Internal execution strategy injection token
 */
/** @type {?} */
const NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = [...paths];
    return (/**
     * @param {?} obj
     * @return {?}
     */
    obj => copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    (acc, part) => acc && acc[part]), obj));
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        g => g === stateClass));
        if (!meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        const { name, children } = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        /** @type {?} */
        const meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    });
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        (dep) => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    k => visit(k)));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
/** @type {?} */
const DOLLAR_CHAR_CODE = 36;
/**
 * If `foo$` => make it just `foo`
 *
 * @ignore
 * @param {?} name
 * @return {?}
 */
function removeDollarAtTheEnd(name) {
    /** @type {?} */
    const lastCharIndex = name.length - 1;
    /** @type {?} */
    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns the type from an action instance/class.
 * @ignore
 * @param {?} action
 * @return {?}
 */
function getActionTypeFromInstance(action) {
    if (action.constructor && action.constructor.type) {
        return action.constructor.type;
    }
    return action.type;
}
/**
 * Matches a action
 * @ignore
 * @param {?} action1
 * @return {?}
 */
function actionMatcher(action1) {
    /** @type {?} */
    const type1 = getActionTypeFromInstance(action1);
    return (/**
     * @param {?} action2
     * @return {?}
     */
    function (action2) {
        return type1 === getActionTypeFromInstance(action2);
    });
}
/**
 * Set a deeply nested value. Example:
 *
 *   setValue({ foo: { bar: { eat: false } } },
 *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
 *
 * While it traverses it also creates new objects from top down.
 *
 * @ignore
 * @type {?}
 */
const setValue = (/**
 * @param {?} obj
 * @param {?} prop
 * @param {?} val
 * @return {?}
 */
(obj, prop, val) => {
    obj = Object.assign({}, obj);
    /** @type {?} */
    const split = prop.split('.');
    /** @type {?} */
    const lastIndex = split.length - 1;
    split.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @param {?} index
     * @return {?}
     */
    (acc, part, index) => {
        if (index === lastIndex) {
            acc[part] = val;
        }
        else {
            acc[part] = Array.isArray(acc[part]) ? [...acc[part]] : Object.assign({}, acc[part]);
        }
        return acc && acc[part];
    }), obj);
    return obj;
});
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @type {?}
 */
const getValue = (/**
 * @param {?} obj
 * @param {?} prop
 * @return {?}
 */
(obj, prop) => prop.split('.').reduce((/**
 * @param {?} acc
 * @param {?} part
 * @return {?}
 */
(acc, part) => acc && acc[part]), obj));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will grab actions that have just been dispatched as well as actions that have completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofAction(...allowedTypes) {
    return ofActionOperator(allowedTypes);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been dispatched
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionDispatched(...allowedTypes) {
    return ofActionOperator(allowedTypes, ["DISPATCHED" /* Dispatched */]);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been successfully completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionSuccessful(...allowedTypes) {
    return ofActionOperator(allowedTypes, ["SUCCESSFUL" /* Successful */]);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been canceled
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionCanceled(...allowedTypes) {
    return ofActionOperator(allowedTypes, ["CANCELED" /* Canceled */]);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just been completed
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionCompleted(...allowedTypes) {
    /** @type {?} */
    const allowedStatuses = [
        "SUCCESSFUL" /* Successful */,
        "CANCELED" /* Canceled */,
        "ERRORED" /* Errored */
    ];
    return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);
}
/**
 * RxJS operator for selecting out specific actions.
 *
 * This will ONLY grab actions that have just thrown an error
 * @param {...?} allowedTypes
 * @return {?}
 */
function ofActionErrored(...allowedTypes) {
    return ofActionOperator(allowedTypes, ["ERRORED" /* Errored */]);
}
/**
 * @template T
 * @param {?} allowedTypes
 * @param {?=} statuses
 * @param {?=} mapOperator
 * @return {?}
 */
function ofActionOperator(allowedTypes, statuses, mapOperator = mapAction) {
    /** @type {?} */
    const allowedMap = createAllowedActionTypesMap(allowedTypes);
    /** @type {?} */
    const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);
    return (/**
     * @param {?} o
     * @return {?}
     */
    function (o) {
        return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());
    });
}
/**
 * @param {?} allowedTypes
 * @param {?=} allowedStatuses
 * @return {?}
 */
function filterStatus(allowedTypes, allowedStatuses) {
    return filter((/**
     * @param {?} ctx
     * @return {?}
     */
    (ctx) => {
        /** @type {?} */
        const actionType = (/** @type {?} */ (getActionTypeFromInstance(ctx.action)));
        /** @type {?} */
        const typeMatch = allowedTypes[actionType];
        /** @type {?} */
        const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;
        return typeMatch && statusMatch;
    }));
}
/**
 * @return {?}
 */
function mapActionResult() {
    return map((/**
     * @param {?} __0
     * @return {?}
     */
    ({ action, status, error }) => {
        return (/** @type {?} */ ({
            action,
            result: {
                successful: "SUCCESSFUL" /* Successful */ === status,
                canceled: "CANCELED" /* Canceled */ === status,
                error
            }
        }));
    }));
}
/**
 * @template T
 * @return {?}
 */
function mapAction() {
    return map((/**
     * @param {?} ctx
     * @return {?}
     */
    (ctx) => (/** @type {?} */ (ctx.action))));
}
/**
 * @param {?} types
 * @return {?}
 */
function createAllowedActionTypesMap(types) {
    return types.reduce((/**
     * @param {?} filterMap
     * @param {?} klass
     * @return {?}
     */
    (filterMap, klass) => {
        filterMap[(/** @type {?} */ (getActionTypeFromInstance(klass)))] = true;
        return filterMap;
    }), (/** @type {?} */ ({})));
}
/**
 * @param {?} statuses
 * @return {?}
 */
function createAllowedStatusesMap(statuses) {
    return statuses.reduce((/**
     * @param {?} filterMap
     * @param {?} status
     * @return {?}
     */
    (filterMap, status) => {
        filterMap[status] = true;
        return filterMap;
    }), (/** @type {?} */ ({})));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InternalNgxsExecutionStrategy {
    /**
     * @param {?} _executionStrategy
     */
    constructor(_executionStrategy) {
        this._executionStrategy = _executionStrategy;
    }
    /**
     * @template T
     * @param {?} func
     * @return {?}
     */
    enter(func) {
        return this._executionStrategy.enter(func);
    }
    /**
     * @template T
     * @param {?} func
     * @return {?}
     */
    leave(func) {
        return this._executionStrategy.leave(func);
    }
}
InternalNgxsExecutionStrategy.decorators = [
    { type: Injectable }
];
/** @nocollapse */
InternalNgxsExecutionStrategy.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [NGXS_EXECUTION_STRATEGY,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns operator that will run
 * `subscribe` outside of the ngxs execution context
 * @template T
 * @param {?} ngxsExecutionStrategy
 * @return {?}
 */
function leaveNgxs(ngxsExecutionStrategy) {
    return (/**
     * @param {?} source
     * @return {?}
     */
    (source) => {
        return new Observable((/**
         * @param {?} sink
         * @return {?}
         */
        (sink) => {
            return source.subscribe({
                /**
                 * @param {?} value
                 * @return {?}
                 */
                next(value) {
                    ngxsExecutionStrategy.leave((/**
                     * @return {?}
                     */
                    () => sink.next(value)));
                },
                /**
                 * @param {?} error
                 * @return {?}
                 */
                error(error) {
                    ngxsExecutionStrategy.leave((/**
                     * @return {?}
                     */
                    () => sink.error(error)));
                },
                /**
                 * @return {?}
                 */
                complete() {
                    ngxsExecutionStrategy.leave((/**
                     * @return {?}
                     */
                    () => sink.complete()));
                }
            });
        }));
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
class OrderedSubject extends Subject {
    constructor() {
        super(...arguments);
        this._itemQueue = [];
        this._busyPushingNext = false;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    next(value) {
        if (this._busyPushingNext) {
            this._itemQueue.unshift((/** @type {?} */ (value)));
            return;
        }
        this._busyPushingNext = true;
        super.next(value);
        while (this._itemQueue.length > 0) {
            /** @type {?} */
            const nextValue = this._itemQueue.pop();
            super.next(nextValue);
        }
        this._busyPushingNext = false;
    }
}
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
class InternalActions extends OrderedSubject {
}
InternalActions.decorators = [
    { type: Injectable }
];
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
class Actions extends Observable {
    /**
     * @param {?} actions$
     * @param {?} internalExecutionStrategy
     */
    constructor(actions$, internalExecutionStrategy) {
        super((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            actions$
                .pipe(leaveNgxs(internalExecutionStrategy))
                .subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => observer.next(res)), (/**
             * @param {?} err
             * @return {?}
             */
            err => observer.error(err)), (/**
             * @return {?}
             */
            () => observer.complete()));
        }));
    }
}
Actions.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Actions.ctorParameters = () => [
    { type: InternalActions },
    { type: InternalNgxsExecutionStrategy }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Composes a array of functions from left to right. Example:
 *
 *      compose([fn, final])(state, action);
 *
 * then the funcs have a signature like:
 *
 *      function fn (state, action, next) {
 *          console.log('here', state, action, next);
 *          return next(state, action);
 *      }
 *
 *      function final (state, action) {
 *          console.log('here', state, action);
 *          return state;
 *      }
 *
 * the last function should not call `next`.
 *
 * @ignore
 * @type {?}
 */
const compose = (/**
 * @param {?} funcs
 * @return {?}
 */
(funcs) => (/**
 * @param {...?} args
 * @return {?}
 */
(...args) => {
    /** @type {?} */
    const curr = (/** @type {?} */ (funcs.shift()));
    return curr(...args, (/**
     * @param {...?} nextArgs
     * @return {?}
     */
    (...nextArgs) => compose(funcs)(...nextArgs)));
}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * BehaviorSubject of the entire state.
 * @ignore
 */
class StateStream extends BehaviorSubject {
    constructor() {
        super({});
    }
}
StateStream.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateStream.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Plugin manager class
 * @ignore
 */
class PluginManager {
    /**
     * @param {?} _parentManager
     * @param {?} _plugins
     */
    constructor(_parentManager, _plugins) {
        this._parentManager = _parentManager;
        this._plugins = _plugins;
        this.plugins = [];
        this.register();
    }
    /**
     * @private
     * @return {?}
     */
    register() {
        if (!this._plugins) {
            return;
        }
        this.plugins = this._plugins.map((/**
         * @param {?} plugin
         * @return {?}
         */
        plugin => {
            if (plugin.handle) {
                return plugin.handle.bind(plugin);
            }
            else {
                return plugin;
            }
        }));
        if (this._parentManager) {
            this._parentManager.plugins.push(...this.plugins);
        }
    }
}
PluginManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PluginManager.ctorParameters = () => [
    { type: PluginManager, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: Array, decorators: [{ type: Inject, args: [NGXS_PLUGINS,] }, { type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Internal Action result stream that is emitted when an action is completed.
 * This is used as a method of returning the action result to the dispatcher
 * for the observable returned by the dispatch(...) call.
 * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
 */
class InternalDispatchedActionResults extends Subject {
}
InternalDispatchedActionResults.decorators = [
    { type: Injectable }
];
class InternalDispatcher {
    /**
     * @param {?} _errorHandler
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _pluginManager
     * @param {?} _stateStream
     * @param {?} _ngxsExecutionStrategy
     */
    constructor(_errorHandler, _actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy) {
        this._errorHandler = _errorHandler;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._pluginManager = _pluginManager;
        this._stateStream = _stateStream;
        this._ngxsExecutionStrategy = _ngxsExecutionStrategy;
    }
    /**
     * Dispatches event(s).
     * @param {?} actionOrActions
     * @return {?}
     */
    dispatch(actionOrActions) {
        /** @type {?} */
        const result = this._ngxsExecutionStrategy.enter((/**
         * @return {?}
         */
        () => this.dispatchByEvents(actionOrActions)));
        result.subscribe({
            error: (/**
             * @param {?} error
             * @return {?}
             */
            error => this._ngxsExecutionStrategy.leave((/**
             * @return {?}
             */
            () => this._errorHandler.handleError(error))))
        });
        return result.pipe(leaveNgxs(this._ngxsExecutionStrategy));
    }
    /**
     * @private
     * @param {?} actionOrActions
     * @return {?}
     */
    dispatchByEvents(actionOrActions) {
        if (Array.isArray(actionOrActions)) {
            return forkJoin(actionOrActions.map((/**
             * @param {?} a
             * @return {?}
             */
            a => this.dispatchSingle(a))));
        }
        else {
            return this.dispatchSingle(actionOrActions);
        }
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    dispatchSingle(action) {
        /** @type {?} */
        const prevState = this._stateStream.getValue();
        /** @type {?} */
        const plugins = this._pluginManager.plugins;
        return ((/** @type {?} */ (compose([
            ...plugins,
            (/**
             * @param {?} nextState
             * @param {?} nextAction
             * @return {?}
             */
            (nextState, nextAction) => {
                if (nextState !== prevState) {
                    this._stateStream.next(nextState);
                }
                /** @type {?} */
                const actionResult$ = this.getActionResultStream(nextAction);
                actionResult$.subscribe((/**
                 * @param {?} ctx
                 * @return {?}
                 */
                ctx => this._actions.next(ctx)));
                this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                return this.createDispatchObservable(actionResult$);
            })
        ])(prevState, action)))).pipe(shareReplay());
    }
    /**
     * @private
     * @param {?} action
     * @return {?}
     */
    getActionResultStream(action) {
        return this._actionResults.pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => ctx.action === action && ctx.status !== "DISPATCHED" /* Dispatched */)), take(1), shareReplay());
    }
    /**
     * @private
     * @param {?} actionResult$
     * @return {?}
     */
    createDispatchObservable(actionResult$) {
        return actionResult$
            .pipe(exhaustMap((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => {
            switch (ctx.status) {
                case "SUCCESSFUL" /* Successful */:
                    return of(this._stateStream.getValue());
                case "ERRORED" /* Errored */:
                    return throwError(ctx.error);
                default:
                    return empty();
            }
        })))
            .pipe(shareReplay());
    }
}
InternalDispatcher.decorators = [
    { type: Injectable }
];
/** @nocollapse */
InternalDispatcher.ctorParameters = () => [
    { type: ErrorHandler },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: PluginManager },
    { type: StateStream },
    { type: InternalNgxsExecutionStrategy }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function defaultEqualityCheck(a, b) {
    return a === b;
}
/**
 * @param {?} equalityCheck
 * @param {?} prev
 * @param {?} next
 * @return {?}
 */
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
        return false;
    }
    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
    /** @type {?} */
    const length = prev.length;
    for (let i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Memoize a function on its last inputs only.
 * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 * @template T
 * @param {?} func
 * @param {?=} equalityCheck
 * @return {?}
 */
function memoize(func, equalityCheck = defaultEqualityCheck) {
    /** @type {?} */
    let lastArgs = null;
    /** @type {?} */
    let lastResult = null;
    // we reference arguments instead of spreading them for performance reasons
    /**
     * @return {?}
     */
    function memoized() {
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            // apply arguments instead of spreading for performance.
            lastResult = ((/** @type {?} */ (func))).apply(null, arguments);
        }
        lastArgs = arguments;
        return lastResult;
    }
    ((/** @type {?} */ (memoized))).reset = (/**
     * @return {?}
     */
    function () {
        // The hidden (for now) ability to reset the memoization
        lastArgs = null;
        lastResult = null;
    });
    return (/** @type {?} */ (memoized));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function _isAngularInTestMode() {
    /** @type {?} */
    const platformRef = getPlatform();
    if (!platformRef)
        return false;
    /** @type {?} */
    const compilerOptions = platformRef.injector.get(COMPILER_OPTIONS, null);
    if (!compilerOptions)
        return false;
    /** @type {?} */
    const isInTestMode = compilerOptions.some((/**
     * @param {?} item
     * @return {?}
     */
    (item) => {
        /** @type {?} */
        const providers = (item && item.providers) || [];
        return providers.some((/**
         * @param {?} provider
         * @return {?}
         */
        (provider) => {
            return ((provider && provider.provide && provider.provide.name === 'MockNgModuleResolver') ||
                false);
        }));
    }));
    return isInTestMode;
}
/** @type {?} */
const isAngularInTestMode = memoize(_isAngularInTestMode);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ConfigValidator {
    /**
     * @param {?} _config
     */
    constructor(_config) {
        this._config = _config;
    }
    /**
     * @return {?}
     */
    verifyDevMode() {
        if (isAngularInTestMode()) {
            return;
        }
        /** @type {?} */
        const isNgxsDevMode = this._config.developmentMode;
        /** @type {?} */
        const isNgDevMode = isDevMode();
        /** @type {?} */
        const incorrectProduction = !isNgDevMode && isNgxsDevMode;
        /** @type {?} */
        const incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
        /** @type {?} */
        const example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        if (incorrectProduction) {
            console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
        }
        else if (incorrectDevelopment) {
            console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
        }
    }
}
ConfigValidator.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ConfigValidator.ctorParameters = () => [
    { type: NgxsConfig }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Object freeze code
 * https://github.com/jsdf/deep-freeze
 * @type {?}
 */
const deepFreeze = (/**
 * @param {?} o
 * @return {?}
 */
(o) => {
    Object.freeze(o);
    /** @type {?} */
    const oIsFunction = typeof o === 'function';
    /** @type {?} */
    const hasOwnProp = Object.prototype.hasOwnProperty;
    Object.getOwnPropertyNames(o).forEach((/**
     * @param {?} prop
     * @return {?}
     */
    function (prop) {
        if (hasOwnProp.call(o, prop) &&
            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
            o[prop] !== null &&
            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
            !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
        }
    }));
    return o;
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
class InternalStateOperations {
    /**
     * @param {?} _stateStream
     * @param {?} _dispatcher
     * @param {?} _config
     * @param {?} configValidator
     */
    constructor(_stateStream, _dispatcher, _config, configValidator) {
        this._stateStream = _stateStream;
        this._dispatcher = _dispatcher;
        this._config = _config;
        configValidator.verifyDevMode();
    }
    /**
     * Returns the root state operators.
     * @return {?}
     */
    getRootStateOperations() {
        /** @type {?} */
        const rootStateOperations = {
            getState: (/**
             * @return {?}
             */
            () => this._stateStream.getValue()),
            setState: (/**
             * @param {?} newState
             * @return {?}
             */
            (newState) => this._stateStream.next(newState)),
            dispatch: (/**
             * @param {?} actions
             * @return {?}
             */
            (actions) => this._dispatcher.dispatch(actions))
        };
        if (this._config.developmentMode) {
            return this.ensureStateAndActionsAreImmutable(rootStateOperations);
        }
        return rootStateOperations;
    }
    /**
     * @private
     * @param {?} root
     * @return {?}
     */
    ensureStateAndActionsAreImmutable(root) {
        return {
            getState: (/**
             * @return {?}
             */
            () => root.getState()),
            setState: (/**
             * @param {?} value
             * @return {?}
             */
            value => {
                /** @type {?} */
                const frozenValue = deepFreeze(value);
                return root.setState(frozenValue);
            }),
            dispatch: (/**
             * @param {?} actions
             * @return {?}
             */
            actions => {
                return root.dispatch(actions);
            })
        };
    }
    /**
     * @param {?} results
     * @return {?}
     */
    setStateToTheCurrentWithNew(results) {
        /** @type {?} */
        const stateOperations = this.getRootStateOperations();
        // Get our current stream
        /** @type {?} */
        const currentState = stateOperations.getState();
        // Set the state to the current + new
        stateOperations.setState(Object.assign({}, currentState, results.defaults));
    }
}
InternalStateOperations.decorators = [
    { type: Injectable }
];
/** @nocollapse */
InternalStateOperations.ctorParameters = () => [
    { type: StateStream },
    { type: InternalDispatcher },
    { type: NgxsConfig },
    { type: ConfigValidator }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} val
 * @return {?}
 */
function simplePatch(val) {
    return (/**
     * @param {?} existingState
     * @return {?}
     */
    (existingState) => {
        /** @type {?} */
        const isArray = Array.isArray(val);
        /** @type {?} */
        const isPrimitive = typeof val !== 'object';
        if (isArray) {
            throw new Error('Patching arrays is not supported.');
        }
        if (isPrimitive) {
            throw new Error('Patching primitives is not supported.');
        }
        /** @type {?} */
        const newState = Object.assign({}, ((/** @type {?} */ (existingState))));
        for (const k in val) {
            newState[k] = val[k];
        }
        return (/** @type {?} */ (newState));
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State Context factory class
 * @ignore
 */
class StateContextFactory {
    /**
     * @param {?} _internalStateOperations
     */
    constructor(_internalStateOperations) {
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Create the state context
     * @template T
     * @param {?} metadata
     * @return {?}
     */
    createStateContext(metadata) {
        /** @type {?} */
        const root = this._internalStateOperations.getRootStateOperations();
        /**
         * @param {?} currentAppState
         * @return {?}
         */
        function getState(currentAppState) {
            return getValue(currentAppState, metadata.depth);
        }
        /**
         * @param {?} currentAppState
         * @param {?} newValue
         * @return {?}
         */
        function setStateValue(currentAppState, newValue) {
            /** @type {?} */
            const newAppState = setValue(currentAppState, metadata.depth, newValue);
            root.setState(newAppState);
            return newAppState;
            // In doing this refactoring I noticed that there is a 'bug' where the
            // application state is returned instead of this state slice.
            // This has worked this way since the beginning see:
            // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts
            // This needs to be fixed, but is a 'breaking' change.
            // I will do this fix in a subsequent PR and we can decide how to handle it.
        }
        /**
         * @param {?} currentAppState
         * @param {?} stateOperator
         * @return {?}
         */
        function setStateFromOperator(currentAppState, stateOperator) {
            /** @type {?} */
            const local = getState(currentAppState);
            /** @type {?} */
            const newValue = stateOperator(local);
            return setStateValue(currentAppState, newValue);
        }
        /**
         * @param {?} value
         * @return {?}
         */
        function isStateOperator(value) {
            return typeof value === 'function';
        }
        return {
            /**
             * @return {?}
             */
            getState() {
                /** @type {?} */
                const currentAppState = root.getState();
                return getState(currentAppState);
            },
            /**
             * @param {?} val
             * @return {?}
             */
            patchState(val) {
                /** @type {?} */
                const currentAppState = root.getState();
                /** @type {?} */
                const patchOperator = simplePatch(val);
                return setStateFromOperator(currentAppState, patchOperator);
            },
            /**
             * @param {?} val
             * @return {?}
             */
            setState(val) {
                /** @type {?} */
                const currentAppState = root.getState();
                return isStateOperator(val)
                    ? setStateFromOperator(currentAppState, val)
                    : setStateValue(currentAppState, val);
            },
            /**
             * @param {?} actions
             * @return {?}
             */
            dispatch(actions) {
                return root.dispatch(actions);
            }
        };
    }
}
StateContextFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateContextFactory.ctorParameters = () => [
    { type: InternalStateOperations }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class StoreValidators {
    /**
     * @param {?} name
     * @return {?}
     */
    static stateNameErrorMessage(name) {
        return `${name} is not a valid state name. It needs to be a valid object property name.`;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    static checkCorrectStateName(name) {
        if (!name) {
            throw new Error(`States must register a 'name' property`);
        }
        if (!this.stateNameRegex.test(name)) {
            throw new Error(this.stateNameErrorMessage(name));
        }
    }
    /**
     * @param {?} state
     * @param {?} statesByName
     * @return {?}
     */
    static checkStateNameIsUnique(state, statesByName) {
        /** @type {?} */
        const meta = this.getValidStateMeta(state);
        /** @type {?} */
        const stateName = (/** @type {?} */ ((/** @type {?} */ (meta)).name));
        /** @type {?} */
        const existingState = statesByName[stateName];
        if (existingState && existingState !== state) {
            throw new Error(`State name '${stateName}' from ${state.name} already exists in ${existingState.name}`);
        }
        return stateName;
    }
    /**
     * @param {?} state
     * @return {?}
     */
    static getValidStateMeta(state) {
        /** @type {?} */
        const meta = getStoreMetadata(state);
        if (!meta) {
            throw new Error('States must be decorated with @State() decorator');
        }
        return meta;
    }
}
StoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * State factory class
 * @ignore
 */
class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     * @param {?} _internalStateOperations
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _internalStateOperations) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._internalStateOperations = _internalStateOperations;
        this._connected = false;
        this._states = [];
        this._statesByName = {};
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * @return {?}
     */
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    /**
     * @private
     * @return {?}
     */
    get stateTreeRef() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    static cloneDefaults(defaults) {
        /** @type {?} */
        let value = {};
        if (Array.isArray(defaults)) {
            value = [...defaults];
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    static checkStatesAreValid(stateClasses) {
        stateClasses.forEach(StoreValidators.getValidStateMeta);
    }
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    add(stateClasses) {
        StateFactory.checkStatesAreValid(stateClasses);
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        /** @type {?} */
        const stateGraph = buildGraph(newStates);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const depths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(newStates);
        /** @type {?} */
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            /** @type {?} */
            const depth = depths[name];
            /** @type {?} */
            const meta = (/** @type {?} */ (stateClass[META_KEY]));
            this.addRuntimeInfoToMeta(meta, depth);
            /** @type {?} */
            const stateMap = {
                name,
                depth,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, depth)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        /** @type {?} */
        const classes = stateClasses || [];
        /** @type {?} */
        const states = this.add(classes);
        /** @type {?} */
        const defaults = states.reduce((/**
         * @param {?} result
         * @param {?} meta
         * @return {?}
         */
        (result, meta) => setValue(result, meta.depth, meta.defaults)), {});
        return { defaults, states };
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._connected)
            return;
        this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => ctx.status === "DISPATCHED" /* Dispatched */)), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ action }) => this.invokeActions(this._actions, (/** @type {?} */ (action))).pipe(map((/**
         * @return {?}
         */
        () => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ })))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error })))))))))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => this._actionResults.next(ctx)));
        this._connected = true;
    }
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    invokeActions(actions$, action) {
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const type = (/** @type {?} */ (getActionTypeFromInstance(action)));
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            result = result.pipe(actionMeta.options.cancelUncompleted
                                ? // todo: ofActionDispatched should be used with action class
                                    takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action)))))
                                : map((/**
                                 * @param {?} r
                                 * @return {?}
                                 */
                                r => r))); // map acts like a noop
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    addToStatesMap(stateClasses) {
        /** @type {?} */
        const newStates = [];
        /** @type {?} */
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            /** @type {?} */
            const stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
            /** @type {?} */
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    /**
     * @private
     * @param {?} meta
     * @param {?} depth
     * @return {?}
     */
    addRuntimeInfoToMeta(meta, depth) {
        meta.path = depth;
        meta.selectFromAppState = propGetter(depth.split('.'), this._config);
    }
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    hasBeenMountedAndBootstrapped(name, path) {
        /** @type {?} */
        const valueIsBootstrapped = getValue(this.stateTreeRef, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrapped;
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory },
    { type: InternalStateOperations }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LifecycleStateManager {
    /**
     * @param {?} internalStateOperations
     * @param {?} stateContextFactory
     * @param {?} bootstrapper
     */
    constructor(internalStateOperations, stateContextFactory, bootstrapper) {
        this.internalStateOperations = internalStateOperations;
        this.stateContextFactory = stateContextFactory;
        this.bootstrapper = bootstrapper;
    }
    /**
     * @template T
     * @param {?} action
     * @param {?} results
     * @return {?}
     */
    ngxsBootstrap(action, results) {
        this.internalStateOperations
            .getRootStateOperations()
            .dispatch(action)
            .pipe(filter((/**
         * @return {?}
         */
        () => !!results)), tap((/**
         * @return {?}
         */
        () => this.invokeInit((/** @type {?} */ (results)).states))), mergeMap((/**
         * @return {?}
         */
        () => this.bootstrapper.appBootstrapped$)), filter((/**
         * @param {?} appBootstrapped
         * @return {?}
         */
        appBootstrapped => !!appBootstrapped)))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.invokeBootstrap((/** @type {?} */ (results)).states);
        }));
    }
    /**
     * Invoke the init function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    invokeInit(stateMetadatas) {
        this.invokeLifecycleHooks(stateMetadatas, "ngxsOnInit" /* NgxsOnInit */);
    }
    /**
     * Invoke the bootstrap function on the states.
     * @param {?} stateMetadatas
     * @return {?}
     */
    invokeBootstrap(stateMetadatas) {
        this.invokeLifecycleHooks(stateMetadatas, "ngxsAfterBootstrap" /* NgxsAfterBootstrap */);
    }
    /**
     * @private
     * @param {?} stateMetadatas
     * @param {?} hook
     * @return {?}
     */
    invokeLifecycleHooks(stateMetadatas, hook) {
        for (const metadata of stateMetadatas) {
            /** @type {?} */
            const instance = metadata.instance;
            if (instance[hook]) {
                /** @type {?} */
                const stateContext = this.stateContextFactory.createStateContext(metadata);
                (/** @type {?} */ (instance[hook]))(stateContext);
            }
        }
    }
}
LifecycleStateManager.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LifecycleStateManager.ctorParameters = () => [
    { type: InternalStateOperations },
    { type: StateContextFactory },
    { type: NgxsBootstrapper }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Function for creating a selector
 * @template T
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    const wrappedFn = (/** @type {?} */ ((/**
     * @param {...?} args
     * @return {?}
     */
    function wrappedSelectorFn(...args) {
        /** @type {?} */
        const returnValue = originalFn(...args);
        if (returnValue instanceof Function) {
            /** @type {?} */
            const innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    })));
    /** @type {?} */
    const memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    const containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    const fn = (/**
     * @param {?} state
     * @return {?}
     */
    (state) => {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            const metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push(...selectors);
        }
        // Determine arguments from the app state using the selectors
        results.push(...selectorsToApply.map((/**
         * @param {?} a
         * @return {?}
         */
        a => getSelectorFn(a)(state))));
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn(...results);
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    });
    /** @type {?} */
    const selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
function getSelectorFn(selector) {
    /** @type {?} */
    const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Store {
    /**
     * @param {?} _stateStream
     * @param {?} _internalStateOperations
     * @param {?} _config
     * @param {?} _internalExecutionStrategy
     */
    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy) {
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
        this._config = _config;
        this._internalExecutionStrategy = _internalExecutionStrategy;
        this._stateStream.next(this._config.defaultsState);
    }
    /**
     * Dispatches event(s).
     * @param {?} event
     * @return {?}
     */
    dispatch(event) {
        return this._internalStateOperations.getRootStateOperations().dispatch(event);
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    select(selector) {
        /** @type {?} */
        const selectorFn = getSelectorFn(selector);
        return this._stateStream.pipe(map(selectorFn), catchError((/**
         * @param {?} err
         * @return {?}
         */
        err => {
            // if error is TypeError we swallow it to prevent usual errors with property access
            if (err instanceof TypeError) {
                return of(undefined);
            }
            // rethrow other errors
            throw err;
        })), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    selectOnce(selector) {
        return this.select(selector).pipe(take(1));
    }
    /**
     * @param {?} selector
     * @return {?}
     */
    selectSnapshot(selector) {
        /** @type {?} */
        const selectorFn = getSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    }
    /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    subscribe(fn) {
        return this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);
    }
    /**
     * Return the raw value of the state.
     * @return {?}
     */
    snapshot() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    reset(state) {
        return this._internalStateOperations.getRootStateOperations().setState(state);
    }
}
Store.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Store.ctorParameters = () => [
    { type: StateStream },
    { type: InternalStateOperations },
    { type: NgxsConfig },
    { type: InternalNgxsExecutionStrategy }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Allows the select decorator to get access to the DI store.
 * @ignore
 */
class SelectFactory {
    /**
     * @param {?} store
     * @param {?} config
     */
    constructor(store, config) {
        SelectFactory.store = store;
        SelectFactory.config = config;
    }
}
SelectFactory.store = undefined;
SelectFactory.config = undefined;
SelectFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
SelectFactory.ctorParameters = () => [
    { type: Store },
    { type: NgxsConfig }
];
/**
 * Decorator for selecting a slice of state from the store.
 * @param {?=} selectorOrFeature
 * @param {...?} paths
 * @return {?}
 */
function Select(selectorOrFeature, ...paths) {
    return (/**
     * @param {?} target
     * @param {?} name
     * @return {?}
     */
    function (target, name) {
        /** @type {?} */
        const selectorFnName = '__' + name + '__selector';
        if (!selectorOrFeature) {
            selectorOrFeature = removeDollarAtTheEnd(name);
        }
        /** @type {?} */
        const createSelect = (/**
         * @param {?} fn
         * @return {?}
         */
        (fn) => {
            /** @type {?} */
            const store = SelectFactory.store;
            if (!store) {
                throw new Error('SelectFactory not connected to store!');
            }
            return store.select(fn);
        });
        /** @type {?} */
        const createSelector = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const config = SelectFactory.config;
            if (typeof selectorOrFeature === 'string') {
                /** @type {?} */
                const propsArray = paths.length
                    ? [selectorOrFeature, ...paths]
                    : selectorOrFeature.split('.');
                return propGetter(propsArray, (/** @type {?} */ (config)));
            }
            else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {
                return propGetter(selectorOrFeature[META_KEY].path.split('.'), (/** @type {?} */ (config)));
            }
            else {
                return selectorOrFeature;
            }
        });
        if (target[selectorFnName]) {
            throw new Error('You cannot use @Select decorator and a ' + selectorFnName + ' property.');
        }
        if (delete target[name]) {
            Object.defineProperty(target, selectorFnName, {
                writable: true,
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(target, name, {
                get: (/**
                 * @return {?}
                 */
                function () {
                    return (this[selectorFnName] ||
                        (this[selectorFnName] = createSelect.apply(this, [createSelector()])));
                }),
                enumerable: true,
                configurable: true
            });
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Init action
 */
class InitState {
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '@@INIT';
    }
}
/**
 * Update action
 */
class UpdateState {
    /**
     * @return {?}
     */
    static get type() {
        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138
        return '@@UPDATE_STATE';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Root module
 * @ignore
 */
class NgxsRootModule {
    /**
     * @param {?} factory
     * @param {?} internalStateOperations
     * @param {?} store
     * @param {?} select
     * @param {?=} states
     * @param {?=} lifecycleStateManager
     */
    constructor(factory, internalStateOperations, store, select, states = [], lifecycleStateManager) {
        // add stores to the state graph and return their defaults
        /** @type {?} */
        const results = factory.addAndReturnDefaults(states);
        internalStateOperations.setStateToTheCurrentWithNew(results);
        // connect our actions stream
        factory.connectActionHandlers();
        // dispatch the init action and invoke init and bootstrap functions after
        lifecycleStateManager.ngxsBootstrap(new InitState(), results);
    }
}
NgxsRootModule.decorators = [
    { type: NgModule }
];
/** @nocollapse */
NgxsRootModule.ctorParameters = () => [
    { type: StateFactory },
    { type: InternalStateOperations },
    { type: Store },
    { type: SelectFactory },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [ROOT_STATE_TOKEN,] }] },
    { type: LifecycleStateManager }
];
/**
 * Feature module
 * @ignore
 */
class NgxsFeatureModule {
    /**
     * @param {?} store
     * @param {?} internalStateOperations
     * @param {?} factory
     * @param {?} states
     * @param {?} lifecycleStateManager
     */
    constructor(store, internalStateOperations, factory, states, lifecycleStateManager) {
        // Since FEATURE_STATE_TOKEN is a multi token, we need to
        // flatten it [[Feature1State, Feature2State], [Feature3State]]
        /** @type {?} */
        const flattenedStates = ((/** @type {?} */ ([]))).concat(...states);
        // add stores to the state graph and return their defaults
        /** @type {?} */
        const results = factory.addAndReturnDefaults(flattenedStates);
        if (results.states.length) {
            internalStateOperations.setStateToTheCurrentWithNew(results);
            // dispatch the update action and invoke init and bootstrap functions after
            lifecycleStateManager.ngxsBootstrap(new UpdateState(), results);
        }
    }
}
NgxsFeatureModule.decorators = [
    { type: NgModule, args: [{},] }
];
/** @nocollapse */
NgxsFeatureModule.ctorParameters = () => [
    { type: Store },
    { type: InternalStateOperations },
    { type: StateFactory },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FEATURE_STATE_TOKEN,] }] },
    { type: LifecycleStateManager }
];
/**
 * @param {?} options
 * @return {?}
 */
function ngxsConfigFactory(options) {
    /** @type {?} */
    const config = Object.assign(new NgxsConfig(), options);
    return config;
}
/**
 * @param {?} bootstrapper
 * @return {?}
 */
function appBootstrapListenerFactory(bootstrapper) {
    return (/**
     * @return {?}
     */
    () => bootstrapper.bootstrap());
}
/** @type {?} */
const ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');
/**
 * Ngxs Module
 */
class NgxsModule {
    /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    static forRoot(states = [], options = {}) {
        return {
            ngModule: NgxsRootModule,
            providers: [
                StateFactory,
                StateContextFactory,
                Actions,
                InternalActions,
                NgxsBootstrapper,
                ConfigValidator,
                LifecycleStateManager,
                InternalDispatcher,
                InternalDispatchedActionResults,
                InternalStateOperations,
                InternalNgxsExecutionStrategy,
                Store,
                StateStream,
                SelectFactory,
                PluginManager,
                ...states,
                {
                    provide: NGXS_EXECUTION_STRATEGY,
                    useClass: options.executionStrategy || DispatchOutsideZoneNgxsExecutionStrategy
                },
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                },
                {
                    provide: ROOT_OPTIONS,
                    useValue: options
                },
                {
                    provide: NgxsConfig,
                    useFactory: ngxsConfigFactory,
                    deps: [ROOT_OPTIONS]
                },
                {
                    provide: APP_BOOTSTRAP_LISTENER,
                    useFactory: appBootstrapListenerFactory,
                    multi: true,
                    deps: [NgxsBootstrapper]
                }
            ]
        };
    }
    /**
     * Feature module factory
     * @param {?=} states
     * @return {?}
     */
    static forFeature(states = []) {
        return {
            ngModule: NgxsFeatureModule,
            providers: [
                StateFactory,
                PluginManager,
                ...states,
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ]
        };
    }
}
NgxsModule.decorators = [
    { type: NgModule, args: [{},] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates a method with a action information.
 * @param {?} actions
 * @param {?=} options
 * @return {?}
 */
function Action(actions, options) {
    return (/**
     * @param {?} target
     * @param {?} name
     * @param {?} _descriptor
     * @return {?}
     */
    function (target, name, _descriptor) {
        /** @type {?} */
        const meta = ensureStoreMetadata(target.constructor);
        if (!Array.isArray(actions)) {
            actions = [actions];
        }
        for (const action of actions) {
            /** @type {?} */
            const type = action.type;
            if (!meta.actions[type]) {
                meta.actions[type] = [];
            }
            meta.actions[type].push({
                fn: name,
                options: options || {},
                type
            });
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorates a class with ngxs state information.
 * @template T
 * @param {?} options
 * @return {?}
 */
function State(options) {
    /**
     * @param {?} inheritedStateClass
     * @return {?}
     */
    function getStateOptions(inheritedStateClass) {
        /** @type {?} */
        const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};
        return (/** @type {?} */ (Object.assign({}, inheritanceOptions, options)));
    }
    /**
     * @param {?} params
     * @return {?}
     */
    function mutateMetaData(params) {
        const { meta, inheritedStateClass, optionsWithInheritance } = params;
        const { children, defaults, name } = optionsWithInheritance;
        StoreValidators.checkCorrectStateName(name);
        if (inheritedStateClass.hasOwnProperty(META_KEY)) {
            /** @type {?} */
            const inheritedMeta = inheritedStateClass[META_KEY] || {};
            meta.actions = Object.assign({}, meta.actions, inheritedMeta.actions);
        }
        meta.children = children;
        meta.defaults = defaults;
        meta.name = name;
    }
    return (/**
     * @param {?} target
     * @return {?}
     */
    (target) => {
        /** @type {?} */
        const meta = ensureStoreMetadata(target);
        /** @type {?} */
        const inheritedStateClass = Object.getPrototypeOf(target);
        /** @type {?} */
        const optionsWithInheritance = getStateOptions(inheritedStateClass);
        mutateMetaData({ meta, inheritedStateClass, optionsWithInheritance });
        target[META_OPTIONS_KEY] = optionsWithInheritance;
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Decorator for memoizing a state selector.
 * @param {?=} selectors
 * @return {?}
 */
function Selector(selectors) {
    return (/**
     * @param {?} target
     * @param {?} methodName
     * @param {?} descriptor
     * @return {?}
     */
    (target, methodName, descriptor) => {
        if (descriptor.value !== null) {
            /** @type {?} */
            const originalFn = descriptor.value;
            /** @type {?} */
            const memoizedFn = createSelector(selectors, originalFn.bind(target), { containerClass: target, selectorName: methodName });
            return {
                configurable: true,
                /**
                 * @return {?}
                 */
                get() {
                    return memoizedFn;
                }
            };
        }
        else {
            throw new Error('Selectors only work on methods');
        }
    });
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NoopNgxsExecutionStrategy {
    /**
     * @template T
     * @param {?} func
     * @return {?}
     */
    enter(func) {
        return func();
    }
    /**
     * @template T
     * @param {?} func
     * @return {?}
     */
    leave(func) {
        return func();
    }
}
NoopNgxsExecutionStrategy.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxsModule, Action, Store, State, Select, Actions, getSelectorMetadata, getStoreMetadata, ensureStoreMetadata, ensureSelectorMetadata, ofAction, ofActionDispatched, ofActionSuccessful, ofActionCanceled, ofActionErrored, ofActionCompleted, Selector, getActionTypeFromInstance, actionMatcher, createSelector, NoopNgxsExecutionStrategy, NGXS_PLUGINS, StateStream, setValue, getValue, InitState, UpdateState, InternalActions as ɵh, OrderedSubject as ɵg, SelectFactory as ɵf, DispatchOutsideZoneNgxsExecutionStrategy as ɵx, InternalNgxsExecutionStrategy as ɵu, NGXS_EXECUTION_STRATEGY as ɵn, ConfigValidator as ɵv, InternalDispatchedActionResults as ɵp, InternalDispatcher as ɵq, LifecycleStateManager as ɵw, StateContextFactory as ɵr, StateFactory as ɵo, InternalStateOperations as ɵs, NgxsFeatureModule as ɵb, NgxsRootModule as ɵa, ROOT_OPTIONS as ɵe, appBootstrapListenerFactory as ɵd, ngxsConfigFactory as ɵc, PluginManager as ɵt, FEATURE_STATE_TOKEN as ɵk, NgxsConfig as ɵm, ROOT_STATE_TOKEN as ɵj, SELECTOR_META_KEY as ɵl };

//# sourceMappingURL=ngxs-store.js.map