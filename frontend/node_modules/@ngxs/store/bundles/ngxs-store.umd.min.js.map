{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@ngxs/store/src/execution/dispatch-outside-zone-ngxs-execution-strategy.ts","ng://@ngxs/store/src/symbols.ts","ng://@ngxs/store/src/execution/symbols.ts","ng://@ngxs/store/src/internal/internals.ts","ng://@ngxs/store/src/utils/utils.ts","ng://@ngxs/store/src/operators/of-action.ts","ng://@ngxs/store/src/execution/internal-ngxs-execution-strategy.ts","ng://@ngxs/store/src/operators/leave-ngxs.ts","ng://@ngxs/store/src/actions-stream.ts","ng://@ngxs/store/src/utils/compose.ts","ng://@ngxs/store/src/internal/state-stream.ts","ng://@ngxs/store/src/plugin-manager.ts","ng://@ngxs/store/src/internal/dispatcher.ts","ng://@ngxs/store/src/utils/memoize.ts","ng://@ngxs/store/src/utils/angular.ts","ng://@ngxs/store/src/internal/config-validator.ts","ng://@ngxs/store/src/utils/freeze.ts","ng://@ngxs/store/src/internal/state-operations.ts","ng://@ngxs/store/src/internal/state-context-factory.ts","ng://@ngxs/store/src/internal/state-operators.ts","ng://@ngxs/store/src/utils/store-validators.ts","ng://@ngxs/store/src/internal/state-factory.ts","ng://@ngxs/store/src/internal/lifecycle-state-manager.ts","ng://@ngxs/store/src/utils/selector-utils.ts","ng://@ngxs/store/src/store.ts","ng://@ngxs/store/src/decorators/select.ts","ng://@ngxs/store/src/actions/actions.ts","ng://@ngxs/store/src/module.ts","ng://@ngxs/store/src/execution/noop-ngxs-execution-strategy.ts","ng://@ngxs/store/src/decorators/action.ts","ng://@ngxs/store/src/decorators/state.ts","ng://@ngxs/store/src/decorators/selector.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__values","o","m","Symbol","iterator","next","value","done","__read","r","e","ar","push","error","__spread","concat","DispatchOutsideZoneNgxsExecutionStrategy","_ngZone","_platformId","verifyZoneIsNotNooped","enter","func","isPlatformServer","runInsideAngular","runOutsideAngular","leave","NgZone","isInAngularZone","run","ngZone","Injectable","decorators","type","Inject","args","PLATFORM_ID","ROOT_STATE_TOKEN","InjectionToken","FEATURE_STATE_TOKEN","META_KEY","META_OPTIONS_KEY","SELECTOR_META_KEY","NGXS_PLUGINS","NgxsConfig","defaultsState","compatibility","strictContentSecurityPolicy","executionStrategy","NGXS_EXECUTION_STRATEGY","ensureStoreMetadata","target","defineProperty","name","actions","defaults","path","selectFromAppState","children","instance","getStoreMetadata","ensureSelectorMetadata","originalFn","containerClass","selectorName","getSelectorMetadata","propGetter","paths","config","compliantPropGetter","copyOfPaths","obj","reduce","acc","part","fastPropGetter","segments","seg","l","expr","Function","DOLLAR_CHAR_CODE","getActionTypeFromInstance","action","setValue","prop","val","split","lastIndex","index","isArray","getValue","ofActionDispatched","allowedTypes","_i","ofActionOperator","statuses","mapOperator","mapAction","allowedMap","createAllowedActionTypesMap","types","filterMap","klass","allowedStatusMap","createAllowedStatusesMap","status","pipe","filterStatus","allowedStatuses","filter","ctx","actionType","typeMatch","statusMatch","mapActionResult","map","_a","result","successful","canceled","InternalNgxsExecutionStrategy","_executionStrategy","leaveNgxs","ngxsExecutionStrategy","source","Observable","sink","subscribe","complete","OrderedSubject","_this","_super","_itemQueue","_busyPushingNext","tslib_1.__extends","unshift","nextValue","pop","Subject","InternalActions","Actions","actions$","internalExecutionStrategy","observer","res","err","compose","funcs","shift","nextArgs","StateStream","BehaviorSubject","PluginManager","_parentManager","_plugins","plugins","register","plugin","handle","bind","Optional","SkipSelf","InternalDispatchedActionResults","InternalDispatcher","_errorHandler","_actions","_actionResults","_pluginManager","_stateStream","_ngxsExecutionStrategy","dispatch","actionOrActions","dispatchByEvents","handleError","forkJoin","a","dispatchSingle","prevState","nextState","nextAction","actionResult$","getActionResultStream","createDispatchObservable","shareReplay","take","exhaustMap","of","throwError","empty","ErrorHandler","defaultEqualityCheck","memoize","equalityCheck","lastArgs","lastResult","memoized","areArgumentsShallowlyEqual","prev","reset","isAngularInTestMode","_isAngularInTestMode","platformRef","getPlatform","compilerOptions","injector","get","COMPILER_OPTIONS","some","item","providers","provider","provide","ConfigValidator","_config","verifyDevMode","isNgxsDevMode","developmentMode","isNgDevMode","isDevMode","incorrectDevelopment","example","console","warn","deepFreeze","freeze","oIsFunction","hasOwnProp","getOwnPropertyNames","forEach","isFrozen","InternalStateOperations","_dispatcher","configValidator","getRootStateOperations","rootStateOperations","getState","setState","newState","ensureStateAndActionsAreImmutable","root","frozenValue","setStateToTheCurrentWithNew","results","stateOperations","currentState","StateContextFactory","_internalStateOperations","createStateContext","metadata","currentAppState","depth","setStateValue","newValue","newAppState","setStateFromOperator","stateOperator","patchState","simplePatch","existingState","isPrimitive","Error","k","isStateOperator","StoreValidators","stateNameErrorMessage","checkCorrectStateName","stateNameRegex","test","checkStateNameIsUnique","state","statesByName","stateName","getValidStateMeta","meta","RegExp","StateFactory","_injector","_parentFactory","_stateContextFactory","_connected","_states","_statesByName","states","cloneDefaults","isObject","undefined","checkStatesAreValid","stateClasses","add","newStates","addToStatesMap","stateGraph","buildGraph","findName","stateClass","find","g","sortedStates","topologicalSort","graph","sorted","visited","visit","ancestors","dep","indexOf","join","slice","keys","reverse","depths","findFullParentPath","newObj","child","keyToFind","key","parent_1","parent_2","nameGraph","nameToState","bootstrappedStores","sortedStates_1","tslib_1.__values","sortedStates_1_1","name_1","addRuntimeInfoToMeta","stateMap","hasBeenMountedAndBootstrapped","addAndReturnDefaults","classes","connectActionHandlers","mergeMap","invokeActions","defaultIfEmpty","catchError","_c","_d","actionMetas","actionMetas_1","actionMetas_1_1","actionMeta","stateContext","fn","Promise","from","options","cancelUncompleted","takeUntil","statesMap","stateClasses_1","stateClasses_1_1","valueIsBootstrapped","stateTreeRef","Injector","LifecycleStateManager","internalStateOperations","stateContextFactory","bootstrapper","ngxsBootstrap","tap","invokeInit","appBootstrapped$","appBootstrapped","invokeBootstrap","stateMetadatas","invokeLifecycleHooks","hook","stateMetadatas_1","stateMetadatas_1_1","NgxsBootstrapper","createSelector","selectors","creationMetadata","memoizedFn","returnValue","selectorMetaData","selectorsToApply","getSelectorFn","ex","TypeError","selector","Store","_internalExecutionStrategy","event","select","selectorFn","distinctUntilChanged","selectOnce","selectSnapshot","snapshot","SelectFactory","store","InitState","UpdateState","NgxsRootModule","factory","lifecycleStateManager","NgModule","NgxsFeatureModule","flattenedStates","ngxsConfigFactory","appBootstrapListenerFactory","bootstrap","ROOT_OPTIONS","NgxsModule","forRoot","ngModule","useClass","useValue","useFactory","deps","APP_BOOTSTRAP_LISTENER","multi","forFeature","NoopNgxsExecutionStrategy","Action","_descriptor","actions_1","actions_1_1","State","inheritedStateClass","getPrototypeOf","optionsWithInheritance","getStateOptions","inheritanceOptions","mutateMetaData","params","inheritedMeta","Select","selectorOrFeature","selectorFnName","removeDollarAtTheEnd","lastCharIndex","charCodeAt","writable","enumerable","configurable","ofAction","ofActionSuccessful","ofActionCanceled","ofActionErrored","ofActionCompleted","Selector","methodName","descriptor","memoizedFn_1","actionMatcher","action1","type1","action2"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\r\n  NgZone,\r\n  PLATFORM_ID,\r\n  Injectable,\r\n  ÉµNoopNgZone as NoopNgZone,\r\n  Inject\r\n} from '@angular/core';\r\nimport { isPlatformServer } from '@angular/common';\r\n\r\nimport { NgxsExecutionStrategy } from './symbols';\r\n\r\n@Injectable()\r\nexport class DispatchOutsideZoneNgxsExecutionStrategy implements NgxsExecutionStrategy {\r\n  constructor(private _ngZone: NgZone, @Inject(PLATFORM_ID) private _platformId: Object) {\r\n    this.verifyZoneIsNotNooped(this._ngZone);\r\n  }\r\n\r\n  enter<T>(func: () => T): T {\r\n    if (isPlatformServer(this._platformId)) {\r\n      return this.runInsideAngular(func);\r\n    }\r\n    return this.runOutsideAngular(func);\r\n  }\r\n\r\n  leave<T>(func: () => T): T {\r\n    return this.runInsideAngular(func);\r\n  }\r\n\r\n  private runInsideAngular<T>(func: () => T): T {\r\n    if (NgZone.isInAngularZone()) {\r\n      return func();\r\n    }\r\n    return this._ngZone.run(func);\r\n  }\r\n\r\n  private runOutsideAngular<T>(func: () => T): T {\r\n    if (NgZone.isInAngularZone()) {\r\n      return this._ngZone.runOutsideAngular(func);\r\n    }\r\n    return func();\r\n  }\r\n\r\n  private verifyZoneIsNotNooped(ngZone: NgZone): void {\r\n    /* - Removed because unsafe for Angular 5 - investigate\r\n    if (ngZone instanceof NoopNgZone) {\r\n      console.warn(\r\n        'Your application was bootstrapped with nooped zone and your execution strategy requires an ngZone'\r\n      );\r\n    }\r\n    */\r\n  }\r\n}\r\n","import { Injectable, InjectionToken, Type } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n\r\nimport { ObjectKeyMap } from './internal/internals';\r\nimport { NgxsExecutionStrategy } from './execution/symbols';\r\nimport { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';\r\n\r\nexport const ROOT_STATE_TOKEN = new InjectionToken<any>('ROOT_STATE_TOKEN');\r\nexport const FEATURE_STATE_TOKEN = new InjectionToken<any>('FEATURE_STATE_TOKEN');\r\nexport const META_KEY = 'NGXS_META';\r\nexport const META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\r\nexport const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\r\n\r\nexport const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\r\nexport type NgxsPluginFn = (state: any, mutation: any, next: NgxsNextPluginFn) => any;\r\n\r\n/**\r\n * The NGXS config settings.\r\n */\r\n@Injectable()\r\nexport class NgxsConfig {\r\n  /**\r\n   * Run in development mode. This will add additional debugging features:\r\n   * - Object.freeze on the state and actions to guarantee immutability\r\n   * (default: false)\r\n   */\r\n  developmentMode: boolean;\r\n  compatibility: {\r\n    /**\r\n     * Support a strict Content Security Policy.\r\n     * This will cirumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.\r\n     * (default: false)\r\n     */\r\n    strictContentSecurityPolicy: boolean;\r\n  };\r\n  /**\r\n   * Determines the execution context to perform async operations inside. An implementation can be\r\n   * provided to override the default behaviour where the async operations are run\r\n   * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.\r\n   * These observable behaviours are from:\r\n   *   `@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`\r\n   * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your\r\n   * application doesn't rely on zone.js running change detection then you can switch to the\r\n   * `NoopNgxsExecutionStrategy` that doesn't interact with zones.\r\n   * (default: null)\r\n   */\r\n  executionStrategy: Type<NgxsExecutionStrategy>;\r\n  /**\r\n   * Defining the default state before module initialization\r\n   * This is convenient if we need to create a define our own set of states.\r\n   * (default: {})\r\n   */\r\n  defaultsState: ObjectKeyMap<any> = {};\r\n\r\n  constructor() {\r\n    this.compatibility = {\r\n      strictContentSecurityPolicy: false\r\n    };\r\n    this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\r\n  }\r\n}\r\n\r\nexport interface ActionDef {\r\n  type: string;\r\n\r\n  new (...args: any[]): any;\r\n}\r\n\r\nexport type StateOperator<T> = (existing: Readonly<T>) => T;\r\n\r\n/**\r\n * State context provided to the actions in the state.\r\n */\r\nexport interface StateContext<T> {\r\n  /**\r\n   * Get the current state.\r\n   */\r\n  getState(): T;\r\n\r\n  /**\r\n   * Reset the state to a new value.\r\n   */\r\n  setState(val: T | StateOperator<T>): T;\r\n\r\n  /**\r\n   * Patch the existing state with the provided value.\r\n   */\r\n  patchState(val: Partial<T>): T;\r\n\r\n  /**\r\n   * Dispatch a new action and return the dispatched observable.\r\n   */\r\n  dispatch(actions: any | any[]): Observable<void>;\r\n}\r\n\r\nexport type NgxsNextPluginFn = (state: any, mutation: any) => any;\r\n\r\n/**\r\n * Plugin interface\r\n */\r\nexport interface NgxsPlugin {\r\n  /**\r\n   * Handle the state/action before its submitted to the state handlers.\r\n   */\r\n  handle(state: any, action: any, next: NgxsNextPluginFn): any;\r\n}\r\n\r\n/**\r\n * Options that can be provided to the store.\r\n */\r\nexport interface StoreOptions<T> {\r\n  /**\r\n   * Name of the state. Required.\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Default values for the state. If not provided, uses empty object.\r\n   */\r\n  defaults?: T;\r\n\r\n  /**\r\n   * Sub states for the given state.\r\n   */\r\n  children?: any[];\r\n}\r\n\r\n/**\r\n * Actions that can be provided in a action decorator.\r\n */\r\nexport interface ActionOptions {\r\n  /**\r\n   * Cancel the previous uncompleted observable(s).\r\n   */\r\n  cancelUncompleted?: boolean;\r\n}\r\n\r\nexport const enum LifecycleHooks {\r\n  NgxsOnInit = 'ngxsOnInit',\r\n  NgxsAfterBootstrap = 'ngxsAfterBootstrap'\r\n}\r\n\r\n/**\r\n * On init interface\r\n */\r\nexport interface NgxsOnInit {\r\n  ngxsOnInit(ctx?: StateContext<any>): void | any;\r\n}\r\n\r\n/**\r\n * After bootstrap interface\r\n */\r\nexport interface NgxsAfterBootstrap {\r\n  ngxsAfterBootstrap(ctx?: StateContext<any>): void;\r\n}\r\n\r\nexport type NgxsLifeCycle = Partial<NgxsOnInit> & Partial<NgxsAfterBootstrap>;\r\n","import { InjectionToken } from '@angular/core';\r\n\r\n/*\r\n * Internal execution strategy injection token\r\n */\r\nexport const NGXS_EXECUTION_STRATEGY = new InjectionToken<NgxsExecutionStrategy>(\r\n  'NGXS_EXECUTION_STRATEGY'\r\n);\r\n\r\n/*\r\n * Execution strategy interface\r\n */\r\nexport interface NgxsExecutionStrategy {\r\n  enter<T>(func: () => T): T;\r\n  leave<T>(func: () => T): T;\r\n}\r\n","import {\r\n  ActionOptions,\r\n  META_KEY,\r\n  META_OPTIONS_KEY,\r\n  NgxsConfig,\r\n  SELECTOR_META_KEY,\r\n  StoreOptions\r\n} from '../symbols';\r\nimport { Observable } from 'rxjs';\r\n\r\nexport interface ObjectKeyMap<T> {\r\n  [key: string]: T;\r\n}\r\n\r\n// inspired from https://stackoverflow.com/a/43674389\r\nexport interface StateClass<T = any, U = any> {\r\n  [META_KEY]?: MetaDataModel;\r\n  [META_OPTIONS_KEY]?: StoreOptions<U>;\r\n\r\n  new (...args: any[]): T;\r\n}\r\n\r\nexport type StateKeyGraph = ObjectKeyMap<string[]>;\r\nexport type StatesByName = ObjectKeyMap<StateClass>;\r\n\r\nexport interface ActionHandlerMetaData {\r\n  fn: string | symbol;\r\n  options: ActionOptions;\r\n  type: string;\r\n}\r\n\r\nexport interface StateOperations<T> {\r\n  getState(): T;\r\n\r\n  setState(val: T): T;\r\n\r\n  dispatch(actions: any | any[]): Observable<void>;\r\n}\r\n\r\nexport interface MetaDataModel {\r\n  name: string | null;\r\n  actions: ObjectKeyMap<ActionHandlerMetaData[]>;\r\n  defaults: any;\r\n  path: string | null;\r\n  selectFromAppState: SelectFromState | null;\r\n  children?: StateClass[];\r\n  instance: any;\r\n}\r\n\r\nexport type SelectFromState = (state: any) => any;\r\n\r\nexport interface SelectorMetaDataModel {\r\n  selectFromAppState: SelectFromState | null;\r\n  originalFn: Function | null;\r\n  containerClass: any;\r\n  selectorName: string | null;\r\n}\r\n\r\nexport interface MappedStore {\r\n  name: string;\r\n  actions: ObjectKeyMap<ActionHandlerMetaData[]>;\r\n  defaults: any;\r\n  instance: any;\r\n  depth: string;\r\n}\r\n\r\nexport interface StatesAndDefaults {\r\n  defaults: any;\r\n  states: MappedStore[];\r\n}\r\n\r\n/**\r\n * Ensures metadata is attached to the class and returns it.\r\n *\r\n * @ignore\r\n */\r\nexport function ensureStoreMetadata(target: StateClass): MetaDataModel {\r\n  if (!target.hasOwnProperty(META_KEY)) {\r\n    const defaultMetadata: MetaDataModel = {\r\n      name: null,\r\n      actions: {},\r\n      defaults: {},\r\n      path: null,\r\n      selectFromAppState: null,\r\n      children: [],\r\n      instance: null\r\n    };\r\n\r\n    Object.defineProperty(target, META_KEY, { value: defaultMetadata });\r\n  }\r\n  return getStoreMetadata(target);\r\n}\r\n\r\n/**\r\n * Get the metadata attached to the state class if it exists.\r\n *\r\n * @ignore\r\n */\r\nexport function getStoreMetadata(target: StateClass): MetaDataModel {\r\n  return target[META_KEY]!;\r\n}\r\n\r\n/**\r\n * Ensures metadata is attached to the selector and returns it.\r\n *\r\n * @ignore\r\n */\r\nexport function ensureSelectorMetadata(target: Function): SelectorMetaDataModel {\r\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\r\n    const defaultMetadata: SelectorMetaDataModel = {\r\n      selectFromAppState: null,\r\n      originalFn: null,\r\n      containerClass: null,\r\n      selectorName: null\r\n    };\r\n\r\n    Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });\r\n  }\r\n\r\n  return getSelectorMetadata(target);\r\n}\r\n\r\n/**\r\n * Get the metadata attached to the selector if it exists.\r\n *\r\n * @ignore\r\n */\r\nexport function getSelectorMetadata(target: any): SelectorMetaDataModel {\r\n  return target[SELECTOR_META_KEY];\r\n}\r\n\r\n/**\r\n * Get a deeply nested value. Example:\r\n *\r\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\r\n *\r\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\r\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\r\n *\r\n * @ignore\r\n */\r\nfunction compliantPropGetter(paths: string[]): (x: any) => any {\r\n  const copyOfPaths = [...paths];\r\n  return obj => copyOfPaths.reduce((acc: any, part: string) => acc && acc[part], obj);\r\n}\r\n\r\n/**\r\n * The generated function is faster than:\r\n * - pluck (Observable operator)\r\n * - memoize\r\n *\r\n * @ignore\r\n */\r\nfunction fastPropGetter(paths: string[]): (x: any) => any {\r\n  const segments = paths;\r\n  let seg = 'store.' + segments[0];\r\n  let i = 0;\r\n  const l = segments.length;\r\n\r\n  let expr = seg;\r\n  while (++i < l) {\r\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\r\n  }\r\n\r\n  const fn = new Function('store', 'return ' + expr + ';');\r\n\r\n  return <(x: any) => any>fn;\r\n}\r\n\r\n/**\r\n * Get a deeply nested value. Example:\r\n *\r\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\r\n *\r\n * @ignore\r\n */\r\nexport function propGetter(paths: string[], config: NgxsConfig) {\r\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\r\n    return compliantPropGetter(paths);\r\n  } else {\r\n    return fastPropGetter(paths);\r\n  }\r\n}\r\n\r\n/**\r\n * Given an array of states, it will return a object graph. Example:\r\n *    const states = [\r\n *      Cart,\r\n *      CartSaved,\r\n *      CartSavedItems\r\n *    ]\r\n *\r\n * would return:\r\n *\r\n *  const graph = {\r\n *    cart: ['saved'],\r\n *    saved: ['items'],\r\n *    items: []\r\n *  };\r\n *\r\n * @ignore\r\n */\r\nexport function buildGraph(stateClasses: StateClass[]): StateKeyGraph {\r\n  const findName = (stateClass: StateClass) => {\r\n    const meta = stateClasses.find(g => g === stateClass);\r\n    if (!meta) {\r\n      throw new Error(\r\n        `Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`\r\n      );\r\n    }\r\n\r\n    return meta[META_KEY]!.name!;\r\n  };\r\n\r\n  return stateClasses.reduce<StateKeyGraph>(\r\n    (result: StateKeyGraph, stateClass: StateClass) => {\r\n      const { name, children } = stateClass[META_KEY]!;\r\n      result[name!] = (children || []).map(findName);\r\n      return result;\r\n    },\r\n    {}\r\n  );\r\n}\r\n\r\n/**\r\n * Given a states array, returns object graph\r\n * returning the name and state metadata. Example:\r\n *\r\n *  const graph = {\r\n *    cart: { metadata }\r\n *  };\r\n *\r\n * @ignore\r\n */\r\nexport function nameToState(states: StateClass[]): ObjectKeyMap<StateClass> {\r\n  return states.reduce<ObjectKeyMap<StateClass>>(\r\n    (result: ObjectKeyMap<StateClass>, stateClass: StateClass) => {\r\n      const meta = stateClass[META_KEY]!;\r\n      result[meta.name!] = stateClass;\r\n      return result;\r\n    },\r\n    {}\r\n  );\r\n}\r\n\r\n/**\r\n * Given a object relationship graph will return the full path\r\n * for the child items. Example:\r\n *\r\n *  const graph = {\r\n *    cart: ['saved'],\r\n *    saved: ['items'],\r\n *    items: []\r\n *  };\r\n *\r\n * would return:\r\n *\r\n *  const r = {\r\n *    cart: 'cart',\r\n *    saved: 'cart.saved',\r\n *    items: 'cart.saved.items'\r\n *  };\r\n *\r\n * @ignore\r\n */\r\nexport function findFullParentPath(\r\n  obj: StateKeyGraph,\r\n  newObj: ObjectKeyMap<string> = {}\r\n): ObjectKeyMap<string> {\r\n  const visit = (child: StateKeyGraph, keyToFind: string): string | null => {\r\n    for (const key in child) {\r\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\r\n        const parent = visit(child, key);\r\n        return parent !== null ? `${parent}.${key}` : key;\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  for (const key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      const parent = visit(obj, key);\r\n      newObj[key] = parent ? `${parent}.${key}` : key;\r\n    }\r\n  }\r\n\r\n  return newObj;\r\n}\r\n\r\n/**\r\n * Given a object graph, it will return the items topologically sorted Example:\r\n *\r\n *  const graph = {\r\n *    cart: ['saved'],\r\n *    saved: ['items'],\r\n *    items: []\r\n *  };\r\n *\r\n * would return:\r\n *\r\n *  const results = [\r\n *    'items',\r\n *    'saved',\r\n *    'cart'\r\n *  ];\r\n *\r\n * @ignore\r\n */\r\nexport function topologicalSort(graph: StateKeyGraph): string[] {\r\n  const sorted: string[] = [];\r\n  const visited: ObjectKeyMap<boolean> = {};\r\n\r\n  const visit = (name: string, ancestors: string[] = []) => {\r\n    if (!Array.isArray(ancestors)) {\r\n      ancestors = [];\r\n    }\r\n\r\n    ancestors.push(name);\r\n    visited[name] = true;\r\n\r\n    graph[name].forEach((dep: string) => {\r\n      if (ancestors.indexOf(dep) >= 0) {\r\n        throw new Error(\r\n          `Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`\r\n        );\r\n      }\r\n\r\n      if (visited[dep]) {\r\n        return;\r\n      }\r\n\r\n      visit(dep, ancestors.slice(0));\r\n    });\r\n\r\n    if (sorted.indexOf(name) < 0) {\r\n      sorted.push(name);\r\n    }\r\n  };\r\n\r\n  Object.keys(graph).forEach(k => visit(k));\r\n\r\n  return sorted.reverse();\r\n}\r\n\r\n/**\r\n * Returns if the parameter is a object or not.\r\n *\r\n * @ignore\r\n */\r\nexport function isObject(obj: any) {\r\n  return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';\r\n}\r\n\r\nconst DOLLAR_CHAR_CODE = 36;\r\n\r\n/**\r\n * If `foo$` => make it just `foo`\r\n *\r\n * @ignore\r\n */\r\nexport function removeDollarAtTheEnd(name: string): string {\r\n  const lastCharIndex = name.length - 1;\r\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\r\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\r\n}\r\n","/**\r\n * Returns the type from an action instance/class.\r\n * @ignore\r\n */\r\nexport function getActionTypeFromInstance(action: any): string | undefined {\r\n  if (action.constructor && action.constructor.type) {\r\n    return action.constructor.type;\r\n  }\r\n\r\n  return action.type;\r\n}\r\n\r\nexport function getActionTypeFromClass<T = any>(actionClass: any): string {\r\n  return actionClass.type;\r\n}\r\n\r\n/**\r\n * Matches a action\r\n * @ignore\r\n */\r\nexport function actionMatcher(action1: any) {\r\n  const type1 = getActionTypeFromInstance(action1);\r\n\r\n  return function(action2: any) {\r\n    return type1 === getActionTypeFromInstance(action2);\r\n  };\r\n}\r\n\r\n/**\r\n * Set a deeply nested value. Example:\r\n *\r\n *   setValue({ foo: { bar: { eat: false } } },\r\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\r\n *\r\n * While it traverses it also creates new objects from top down.\r\n *\r\n * @ignore\r\n */\r\nexport const setValue = (obj: any, prop: string, val: any) => {\r\n  obj = { ...obj };\r\n\r\n  const split = prop.split('.');\r\n  const lastIndex = split.length - 1;\r\n\r\n  split.reduce((acc, part, index) => {\r\n    if (index === lastIndex) {\r\n      acc[part] = val;\r\n    } else {\r\n      acc[part] = Array.isArray(acc[part]) ? [...acc[part]] : { ...acc[part] };\r\n    }\r\n\r\n    return acc && acc[part];\r\n  }, obj);\r\n\r\n  return obj;\r\n};\r\n\r\n/**\r\n * Get a deeply nested value. Example:\r\n *\r\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\r\n *\r\n * @ignore\r\n */\r\nexport const getValue = (obj: any, prop: string): any =>\r\n  prop.split('.').reduce((acc: any, part: string) => acc && acc[part], obj);\r\n","import { OperatorFunction, Observable } from 'rxjs';\r\nimport { map, filter } from 'rxjs/operators';\r\nimport { getActionTypeFromInstance } from '../utils/utils';\r\nimport { ActionContext, ActionStatus } from '../actions-stream';\r\n\r\nexport interface ActionCompletion<T = any, E = Error> {\r\n  action: T;\r\n  result: {\r\n    successful: boolean;\r\n    canceled: boolean;\r\n    error?: E;\r\n  };\r\n}\r\n\r\nexport function ofAction<T>(allowedType: any): OperatorFunction<ActionContext, T>;\r\nexport function ofAction<T>(...allowedTypes: any[]): OperatorFunction<ActionContext, T>;\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will grab actions that have just been dispatched as well as actions that have completed\r\n */\r\nexport function ofAction(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just been dispatched\r\n */\r\nexport function ofActionDispatched(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, [ActionStatus.Dispatched]);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just been successfully completed\r\n */\r\nexport function ofActionSuccessful(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, [ActionStatus.Successful]);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just been canceled\r\n */\r\nexport function ofActionCanceled(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, [ActionStatus.Canceled]);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just been completed\r\n */\r\nexport function ofActionCompleted(...allowedTypes: any[]) {\r\n  const allowedStatuses = [\r\n    ActionStatus.Successful,\r\n    ActionStatus.Canceled,\r\n    ActionStatus.Errored\r\n  ];\r\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\r\n}\r\n\r\n/**\r\n * RxJS operator for selecting out specific actions.\r\n *\r\n * This will ONLY grab actions that have just thrown an error\r\n */\r\nexport function ofActionErrored(...allowedTypes: any[]) {\r\n  return ofActionOperator(allowedTypes, [ActionStatus.Errored]);\r\n}\r\n\r\nfunction ofActionOperator<T = any>(\r\n  allowedTypes: any[],\r\n  statuses?: ActionStatus[],\r\n  mapOperator: () => OperatorFunction<ActionContext, T> = mapAction\r\n) {\r\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\r\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\r\n  return function(o: Observable<ActionContext>) {\r\n    return o.pipe(\r\n      filterStatus(allowedMap, allowedStatusMap),\r\n      mapOperator()\r\n    );\r\n  };\r\n}\r\n\r\nfunction filterStatus(allowedTypes: FilterMap, allowedStatuses?: FilterMap) {\r\n  return filter((ctx: ActionContext) => {\r\n    const actionType = getActionTypeFromInstance(ctx.action)!;\r\n    const typeMatch = allowedTypes[actionType];\r\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\r\n    return typeMatch && statusMatch;\r\n  });\r\n}\r\n\r\nfunction mapActionResult(): OperatorFunction<ActionContext, ActionCompletion> {\r\n  return map(({ action, status, error }: ActionContext) => {\r\n    return <ActionCompletion>{\r\n      action,\r\n      result: {\r\n        successful: ActionStatus.Successful === status,\r\n        canceled: ActionStatus.Canceled === status,\r\n        error\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\nfunction mapAction<T = any>(): OperatorFunction<ActionContext, T> {\r\n  return map((ctx: ActionContext) => <T>ctx.action);\r\n}\r\n\r\ntype FilterMap = { [key: string]: boolean };\r\n\r\nfunction createAllowedActionTypesMap(types: any[]): FilterMap {\r\n  return types.reduce(\r\n    (filterMap: FilterMap, klass: any) => {\r\n      filterMap[getActionTypeFromInstance(klass)!] = true;\r\n      return filterMap;\r\n    },\r\n    <FilterMap>{}\r\n  );\r\n}\r\n\r\nfunction createAllowedStatusesMap(statuses: ActionStatus[]): FilterMap {\r\n  return statuses.reduce(\r\n    (filterMap: FilterMap, status: ActionStatus) => {\r\n      filterMap[status] = true;\r\n      return filterMap;\r\n    },\r\n    <FilterMap>{}\r\n  );\r\n}\r\n","import { Injectable, Inject } from '@angular/core';\r\n\r\nimport { NgxsExecutionStrategy, NGXS_EXECUTION_STRATEGY } from './symbols';\r\n\r\n@Injectable()\r\nexport class InternalNgxsExecutionStrategy implements NgxsExecutionStrategy {\r\n  constructor(\r\n    @Inject(NGXS_EXECUTION_STRATEGY) private _executionStrategy: NgxsExecutionStrategy\r\n  ) {}\r\n\r\n  enter<T>(func: () => T): T {\r\n    return this._executionStrategy.enter(func);\r\n  }\r\n\r\n  leave<T>(func: () => T): T {\r\n    return this._executionStrategy.leave(func);\r\n  }\r\n}\r\n","import { MonoTypeOperatorFunction, Observable, Observer } from 'rxjs';\r\nimport { NgxsExecutionStrategy } from '../execution/symbols';\r\n\r\n/**\r\n * Returns operator that will run\r\n * `subscribe` outside of the ngxs execution context\r\n */\r\nexport function leaveNgxs<T>(\r\n  ngxsExecutionStrategy: NgxsExecutionStrategy\r\n): MonoTypeOperatorFunction<T> {\r\n  return (source: Observable<T>) => {\r\n    return new Observable((sink: Observer<T>) => {\r\n      return source.subscribe({\r\n        next(value) {\r\n          ngxsExecutionStrategy.leave(() => sink.next(value));\r\n        },\r\n        error(error) {\r\n          ngxsExecutionStrategy.leave(() => sink.error(error));\r\n        },\r\n        complete() {\r\n          ngxsExecutionStrategy.leave(() => sink.complete());\r\n        }\r\n      });\r\n    });\r\n  };\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable, Subject } from 'rxjs';\r\n\r\nimport { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';\r\nimport { leaveNgxs } from './operators/leave-ngxs';\r\n\r\n/**\r\n * Status of a dispatched action\r\n */\r\nexport const enum ActionStatus {\r\n  Dispatched = 'DISPATCHED',\r\n  Successful = 'SUCCESSFUL',\r\n  Canceled = 'CANCELED',\r\n  Errored = 'ERRORED'\r\n}\r\n\r\nexport interface ActionContext<T = any> {\r\n  status: ActionStatus;\r\n  action: T;\r\n  error?: Error;\r\n}\r\n\r\n/**\r\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\r\n * A standard Subject does not have this guarantee.\r\n * For example, given the following code:\r\n * ```typescript\r\n *   const subject = new Subject<string>();\r\n     subject.subscribe(value => {\r\n       if (value === 'start') subject.next('end');\r\n     });\r\n     subject.subscribe(value => { });\r\n     subject.next('start');\r\n * ```\r\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\r\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\r\n */\r\nexport class OrderedSubject<T> extends Subject<T> {\r\n  private _itemQueue: T[] = [];\r\n  private _busyPushingNext = false;\r\n\r\n  next(value?: T): void {\r\n    if (this._busyPushingNext) {\r\n      this._itemQueue.unshift(value!);\r\n      return;\r\n    }\r\n    this._busyPushingNext = true;\r\n    super.next(value);\r\n    while (this._itemQueue.length > 0) {\r\n      const nextValue = this._itemQueue.pop();\r\n      super.next(nextValue);\r\n    }\r\n    this._busyPushingNext = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Internal Action stream that is emitted anytime an action is dispatched.\r\n */\r\n@Injectable()\r\nexport class InternalActions extends OrderedSubject<ActionContext> {}\r\n\r\n/**\r\n * Action stream that is emitted anytime an action is dispatched.\r\n *\r\n * You can listen to this in services to react without stores.\r\n */\r\n@Injectable()\r\nexport class Actions extends Observable<any> {\r\n  constructor(\r\n    actions$: InternalActions,\r\n    internalExecutionStrategy: InternalNgxsExecutionStrategy\r\n  ) {\r\n    super(observer => {\r\n      actions$\r\n        .pipe(leaveNgxs(internalExecutionStrategy))\r\n        .subscribe(\r\n          res => observer.next(res),\r\n          err => observer.error(err),\r\n          () => observer.complete()\r\n        );\r\n    });\r\n  }\r\n}\r\n","export type StateFn = (...args: any[]) => any;\r\n\r\n/**\r\n * Composes a array of functions from left to right. Example:\r\n *\r\n *      compose([fn, final])(state, action);\r\n *\r\n * then the funcs have a signature like:\r\n *\r\n *      function fn (state, action, next) {\r\n *          console.log('here', state, action, next);\r\n *          return next(state, action);\r\n *      }\r\n *\r\n *      function final (state, action) {\r\n *          console.log('here', state, action);\r\n *          return state;\r\n *      }\r\n *\r\n * the last function should not call `next`.\r\n *\r\n * @ignore\r\n */\r\nexport const compose = (funcs: StateFn[]) => (...args: any[]) => {\r\n  const curr = funcs.shift()!;\r\n  return curr(...args, (...nextArgs: any[]) => compose(funcs)(...nextArgs));\r\n};\r\n","import { Injectable } from '@angular/core';\r\nimport { BehaviorSubject } from 'rxjs';\r\nimport { ObjectKeyMap } from '../internal/internals';\r\n\r\n/**\r\n * BehaviorSubject of the entire state.\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class StateStream extends BehaviorSubject<ObjectKeyMap<any>> {\r\n  constructor() {\r\n    super({});\r\n  }\r\n}\r\n","import { Injectable, Optional, SkipSelf, Inject } from '@angular/core';\r\nimport { NgxsPluginFn, NGXS_PLUGINS, NgxsPlugin } from './symbols';\r\n\r\n/**\r\n * Plugin manager class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class PluginManager {\r\n  plugins: NgxsPluginFn[] = [];\r\n\r\n  constructor(\r\n    @Optional()\r\n    @SkipSelf()\r\n    private _parentManager: PluginManager,\r\n    @Inject(NGXS_PLUGINS)\r\n    @Optional()\r\n    private _plugins: NgxsPlugin[]\r\n  ) {\r\n    this.register();\r\n  }\r\n\r\n  private register() {\r\n    if (!this._plugins) {\r\n      return;\r\n    }\r\n\r\n    this.plugins = this._plugins.map(plugin => {\r\n      if (plugin.handle) {\r\n        return plugin.handle.bind(plugin);\r\n      } else {\r\n        return plugin;\r\n      }\r\n    });\r\n\r\n    if (this._parentManager) {\r\n      this._parentManager.plugins.push(...this.plugins);\r\n    }\r\n  }\r\n}\r\n","import { Injectable, ErrorHandler } from '@angular/core';\r\nimport { Observable, of, forkJoin, empty, Subject, throwError } from 'rxjs';\r\nimport { shareReplay, filter, exhaustMap, take } from 'rxjs/operators';\r\n\r\nimport { compose } from '../utils/compose';\r\nimport { InternalActions, ActionStatus, ActionContext } from '../actions-stream';\r\nimport { StateStream } from './state-stream';\r\nimport { PluginManager } from '../plugin-manager';\r\nimport { NgxsConfig } from '../symbols';\r\nimport { InternalNgxsExecutionStrategy } from '../execution/internal-ngxs-execution-strategy';\r\nimport { leaveNgxs } from '../operators/leave-ngxs';\r\n\r\n/**\r\n * Internal Action result stream that is emitted when an action is completed.\r\n * This is used as a method of returning the action result to the dispatcher\r\n * for the observable returned by the dispatch(...) call.\r\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\r\n */\r\n@Injectable()\r\nexport class InternalDispatchedActionResults extends Subject<ActionContext> {}\r\n\r\n@Injectable()\r\nexport class InternalDispatcher {\r\n  constructor(\r\n    private _errorHandler: ErrorHandler,\r\n    private _actions: InternalActions,\r\n    private _actionResults: InternalDispatchedActionResults,\r\n    private _pluginManager: PluginManager,\r\n    private _stateStream: StateStream,\r\n    private _ngxsExecutionStrategy: InternalNgxsExecutionStrategy\r\n  ) {}\r\n\r\n  /**\r\n   * Dispatches event(s).\r\n   */\r\n  dispatch(actionOrActions: any | any[]): Observable<any> {\r\n    const result = this._ngxsExecutionStrategy.enter(() =>\r\n      this.dispatchByEvents(actionOrActions)\r\n    );\r\n\r\n    result.subscribe({\r\n      error: error =>\r\n        this._ngxsExecutionStrategy.leave(() => this._errorHandler.handleError(error))\r\n    });\r\n\r\n    return result.pipe(leaveNgxs(this._ngxsExecutionStrategy));\r\n  }\r\n\r\n  private dispatchByEvents(actionOrActions: any | any[]): Observable<any> {\r\n    if (Array.isArray(actionOrActions)) {\r\n      return forkJoin(actionOrActions.map(a => this.dispatchSingle(a)));\r\n    } else {\r\n      return this.dispatchSingle(actionOrActions);\r\n    }\r\n  }\r\n\r\n  private dispatchSingle(action: any): Observable<any> {\r\n    const prevState = this._stateStream.getValue();\r\n    const plugins = this._pluginManager.plugins;\r\n\r\n    return (compose([\r\n      ...plugins,\r\n      (nextState: any, nextAction: any) => {\r\n        if (nextState !== prevState) {\r\n          this._stateStream.next(nextState);\r\n        }\r\n        const actionResult$ = this.getActionResultStream(nextAction);\r\n        actionResult$.subscribe(ctx => this._actions.next(ctx));\r\n        this._actions.next({ action: nextAction, status: ActionStatus.Dispatched });\r\n        return this.createDispatchObservable(actionResult$);\r\n      }\r\n    ])(prevState, action) as Observable<any>).pipe(shareReplay());\r\n  }\r\n\r\n  private getActionResultStream(action: any): Observable<ActionContext> {\r\n    return this._actionResults.pipe(\r\n      filter(\r\n        (ctx: ActionContext) => ctx.action === action && ctx.status !== ActionStatus.Dispatched\r\n      ),\r\n      take(1),\r\n      shareReplay()\r\n    );\r\n  }\r\n\r\n  private createDispatchObservable(actionResult$: Observable<ActionContext>): Observable<any> {\r\n    return actionResult$\r\n      .pipe(\r\n        exhaustMap((ctx: ActionContext) => {\r\n          switch (ctx.status) {\r\n            case ActionStatus.Successful:\r\n              return of(this._stateStream.getValue());\r\n            case ActionStatus.Errored:\r\n              return throwError(ctx.error);\r\n            default:\r\n              return empty();\r\n          }\r\n        })\r\n      )\r\n      .pipe(shareReplay());\r\n  }\r\n}\r\n","function defaultEqualityCheck(a: any, b: any) {\r\n  return a === b;\r\n}\r\n\r\nfunction areArgumentsShallowlyEqual(\r\n  equalityCheck: (a: any, b: any) => boolean,\r\n  prev: IArguments | null,\r\n  next: IArguments | null\r\n) {\r\n  if (prev === null || next === null || prev.length !== next.length) {\r\n    return false;\r\n  }\r\n\r\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n  const length = prev.length;\r\n  for (let i = 0; i < length; i++) {\r\n    if (!equalityCheck(prev[i], next[i])) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Memoize a function on its last inputs only.\r\n * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js\r\n *\r\n * @ignore\r\n */\r\nexport function memoize<T extends (...args: any[]) => any>(\r\n  func: T,\r\n  equalityCheck = defaultEqualityCheck\r\n): T {\r\n  let lastArgs: IArguments | null = null;\r\n  let lastResult: any = null;\r\n  // we reference arguments instead of spreading them for performance reasons\r\n  function memoized() {\r\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\r\n      // apply arguments instead of spreading for performance.\r\n      lastResult = (<Function>func).apply(null, arguments);\r\n    }\r\n\r\n    lastArgs = arguments;\r\n    return lastResult;\r\n  }\r\n  (<any>memoized).reset = function() {\r\n    // The hidden (for now) ability to reset the memoization\r\n    lastArgs = null;\r\n    lastResult = null;\r\n  };\r\n  return memoized as T;\r\n}\r\n","import { getPlatform, COMPILER_OPTIONS, CompilerOptions, PlatformRef } from '@angular/core';\r\nimport { memoize } from './memoize';\r\n\r\nfunction _isAngularInTestMode() {\r\n  const platformRef: PlatformRef | null = getPlatform();\r\n  if (!platformRef) return false;\r\n  const compilerOptions = platformRef.injector.get(COMPILER_OPTIONS, null);\r\n  if (!compilerOptions) return false;\r\n  const isInTestMode = compilerOptions.some((item: CompilerOptions) => {\r\n    const providers = (item && item.providers) || [];\r\n    return providers.some((provider: any) => {\r\n      return (\r\n        (provider && provider.provide && provider.provide.name === 'MockNgModuleResolver') ||\r\n        false\r\n      );\r\n    });\r\n  });\r\n  return isInTestMode;\r\n}\r\n\r\nexport const isAngularInTestMode = memoize(_isAngularInTestMode);\r\n","import { Injectable, isDevMode } from '@angular/core';\r\n\r\nimport { isAngularInTestMode } from '../utils/angular';\r\nimport { NgxsConfig } from '../symbols';\r\n\r\n@Injectable()\r\nexport class ConfigValidator {\r\n  constructor(private _config: NgxsConfig) {}\r\n\r\n  public verifyDevMode(): void {\r\n    if (isAngularInTestMode()) {\r\n      return;\r\n    }\r\n\r\n    const isNgxsDevMode = this._config.developmentMode;\r\n    const isNgDevMode = isDevMode();\r\n    const incorrectProduction = !isNgDevMode && isNgxsDevMode;\r\n    const incorrectDevelopment = isNgDevMode && !isNgxsDevMode;\r\n    const example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';\r\n\r\n    if (incorrectProduction) {\r\n      console.warn(\r\n        'Angular is running in production mode but NGXS is still running in the development mode!\\n',\r\n        'Please set developmentMode to false on the NgxsModule options when in production mode.\\n',\r\n        example\r\n      );\r\n    } else if (incorrectDevelopment) {\r\n      console.warn(\r\n        'RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\\n',\r\n        example\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Object freeze code\r\n * https://github.com/jsdf/deep-freeze\r\n */\r\nexport const deepFreeze = (o: any) => {\r\n  Object.freeze(o);\r\n\r\n  const oIsFunction = typeof o === 'function';\r\n  const hasOwnProp = Object.prototype.hasOwnProperty;\r\n\r\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\r\n    if (\r\n      hasOwnProp.call(o, prop) &&\r\n      (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\r\n      o[prop] !== null &&\r\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\r\n      !Object.isFrozen(o[prop])\r\n    ) {\r\n      deepFreeze(o[prop]);\r\n    }\r\n  });\r\n\r\n  return o;\r\n};\r\n","import { Injectable } from '@angular/core';\r\n\r\nimport { ConfigValidator } from './config-validator';\r\nimport { StateOperations, StatesAndDefaults } from '../internal/internals';\r\nimport { InternalDispatcher } from '../internal/dispatcher';\r\nimport { StateStream } from './state-stream';\r\nimport { NgxsConfig } from '../symbols';\r\nimport { deepFreeze } from '../utils/freeze';\r\n\r\n/**\r\n * State Context factory class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class InternalStateOperations {\r\n  constructor(\r\n    private _stateStream: StateStream,\r\n    private _dispatcher: InternalDispatcher,\r\n    private _config: NgxsConfig,\r\n    configValidator: ConfigValidator\r\n  ) {\r\n    configValidator.verifyDevMode();\r\n  }\r\n\r\n  /**\r\n   * Returns the root state operators.\r\n   */\r\n  getRootStateOperations(): StateOperations<any> {\r\n    const rootStateOperations = {\r\n      getState: () => this._stateStream.getValue(),\r\n      setState: (newState: any) => this._stateStream.next(newState),\r\n      dispatch: (actions: any[]) => this._dispatcher.dispatch(actions)\r\n    };\r\n\r\n    if (this._config.developmentMode) {\r\n      return this.ensureStateAndActionsAreImmutable(rootStateOperations);\r\n    }\r\n\r\n    return rootStateOperations;\r\n  }\r\n\r\n  private ensureStateAndActionsAreImmutable(root: StateOperations<any>): StateOperations<any> {\r\n    return {\r\n      getState: () => root.getState(),\r\n      setState: value => {\r\n        const frozenValue = deepFreeze(value);\r\n        return root.setState(frozenValue);\r\n      },\r\n      dispatch: actions => {\r\n        return root.dispatch(actions);\r\n      }\r\n    };\r\n  }\r\n\r\n  setStateToTheCurrentWithNew(results: StatesAndDefaults): void {\r\n    const stateOperations: StateOperations<any> = this.getRootStateOperations();\r\n\r\n    // Get our current stream\r\n    const currentState = stateOperations.getState();\r\n    // Set the state to the current + new\r\n    stateOperations.setState({ ...currentState, ...results.defaults });\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\n\r\nimport { StateContext, StateOperator } from '../symbols';\r\nimport { MappedStore } from '../internal/internals';\r\nimport { setValue, getValue } from '../utils/utils';\r\nimport { InternalStateOperations } from '../internal/state-operations';\r\nimport { simplePatch } from './state-operators';\r\n\r\n/**\r\n * State Context factory class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class StateContextFactory {\r\n  constructor(private _internalStateOperations: InternalStateOperations) {}\r\n\r\n  /**\r\n   * Create the state context\r\n   */\r\n  createStateContext<T>(metadata: MappedStore): StateContext<T> {\r\n    const root = this._internalStateOperations.getRootStateOperations();\r\n\r\n    function getState(currentAppState: any): T {\r\n      return getValue(currentAppState, metadata.depth);\r\n    }\r\n\r\n    function setStateValue(currentAppState: any, newValue: T): any {\r\n      const newAppState = setValue(currentAppState, metadata.depth, newValue);\r\n      root.setState(newAppState);\r\n      return newAppState;\r\n      // In doing this refactoring I noticed that there is a 'bug' where the\r\n      // application state is returned instead of this state slice.\r\n      // This has worked this way since the beginning see:\r\n      // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\r\n      // This needs to be fixed, but is a 'breaking' change.\r\n      // I will do this fix in a subsequent PR and we can decide how to handle it.\r\n    }\r\n\r\n    function setStateFromOperator(currentAppState: any, stateOperator: StateOperator<T>) {\r\n      const local = getState(currentAppState);\r\n      const newValue = stateOperator(local);\r\n      return setStateValue(currentAppState, newValue);\r\n    }\r\n\r\n    function isStateOperator(value: T | StateOperator<T>): value is StateOperator<T> {\r\n      return typeof value === 'function';\r\n    }\r\n\r\n    return {\r\n      getState(): T {\r\n        const currentAppState = root.getState();\r\n        return getState(currentAppState);\r\n      },\r\n      patchState(val: Partial<T>): T {\r\n        const currentAppState = root.getState();\r\n        const patchOperator = simplePatch<T>(val);\r\n        return setStateFromOperator(currentAppState, patchOperator);\r\n      },\r\n      setState(val: T | StateOperator<T>): T {\r\n        const currentAppState = root.getState();\r\n        return isStateOperator(val)\r\n          ? setStateFromOperator(currentAppState, val)\r\n          : setStateValue(currentAppState, val);\r\n      },\r\n      dispatch(actions: any | any[]): Observable<void> {\r\n        return root.dispatch(actions);\r\n      }\r\n    };\r\n  }\r\n}\r\n","import { StateOperator } from '../symbols';\r\n\r\nexport function simplePatch<T>(val: Partial<T>): StateOperator<T> {\r\n  return (existingState: Readonly<T>) => {\r\n    const isArray = Array.isArray(val);\r\n    const isPrimitive = typeof val !== 'object';\r\n    if (isArray) {\r\n      throw new Error('Patching arrays is not supported.');\r\n    }\r\n    if (isPrimitive) {\r\n      throw new Error('Patching primitives is not supported.');\r\n    }\r\n    const newState = { ...(<any>existingState) };\r\n    for (const k in val) {\r\n      newState[k] = val[k];\r\n    }\r\n    return <T>newState;\r\n  };\r\n}\r\n","import {\r\n  getStoreMetadata,\r\n  MetaDataModel,\r\n  StateClass,\r\n  StatesByName\r\n} from '../internal/internals';\r\n\r\nexport abstract class StoreValidators {\r\n  public static stateNameRegex: RegExp = new RegExp('^[a-zA-Z0-9_]+$');\r\n\r\n  public static stateNameErrorMessage(name: string) {\r\n    return `${name} is not a valid state name. It needs to be a valid object property name.`;\r\n  }\r\n\r\n  public static checkCorrectStateName(name: string) {\r\n    if (!name) {\r\n      throw new Error(`States must register a 'name' property`);\r\n    }\r\n\r\n    if (!this.stateNameRegex.test(name)) {\r\n      throw new Error(this.stateNameErrorMessage(name));\r\n    }\r\n  }\r\n\r\n  public static checkStateNameIsUnique(state: StateClass, statesByName: StatesByName): string {\r\n    const meta: MetaDataModel = this.getValidStateMeta(state);\r\n    const stateName: string = meta!.name as string;\r\n    const existingState = statesByName[stateName];\r\n    if (existingState && existingState !== state) {\r\n      throw new Error(\r\n        `State name '${stateName}' from ${state.name} already exists in ${existingState.name}`\r\n      );\r\n    }\r\n    return stateName;\r\n  }\r\n\r\n  public static getValidStateMeta(state: StateClass): MetaDataModel {\r\n    const meta: MetaDataModel = getStoreMetadata(state);\r\n    if (!meta) {\r\n      throw new Error('States must be decorated with @State() decorator');\r\n    }\r\n\r\n    return meta;\r\n  }\r\n}\r\n","import { Injectable, Injector, Optional, SkipSelf } from '@angular/core';\r\nimport { forkJoin, from, Observable, of, throwError } from 'rxjs';\r\nimport {\r\n  catchError,\r\n  defaultIfEmpty,\r\n  filter,\r\n  map,\r\n  mergeMap,\r\n  shareReplay,\r\n  takeUntil\r\n} from 'rxjs/operators';\r\n\r\nimport { META_KEY, NgxsConfig } from '../symbols';\r\nimport {\r\n  buildGraph,\r\n  findFullParentPath,\r\n  isObject,\r\n  MappedStore,\r\n  MetaDataModel,\r\n  nameToState,\r\n  ObjectKeyMap,\r\n  propGetter,\r\n  StateClass,\r\n  StateKeyGraph,\r\n  StatesAndDefaults,\r\n  StatesByName,\r\n  topologicalSort\r\n} from './internals';\r\nimport { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';\r\nimport { ofActionDispatched } from '../operators/of-action';\r\nimport { ActionContext, ActionStatus, InternalActions } from '../actions-stream';\r\nimport { InternalDispatchedActionResults } from '../internal/dispatcher';\r\nimport { StateContextFactory } from '../internal/state-context-factory';\r\nimport { StoreValidators } from '../utils/store-validators';\r\nimport { InternalStateOperations } from '../internal/state-operations';\r\n\r\n/**\r\n * State factory class\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class StateFactory {\r\n  private _connected = false;\r\n  private _states: MappedStore[] = [];\r\n  private _statesByName: StatesByName = {};\r\n\r\n  constructor(\r\n    private _injector: Injector,\r\n    private _config: NgxsConfig,\r\n    @Optional()\r\n    @SkipSelf()\r\n    private _parentFactory: StateFactory,\r\n    private _actions: InternalActions,\r\n    private _actionResults: InternalDispatchedActionResults,\r\n    private _stateContextFactory: StateContextFactory,\r\n    private _internalStateOperations: InternalStateOperations\r\n  ) {}\r\n\r\n  public get states(): MappedStore[] {\r\n    return this._parentFactory ? this._parentFactory.states : this._states;\r\n  }\r\n\r\n  public get statesByName(): StatesByName {\r\n    return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\r\n  }\r\n\r\n  private get stateTreeRef(): ObjectKeyMap<any> {\r\n    return this._internalStateOperations.getRootStateOperations().getState();\r\n  }\r\n\r\n  private static cloneDefaults(defaults: any): any {\r\n    let value = {};\r\n\r\n    if (Array.isArray(defaults)) {\r\n      value = [...defaults];\r\n    } else if (isObject(defaults)) {\r\n      value = { ...defaults };\r\n    } else if (defaults === undefined) {\r\n      value = {};\r\n    } else {\r\n      value = defaults;\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  private static checkStatesAreValid(stateClasses: StateClass[]): void {\r\n    stateClasses.forEach(StoreValidators.getValidStateMeta);\r\n  }\r\n\r\n  /**\r\n   * Add a new state to the global defs.\r\n   */\r\n  add(stateClasses: StateClass[]): MappedStore[] {\r\n    StateFactory.checkStatesAreValid(stateClasses);\r\n    const { newStates } = this.addToStatesMap(stateClasses);\r\n    if (!newStates.length) return [];\r\n\r\n    const stateGraph: StateKeyGraph = buildGraph(newStates);\r\n    const sortedStates: string[] = topologicalSort(stateGraph);\r\n    const depths: ObjectKeyMap<string> = findFullParentPath(stateGraph);\r\n    const nameGraph: ObjectKeyMap<StateClass> = nameToState(newStates);\r\n    const bootstrappedStores: MappedStore[] = [];\r\n\r\n    for (const name of sortedStates) {\r\n      const stateClass: StateClass = nameGraph[name];\r\n      const depth: string = depths[name];\r\n      const meta: MetaDataModel = stateClass[META_KEY]!;\r\n\r\n      this.addRuntimeInfoToMeta(meta, depth);\r\n\r\n      const stateMap: MappedStore = {\r\n        name,\r\n        depth,\r\n        actions: meta.actions,\r\n        instance: this._injector.get(stateClass),\r\n        defaults: StateFactory.cloneDefaults(meta.defaults)\r\n      };\r\n\r\n      // ensure our store hasn't already been added\r\n      // but don't throw since it could be lazy\r\n      // loaded from different paths\r\n      if (!this.hasBeenMountedAndBootstrapped(name, depth)) {\r\n        bootstrappedStores.push(stateMap);\r\n      }\r\n\r\n      this.states.push(stateMap);\r\n    }\r\n\r\n    return bootstrappedStores;\r\n  }\r\n\r\n  /**\r\n   * Add a set of states to the store and return the defaults\r\n   */\r\n  addAndReturnDefaults(stateClasses: StateClass[]): StatesAndDefaults {\r\n    const classes: StateClass[] = stateClasses || [];\r\n\r\n    const states: MappedStore[] = this.add(classes);\r\n    const defaults = states.reduce(\r\n      (result: any, meta: MappedStore) => setValue(result, meta.depth, meta.defaults),\r\n      {}\r\n    );\r\n    return { defaults, states };\r\n  }\r\n\r\n  /**\r\n   * Bind the actions to the handlers\r\n   */\r\n  connectActionHandlers() {\r\n    if (this._connected) return;\r\n    this._actions\r\n      .pipe(\r\n        filter((ctx: ActionContext) => ctx.status === ActionStatus.Dispatched),\r\n        mergeMap(({ action }) =>\r\n          this.invokeActions(this._actions, action!).pipe(\r\n            map(() => <ActionContext>{ action, status: ActionStatus.Successful }),\r\n            defaultIfEmpty(<ActionContext>{ action, status: ActionStatus.Canceled }),\r\n            catchError(error =>\r\n              of(<ActionContext>{ action, status: ActionStatus.Errored, error })\r\n            )\r\n          )\r\n        )\r\n      )\r\n      .subscribe(ctx => this._actionResults.next(ctx));\r\n    this._connected = true;\r\n  }\r\n\r\n  /**\r\n   * Invoke actions on the states.\r\n   */\r\n  invokeActions(actions$: InternalActions, action: any) {\r\n    const results = [];\r\n\r\n    for (const metadata of this.states) {\r\n      const type = getActionTypeFromInstance(action)!;\r\n      const actionMetas = metadata.actions[type];\r\n\r\n      if (actionMetas) {\r\n        for (const actionMeta of actionMetas) {\r\n          const stateContext = this._stateContextFactory.createStateContext(metadata);\r\n          try {\r\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\r\n\r\n            if (result instanceof Promise) {\r\n              result = from(result);\r\n            }\r\n\r\n            if (result instanceof Observable) {\r\n              result = result.pipe(\r\n                actionMeta.options.cancelUncompleted\r\n                  ? // todo: ofActionDispatched should be used with action class\r\n                    takeUntil(actions$.pipe(ofActionDispatched(action as any)))\r\n                  : map(r => r)\r\n              ); // map acts like a noop\r\n            } else {\r\n              result = of({}).pipe(shareReplay());\r\n            }\r\n\r\n            results.push(result);\r\n          } catch (e) {\r\n            results.push(throwError(e));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!results.length) {\r\n      results.push(of({}));\r\n    }\r\n\r\n    return forkJoin(results);\r\n  }\r\n\r\n  private addToStatesMap(stateClasses: StateClass[]): { newStates: StateClass[] } {\r\n    const newStates: StateClass[] = [];\r\n    const statesMap: StatesByName = this.statesByName;\r\n\r\n    for (const stateClass of stateClasses) {\r\n      const stateName: string = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);\r\n      const unmountedState: boolean = !statesMap[stateName];\r\n      if (unmountedState) {\r\n        newStates.push(stateClass);\r\n        statesMap[stateName] = stateClass;\r\n      }\r\n    }\r\n\r\n    return { newStates };\r\n  }\r\n\r\n  private addRuntimeInfoToMeta(meta: MetaDataModel, depth: string): void {\r\n    meta.path = depth;\r\n    meta.selectFromAppState = propGetter(depth.split('.'), this._config);\r\n  }\r\n\r\n  /**\r\n   * @description\r\n   * the method checks if the state has already been added to the tree\r\n   * and completed the life cycle\r\n   * @param name\r\n   * @param path\r\n   */\r\n  private hasBeenMountedAndBootstrapped(name: string, path: string): boolean {\r\n    const valueIsBootstrapped: boolean = getValue(this.stateTreeRef, path) !== undefined;\r\n    return this.statesByName[name] && valueIsBootstrapped;\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { NgxsBootstrapper } from '@ngxs/store/internals';\r\n\r\nimport { filter, tap, mergeMap } from 'rxjs/operators';\r\n\r\nimport { StateContextFactory } from './state-context-factory';\r\nimport { InternalStateOperations } from './state-operations';\r\nimport { MappedStore, StatesAndDefaults } from './internals';\r\nimport { LifecycleHooks, NgxsLifeCycle } from '../symbols';\r\n\r\n@Injectable()\r\nexport class LifecycleStateManager {\r\n  constructor(\r\n    private internalStateOperations: InternalStateOperations,\r\n    private stateContextFactory: StateContextFactory,\r\n    private bootstrapper: NgxsBootstrapper\r\n  ) {}\r\n\r\n  ngxsBootstrap<T>(action: T, results: StatesAndDefaults | undefined): void {\r\n    this.internalStateOperations\r\n      .getRootStateOperations()\r\n      .dispatch(action)\r\n      .pipe(\r\n        filter(() => !!results),\r\n        tap(() => this.invokeInit(results!.states)),\r\n        mergeMap(() => this.bootstrapper.appBootstrapped$),\r\n        filter(appBootstrapped => !!appBootstrapped)\r\n      )\r\n      .subscribe(() => {\r\n        this.invokeBootstrap(results!.states);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Invoke the init function on the states.\r\n   */\r\n  invokeInit(stateMetadatas: MappedStore[]): void {\r\n    this.invokeLifecycleHooks(stateMetadatas, LifecycleHooks.NgxsOnInit);\r\n  }\r\n\r\n  /**\r\n   * Invoke the bootstrap function on the states.\r\n   */\r\n  invokeBootstrap(stateMetadatas: MappedStore[]) {\r\n    this.invokeLifecycleHooks(stateMetadatas, LifecycleHooks.NgxsAfterBootstrap);\r\n  }\r\n\r\n  private invokeLifecycleHooks(stateMetadatas: MappedStore[], hook: LifecycleHooks): void {\r\n    for (const metadata of stateMetadatas) {\r\n      const instance: NgxsLifeCycle = metadata.instance;\r\n\r\n      if (instance[hook]) {\r\n        const stateContext = this.stateContextFactory.createStateContext(metadata);\r\n        instance[hook]!(stateContext);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import {\r\n  SelectFromState,\r\n  ensureSelectorMetadata,\r\n  getSelectorMetadata,\r\n  getStoreMetadata\r\n} from '../internal/internals';\r\nimport { memoize } from '../utils/memoize';\r\n\r\n/**\r\n * Function for creating a selector\r\n * @param selectors The selectors to use to create the arguments of this function\r\n * @param originalFn The original function being made into a selector\r\n * @param creationMetadata\r\n */\r\nexport function createSelector<T extends (...args: any[]) => any>(\r\n  selectors: any[] | undefined,\r\n  originalFn: T,\r\n  creationMetadata?: { containerClass: any; selectorName: string }\r\n) {\r\n  const wrappedFn = function wrappedSelectorFn(...args: any[]) {\r\n    const returnValue = originalFn(...args);\r\n    if (returnValue instanceof Function) {\r\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\r\n      return innerMemoizedFn;\r\n    }\r\n    return returnValue;\r\n  } as T;\r\n  const memoizedFn = memoize(wrappedFn);\r\n  const containerClass = creationMetadata && creationMetadata.containerClass;\r\n\r\n  const fn = (state: any) => {\r\n    const results = [];\r\n\r\n    const selectorsToApply = [];\r\n\r\n    if (containerClass) {\r\n      // If we are on a state class, add it as the first selector parameter\r\n      const metadata = getStoreMetadata(containerClass);\r\n      if (metadata) {\r\n        selectorsToApply.push(containerClass);\r\n      }\r\n    }\r\n\r\n    if (selectors) {\r\n      selectorsToApply.push(...selectors);\r\n    }\r\n\r\n    // Determine arguments from the app state using the selectors\r\n    results.push(...selectorsToApply.map(a => getSelectorFn(a)(state)));\r\n\r\n    // if the lambda tries to access a something on the\r\n    // state that doesn't exist, it will throw a TypeError.\r\n    // since this is quite usual behaviour, we simply return undefined if so.\r\n    try {\r\n      return memoizedFn(...results);\r\n    } catch (ex) {\r\n      if (ex instanceof TypeError) {\r\n        return undefined;\r\n      }\r\n      throw ex;\r\n    }\r\n  };\r\n\r\n  const selectorMetaData = ensureSelectorMetadata(memoizedFn);\r\n  selectorMetaData.originalFn = originalFn;\r\n  selectorMetaData.selectFromAppState = fn;\r\n  if (creationMetadata) {\r\n    selectorMetaData.containerClass = creationMetadata.containerClass;\r\n    selectorMetaData.selectorName = creationMetadata.selectorName;\r\n  }\r\n  return memoizedFn;\r\n}\r\n\r\n/**\r\n * This function gets the selector function to be used to get the selected slice from the app state\r\n * @ignore\r\n */\r\nexport function getSelectorFn(selector: any): SelectFromState {\r\n  const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);\r\n  return (metadata && metadata.selectFromAppState) || selector;\r\n}\r\n","// tslint:disable:unified-signatures\r\nimport { Injectable, Type } from '@angular/core';\r\nimport { Observable, of, Subscription } from 'rxjs';\r\nimport { catchError, distinctUntilChanged, map, take } from 'rxjs/operators';\r\n\r\nimport { getSelectorFn } from './utils/selector-utils';\r\nimport { InternalStateOperations } from './internal/state-operations';\r\nimport { StateStream } from './internal/state-stream';\r\nimport { NgxsConfig } from './symbols';\r\nimport { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';\r\nimport { leaveNgxs } from './operators/leave-ngxs';\r\n\r\n@Injectable()\r\nexport class Store {\r\n  constructor(\r\n    private _stateStream: StateStream,\r\n    private _internalStateOperations: InternalStateOperations,\r\n    private _config: NgxsConfig,\r\n    private _internalExecutionStrategy: InternalNgxsExecutionStrategy\r\n  ) {\r\n    this._stateStream.next(this._config.defaultsState);\r\n  }\r\n\r\n  /**\r\n   * Dispatches event(s).\r\n   */\r\n  dispatch(event: any | any[]): Observable<any> {\r\n    return this._internalStateOperations.getRootStateOperations().dispatch(event);\r\n  }\r\n\r\n  /**\r\n   * Selects a slice of data from the store.\r\n   */\r\n  select<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\r\n  select<T = any>(selector: string | Type<any>): Observable<T>;\r\n  select(selector: any): Observable<any> {\r\n    const selectorFn = getSelectorFn(selector);\r\n    return this._stateStream.pipe(\r\n      map(selectorFn),\r\n      catchError(err => {\r\n        // if error is TypeError we swallow it to prevent usual errors with property access\r\n        if (err instanceof TypeError) {\r\n          return of(undefined);\r\n        }\r\n\r\n        // rethrow other errors\r\n        throw err;\r\n      }),\r\n      distinctUntilChanged(),\r\n      leaveNgxs(this._internalExecutionStrategy)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Select one slice of data from the store.\r\n   */\r\n\r\n  selectOnce<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\r\n  selectOnce<T = any>(selector: string | Type<any>): Observable<T>;\r\n  selectOnce(selector: any): Observable<any> {\r\n    return this.select(selector).pipe(take(1));\r\n  }\r\n\r\n  /**\r\n   * Select a snapshot from the state.\r\n   */\r\n  selectSnapshot<T>(selector: (state: any, ...states: any[]) => T): T;\r\n  selectSnapshot<T = any>(selector: string | Type<any>): T;\r\n  selectSnapshot(selector: any): any {\r\n    const selectorFn = getSelectorFn(selector);\r\n    return selectorFn(this._stateStream.getValue());\r\n  }\r\n\r\n  /**\r\n   * Allow the user to subscribe to the root of the state\r\n   */\r\n  subscribe(fn?: (value: any) => void): Subscription {\r\n    return this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\r\n  }\r\n\r\n  /**\r\n   * Return the raw value of the state.\r\n   */\r\n  snapshot(): any {\r\n    return this._internalStateOperations.getRootStateOperations().getState();\r\n  }\r\n\r\n  /**\r\n   * Reset the state to a specific point in time. This method is useful\r\n   * for plugin's who need to modify the state directly or unit testing.\r\n   */\r\n  reset(state: any) {\r\n    return this._internalStateOperations.getRootStateOperations().setState(state);\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\nimport { Store } from '../store';\r\nimport { propGetter, removeDollarAtTheEnd } from '../internal/internals';\r\nimport { META_KEY, NgxsConfig } from '../symbols';\r\n\r\n/**\r\n * Allows the select decorator to get access to the DI store.\r\n * @ignore\r\n */\r\n@Injectable()\r\nexport class SelectFactory {\r\n  static store: Store | undefined = undefined;\r\n  static config: NgxsConfig | undefined = undefined;\r\n  constructor(store: Store, config: NgxsConfig) {\r\n    SelectFactory.store = store;\r\n    SelectFactory.config = config;\r\n  }\r\n}\r\n\r\n/**\r\n * Decorator for selecting a slice of state from the store.\r\n */\r\nexport function Select(selectorOrFeature?: any, ...paths: string[]) {\r\n  return function(target: any, name: string) {\r\n    const selectorFnName = '__' + name + '__selector';\r\n\r\n    if (!selectorOrFeature) {\r\n      selectorOrFeature = removeDollarAtTheEnd(name);\r\n    }\r\n\r\n    const createSelect = (fn: any) => {\r\n      const store = SelectFactory.store;\r\n\r\n      if (!store) {\r\n        throw new Error('SelectFactory not connected to store!');\r\n      }\r\n\r\n      return store.select(fn);\r\n    };\r\n\r\n    const createSelector = () => {\r\n      const config = SelectFactory.config;\r\n      if (typeof selectorOrFeature === 'string') {\r\n        const propsArray = paths.length\r\n          ? [selectorOrFeature, ...paths]\r\n          : selectorOrFeature.split('.');\r\n\r\n        return propGetter(propsArray, config!);\r\n      } else if (selectorOrFeature[META_KEY] && selectorOrFeature[META_KEY].path) {\r\n        return propGetter(selectorOrFeature[META_KEY].path.split('.'), config!);\r\n      } else {\r\n        return selectorOrFeature;\r\n      }\r\n    };\r\n\r\n    if (target[selectorFnName]) {\r\n      throw new Error(\r\n        'You cannot use @Select decorator and a ' + selectorFnName + ' property.'\r\n      );\r\n    }\r\n\r\n    if (delete target[name]) {\r\n      Object.defineProperty(target, selectorFnName, {\r\n        writable: true,\r\n        enumerable: false,\r\n        configurable: true\r\n      });\r\n\r\n      Object.defineProperty(target, name, {\r\n        get: function() {\r\n          return (\r\n            this[selectorFnName] ||\r\n            (this[selectorFnName] = createSelect.apply(this, [createSelector()]))\r\n          );\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n      });\r\n    }\r\n  };\r\n}\r\n","/**\r\n * Init action\r\n */\r\nexport class InitState {\r\n  static get type() {\r\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\r\n    return '@@INIT';\r\n  }\r\n}\r\n\r\n/**\r\n * Update action\r\n */\r\nexport class UpdateState {\r\n  static get type() {\r\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\r\n    return '@@UPDATE_STATE';\r\n  }\r\n}\r\n","import {\r\n  NgModule,\r\n  ModuleWithProviders,\r\n  Optional,\r\n  Inject,\r\n  InjectionToken,\r\n  APP_BOOTSTRAP_LISTENER\r\n} from '@angular/core';\r\n\r\nimport { NgxsBootstrapper } from '@ngxs/store/internals';\r\n\r\nimport { ROOT_STATE_TOKEN, FEATURE_STATE_TOKEN, NgxsConfig } from './symbols';\r\nimport { NGXS_EXECUTION_STRATEGY } from './execution/symbols';\r\nimport { StateFactory } from './internal/state-factory';\r\nimport { StateContextFactory } from './internal/state-context-factory';\r\nimport { Actions, InternalActions } from './actions-stream';\r\nimport { ConfigValidator } from './internal/config-validator';\r\nimport { LifecycleStateManager } from './internal/lifecycle-state-manager';\r\nimport { InternalDispatcher, InternalDispatchedActionResults } from './internal/dispatcher';\r\nimport { InternalStateOperations } from './internal/state-operations';\r\nimport { Store } from './store';\r\nimport { SelectFactory } from './decorators/select';\r\nimport { StateStream } from './internal/state-stream';\r\nimport { PluginManager } from './plugin-manager';\r\nimport { InitState, UpdateState } from './actions/actions';\r\nimport { StateClass } from './internal/internals';\r\nimport { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';\r\nimport { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';\r\n\r\n/**\r\n * Root module\r\n * @ignore\r\n */\r\n@NgModule()\r\nexport class NgxsRootModule {\r\n  constructor(\r\n    factory: StateFactory,\r\n    internalStateOperations: InternalStateOperations,\r\n    store: Store,\r\n    select: SelectFactory,\r\n    @Optional()\r\n    @Inject(ROOT_STATE_TOKEN)\r\n    states: StateClass[] = [],\r\n    lifecycleStateManager: LifecycleStateManager\r\n  ) {\r\n    // add stores to the state graph and return their defaults\r\n    const results = factory.addAndReturnDefaults(states);\r\n\r\n    internalStateOperations.setStateToTheCurrentWithNew(results);\r\n\r\n    // connect our actions stream\r\n    factory.connectActionHandlers();\r\n\r\n    // dispatch the init action and invoke init and bootstrap functions after\r\n    lifecycleStateManager.ngxsBootstrap(new InitState(), results);\r\n  }\r\n}\r\n\r\n/**\r\n * Feature module\r\n * @ignore\r\n */\r\n@NgModule({})\r\nexport class NgxsFeatureModule {\r\n  constructor(\r\n    store: Store,\r\n    internalStateOperations: InternalStateOperations,\r\n    factory: StateFactory,\r\n    @Optional()\r\n    @Inject(FEATURE_STATE_TOKEN)\r\n    states: any[][],\r\n    lifecycleStateManager: LifecycleStateManager\r\n  ) {\r\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\r\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\r\n    const flattenedStates = ([] as any[]).concat(...states);\r\n\r\n    // add stores to the state graph and return their defaults\r\n    const results = factory.addAndReturnDefaults(flattenedStates);\r\n\r\n    if (results.states.length) {\r\n      internalStateOperations.setStateToTheCurrentWithNew(results);\r\n      // dispatch the update action and invoke init and bootstrap functions after\r\n      lifecycleStateManager.ngxsBootstrap(new UpdateState(), results);\r\n    }\r\n  }\r\n}\r\n\r\nexport type ModuleOptions = Partial<NgxsConfig>;\r\n\r\nexport function ngxsConfigFactory(options: ModuleOptions): NgxsConfig {\r\n  const config = Object.assign(new NgxsConfig(), options);\r\n  return config;\r\n}\r\n\r\nexport function appBootstrapListenerFactory(bootstrapper: NgxsBootstrapper) {\r\n  return () => bootstrapper.bootstrap();\r\n}\r\n\r\nexport const ROOT_OPTIONS = new InjectionToken<ModuleOptions>('ROOT_OPTIONS');\r\n\r\n/**\r\n * Ngxs Module\r\n */\r\n@NgModule({})\r\nexport class NgxsModule {\r\n  /**\r\n   * Root module factory\r\n   */\r\n  static forRoot(states: StateClass[] = [], options: ModuleOptions = {}): ModuleWithProviders {\r\n    return {\r\n      ngModule: NgxsRootModule,\r\n      providers: [\r\n        StateFactory,\r\n        StateContextFactory,\r\n        Actions,\r\n        InternalActions,\r\n        NgxsBootstrapper,\r\n        ConfigValidator,\r\n        LifecycleStateManager,\r\n        InternalDispatcher,\r\n        InternalDispatchedActionResults,\r\n        InternalStateOperations,\r\n        InternalNgxsExecutionStrategy,\r\n        Store,\r\n        StateStream,\r\n        SelectFactory,\r\n        PluginManager,\r\n        ...states,\r\n        {\r\n          provide: NGXS_EXECUTION_STRATEGY,\r\n          useClass: options.executionStrategy || DispatchOutsideZoneNgxsExecutionStrategy\r\n        },\r\n        {\r\n          provide: ROOT_STATE_TOKEN,\r\n          useValue: states\r\n        },\r\n        {\r\n          provide: ROOT_OPTIONS,\r\n          useValue: options\r\n        },\r\n        {\r\n          provide: NgxsConfig,\r\n          useFactory: ngxsConfigFactory,\r\n          deps: [ROOT_OPTIONS]\r\n        },\r\n        {\r\n          provide: APP_BOOTSTRAP_LISTENER,\r\n          useFactory: appBootstrapListenerFactory,\r\n          multi: true,\r\n          deps: [NgxsBootstrapper]\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Feature module factory\r\n   */\r\n  static forFeature(states: StateClass[] = []): ModuleWithProviders {\r\n    return {\r\n      ngModule: NgxsFeatureModule,\r\n      providers: [\r\n        StateFactory,\r\n        PluginManager,\r\n        ...states,\r\n        {\r\n          provide: FEATURE_STATE_TOKEN,\r\n          multi: true,\r\n          useValue: states\r\n        }\r\n      ]\r\n    };\r\n  }\r\n}\r\n","import { Injectable } from '@angular/core';\r\n\r\nimport { NgxsExecutionStrategy } from './symbols';\r\n\r\n@Injectable()\r\nexport class NoopNgxsExecutionStrategy implements NgxsExecutionStrategy {\r\n  enter<T>(func: () => T): T {\r\n    return func();\r\n  }\r\n\r\n  leave<T>(func: () => T): T {\r\n    return func();\r\n  }\r\n}\r\n","import { ensureStoreMetadata } from '../internal/internals';\r\nimport { ActionOptions, ActionDef } from '../symbols';\r\n\r\n/**\r\n * Decorates a method with a action information.\r\n */\r\nexport function Action(\r\n  actions: ActionDef | ActionDef[] | { type: string } | { type: string }[],\r\n  options?: ActionOptions\r\n) {\r\n  return function(target: any, name: string, _descriptor: TypedPropertyDescriptor<any>) {\r\n    const meta = ensureStoreMetadata(target.constructor);\r\n\r\n    if (!Array.isArray(actions)) {\r\n      actions = [actions];\r\n    }\r\n\r\n    for (const action of actions) {\r\n      const type = action.type;\r\n\r\n      if (!meta.actions[type]) {\r\n        meta.actions[type] = [];\r\n      }\r\n\r\n      meta.actions[type].push({\r\n        fn: name,\r\n        options: options || {},\r\n        type\r\n      });\r\n    }\r\n  };\r\n}\r\n","import { ensureStoreMetadata, MetaDataModel, StateClass } from '../internal/internals';\r\nimport { META_KEY, META_OPTIONS_KEY, StoreOptions } from '../symbols';\r\nimport { StoreValidators } from '../utils/store-validators';\r\n\r\ninterface MutateMetaOptions<T> {\r\n  meta: MetaDataModel;\r\n  inheritedStateClass: StateClass;\r\n  optionsWithInheritance: StoreOptions<T>;\r\n}\r\n\r\n/**\r\n * Decorates a class with ngxs state information.\r\n */\r\nexport function State<T>(options: StoreOptions<T>) {\r\n  function getStateOptions(inheritedStateClass: StateClass): StoreOptions<T> {\r\n    const inheritanceOptions: Partial<StoreOptions<T>> =\r\n      inheritedStateClass[META_OPTIONS_KEY] || {};\r\n    return { ...inheritanceOptions, ...options } as StoreOptions<T>;\r\n  }\r\n\r\n  function mutateMetaData(params: MutateMetaOptions<T>): void {\r\n    const { meta, inheritedStateClass, optionsWithInheritance } = params;\r\n    const { children, defaults, name } = optionsWithInheritance;\r\n    StoreValidators.checkCorrectStateName(name);\r\n\r\n    if (inheritedStateClass.hasOwnProperty(META_KEY)) {\r\n      const inheritedMeta: Partial<MetaDataModel> = inheritedStateClass[META_KEY] || {};\r\n      meta.actions = { ...meta.actions, ...inheritedMeta.actions };\r\n    }\r\n\r\n    meta.children = children;\r\n    meta.defaults = defaults;\r\n    meta.name = name;\r\n  }\r\n\r\n  return (target: StateClass): void => {\r\n    const meta: MetaDataModel = ensureStoreMetadata(target);\r\n    const inheritedStateClass: StateClass = Object.getPrototypeOf(target);\r\n    const optionsWithInheritance: StoreOptions<T> = getStateOptions(inheritedStateClass);\r\n    mutateMetaData({ meta, inheritedStateClass, optionsWithInheritance });\r\n    target[META_OPTIONS_KEY] = optionsWithInheritance;\r\n  };\r\n}\r\n","import { createSelector } from '../utils/selector-utils';\r\n\r\n/**\r\n * Decorator for memoizing a state selector.\r\n */\r\nexport function Selector(selectors?: any[]) {\r\n  return (target: any, methodName: string, descriptor: PropertyDescriptor) => {\r\n    if (descriptor.value !== null) {\r\n      const originalFn = descriptor.value;\r\n\r\n      const memoizedFn = createSelector(\r\n        selectors,\r\n        originalFn.bind(target),\r\n        { containerClass: target, selectorName: methodName }\r\n      );\r\n\r\n      return {\r\n        configurable: true,\r\n        get() {\r\n          return memoizedFn;\r\n        }\r\n      };\r\n    } else {\r\n      throw new Error('Selectors only work on methods');\r\n    }\r\n  };\r\n}\r\n"]}