(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('@ngxs/store/operators', ['exports'], factory) :
    (factory((global.ngxs = global.ngxs || {}, global.ngxs.store = global.ngxs.store || {}, global.ngxs.store.operators = {})));
}(this, (function (exports) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} items - Specific items to append to the end of an array
     * @return {?}
     */
    function append(items) {
        return ( /**
         * @param {?} existing
         * @return {?}
         */function appendOperator(existing) {
            // If `items` is `undefined` or `null` or `[]` but `existing` is provided
            // just return `existing`
            /** @type {?} */
            var itemsNotProvidedButExistingIs = (!items || !items.length) && existing;
            if (itemsNotProvidedButExistingIs) {
                return existing;
            }
            if (Array.isArray(existing)) {
                return existing.concat(items);
            }
            // For example if some property is added dynamically
            // and didn't exist before thus it's not `ArrayLike`
            return items;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {...?} operators
     * @return {?}
     */
    function compose() {
        var operators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
        }
        return ( /**
         * @param {?} existing
         * @return {?}
         */function composeOperator(existing) {
            return operators.reduce(( /**
             * @param {?} accumulator
             * @param {?} operator
             * @return {?}
             */function (accumulator, operator) { return operator(accumulator); }), existing);
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */
    function isStateOperator(value) {
        return typeof value === 'function';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    function isUndefined(value) {
        return typeof value === 'undefined';
    }
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */
    function isPredicate(value) {
        return typeof value === 'function';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    function isNumber(value) {
        return typeof value === 'number';
    }
    /**
     * @param {?} index
     * @return {?}
     */
    function invalidIndex(index) {
        return Number.isNaN(index) || index === -1;
    }
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */
    function isNil(value) {
        return value === null || isUndefined(value);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} operatorOrValue
     * @param {?=} existing
     * @return {?}
     */
    function retrieveValue(operatorOrValue, existing) {
        // If state operator is a function
        // then call it with an original value
        if (isStateOperator(operatorOrValue)) {
            return operatorOrValue(( /** @type {?} */(existing)));
        }
        // If operator or value was not provided
        // e.g. `elseOperatorOrValue` is `undefined`
        // then we just return an original value
        if (isUndefined(operatorOrValue)) {
            return ( /** @type {?} */(existing));
        }
        return operatorOrValue;
    }
    /**
     * @template T
     * @param {?} condition - Condition can be a plain boolean value or a function,
     * that returns boolean, also this function can take a value as an argument
     * to which this state operator applies
     * @param {?} trueOperatorOrValue - Any value or a state operator
     * @param {?=} elseOperatorOrValue - Any value or a state operator
     * @return {?}
     */
    function iif(condition, trueOperatorOrValue, elseOperatorOrValue) {
        return ( /**
         * @param {?} existing
         * @return {?}
         */function iifOperator(existing) {
            // Convert the value to a boolean
            /** @type {?} */
            var result = !!condition;
            // but if it is a function then run it to get the result
            if (isPredicate(condition)) {
                result = condition(existing);
            }
            if (result) {
                return retrieveValue(trueOperatorOrValue, existing);
            }
            return retrieveValue(( /** @type {?} */(elseOperatorOrValue)), existing);
        });
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} value - Value to insert
     * @param {?=} beforePosition
     * @return {?}
     */
    function insertItem(value, beforePosition) {
        return ( /**
         * @param {?} existing
         * @return {?}
         */function insertItemOperator(existing) {
            // Have to check explicitly for `null` and `undefined`
            // because `value` can be `0`, thus `!value` will return `true`
            if (isNil(value) && existing) {
                return existing;
            }
            // Property may be dynamic and might not existed before
            if (!Array.isArray(existing)) {
                return [value];
            }
            /** @type {?} */
            var clone = __spread(existing);
            /** @type {?} */
            var index = 0;
            // No need to call `isNumber`
            // as we are checking `> 0` not `>= 0`
            // everything except number will return false here
            if (( /** @type {?} */(beforePosition)) > 0) {
                index = ( /** @type {?} */(beforePosition));
            }
            clone.splice(index, 0, value);
            return clone;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} patchObject
     * @return {?}
     */
    function patch(patchObject) {
        return ( /**
         * @template U
         * @param {?} existing
         * @return {?}
         */function patchStateOperator(existing) {
            /** @type {?} */
            var clone = null;
            for (var k in patchObject) {
                /** @type {?} */
                var newValue = patchObject[k];
                /** @type {?} */
                var existingPropValue = existing[k];
                /** @type {?} */
                var newPropValue = isStateOperator(newValue)
                    ? newValue(( /** @type {?} */(existingPropValue)))
                    : newValue;
                if (newPropValue !== existingPropValue) {
                    if (!clone) {
                        clone = __assign({}, (( /** @type {?} */(existing))));
                    }
                    clone[k] = newPropValue;
                }
            }
            return clone || existing;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} selector - Index of item in the array or a predicate function
     * that can be provided in `Array.prototype.findIndex`
     * @param {?} operatorOrValue - New value under the `selector` index or a
     * function that can be applied to an existing value
     * @return {?}
     */
    function updateItem(selector, operatorOrValue) {
        return ( /**
         * @param {?} existing
         * @return {?}
         */function updateItemOperator(existing) {
            /** @type {?} */
            var index = -1;
            if (isPredicate(selector)) {
                index = existing.findIndex(selector);
            }
            else if (isNumber(selector)) {
                index = selector;
            }
            if (invalidIndex(index)) {
                return existing;
            }
            /** @type {?} */
            var value = ( /** @type {?} */(null));
            // Need to check if the new item value will change the existing item value
            // then, only if it will change it then clone the array and set the item
            if (isStateOperator(operatorOrValue)) {
                value = operatorOrValue(existing[index]);
            }
            else {
                value = operatorOrValue;
            }
            // If the value hasn't been mutated
            // then we just return `existing` array
            if (value === existing[index]) {
                return existing;
            }
            /** @type {?} */
            var clone = __spread(existing);
            clone[index] = value;
            return clone;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} selector - index or predicate to remove an item from an array by
     * @return {?}
     */
    function removeItem(selector) {
        return ( /**
         * @param {?} existing
         * @return {?}
         */function removeItemOperator(existing) {
            /** @type {?} */
            var index = -1;
            if (isPredicate(selector)) {
                index = existing.findIndex(selector);
            }
            else if (isNumber(selector)) {
                index = selector;
            }
            if (invalidIndex(index)) {
                return existing;
            }
            /** @type {?} */
            var clone = __spread(existing);
            clone.splice(index, 1);
            return clone;
        });
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.append = append;
    exports.compose = compose;
    exports.iif = iif;
    exports.insertItem = insertItem;
    exports.patch = patch;
    exports.isStateOperator = isStateOperator;
    exports.updateItem = updateItem;
    exports.removeItem = removeItem;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=ngxs-store-operators.umd.js.map