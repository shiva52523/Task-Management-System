/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} a
 * @param {?} b
 * @return {?}
 */
function defaultEqualityCheck(a, b) {
    return a === b;
}
/**
 * @param {?} equalityCheck
 * @param {?} prev
 * @param {?} next
 * @return {?}
 */
function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
    if (prev === null || next === null || prev.length !== next.length) {
        return false;
    }
    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
    /** @type {?} */
    var length = prev.length;
    for (var i = 0; i < length; i++) {
        if (!equalityCheck(prev[i], next[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Memoize a function on its last inputs only.
 * Oringinally from: https://github.com/reduxjs/reselect/blob/master/src/index.js
 *
 * @ignore
 * @template T
 * @param {?} func
 * @param {?=} equalityCheck
 * @return {?}
 */
export function memoize(func, equalityCheck) {
    if (equalityCheck === void 0) { equalityCheck = defaultEqualityCheck; }
    /** @type {?} */
    var lastArgs = null;
    /** @type {?} */
    var lastResult = null;
    // we reference arguments instead of spreading them for performance reasons
    /**
     * @return {?}
     */
    function memoized() {
        if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
            // apply arguments instead of spreading for performance.
            lastResult = ((/** @type {?} */ (func))).apply(null, arguments);
        }
        lastArgs = arguments;
        return lastResult;
    }
    ((/** @type {?} */ (memoized))).reset = (/**
     * @return {?}
     */
    function () {
        // The hidden (for now) ability to reset the memoization
        lastArgs = null;
        lastResult = null;
    });
    return (/** @type {?} */ (memoized));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVtb2l6ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL3V0aWxzL21lbW9pemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsU0FBUyxvQkFBb0IsQ0FBQyxDQUFNLEVBQUUsQ0FBTTtJQUMxQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakIsQ0FBQzs7Ozs7OztBQUVELFNBQVMsMEJBQTBCLENBQ2pDLGFBQTBDLEVBQzFDLElBQXVCLEVBQ3ZCLElBQXVCO0lBRXZCLElBQUksSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNqRSxPQUFPLEtBQUssQ0FBQztLQUNkOzs7UUFHSyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU07SUFDMUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMvQixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNwQyxPQUFPLEtBQUssQ0FBQztTQUNkO0tBQ0Y7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7Ozs7Ozs7Ozs7O0FBUUQsTUFBTSxVQUFVLE9BQU8sQ0FDckIsSUFBTyxFQUNQLGFBQW9DO0lBQXBDLDhCQUFBLEVBQUEsb0NBQW9DOztRQUVoQyxRQUFRLEdBQXNCLElBQUk7O1FBQ2xDLFVBQVUsR0FBUSxJQUFJOzs7OztJQUUxQixTQUFTLFFBQVE7UUFDZixJQUFJLENBQUMsMEJBQTBCLENBQUMsYUFBYSxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsRUFBRTtZQUNuRSx3REFBd0Q7WUFDeEQsVUFBVSxHQUFHLENBQUMsbUJBQVUsSUFBSSxFQUFBLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsUUFBUSxHQUFHLFNBQVMsQ0FBQztRQUNyQixPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBQ0QsQ0FBQyxtQkFBSyxRQUFRLEVBQUEsQ0FBQyxDQUFDLEtBQUs7OztJQUFHO1FBQ3RCLHdEQUF3RDtRQUN4RCxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLFVBQVUsR0FBRyxJQUFJLENBQUM7SUFDcEIsQ0FBQyxDQUFBLENBQUM7SUFDRixPQUFPLG1CQUFBLFFBQVEsRUFBSyxDQUFDO0FBQ3ZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBkZWZhdWx0RXF1YWxpdHlDaGVjayhhOiBhbnksIGI6IGFueSkge1xyXG4gIHJldHVybiBhID09PSBiO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChcclxuICBlcXVhbGl0eUNoZWNrOiAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4sXHJcbiAgcHJldjogSUFyZ3VtZW50cyB8IG51bGwsXHJcbiAgbmV4dDogSUFyZ3VtZW50cyB8IG51bGxcclxuKSB7XHJcbiAgaWYgKHByZXYgPT09IG51bGwgfHwgbmV4dCA9PT0gbnVsbCB8fCBwcmV2Lmxlbmd0aCAhPT0gbmV4dC5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIERvIHRoaXMgaW4gYSBmb3IgbG9vcCAoYW5kIG5vdCBhIGBmb3JFYWNoYCBvciBhbiBgZXZlcnlgKSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGVxdWFsaXR5IGFzIGZhc3QgYXMgcG9zc2libGUuXHJcbiAgY29uc3QgbGVuZ3RoID0gcHJldi5sZW5ndGg7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogTWVtb2l6ZSBhIGZ1bmN0aW9uIG9uIGl0cyBsYXN0IGlucHV0cyBvbmx5LlxyXG4gKiBPcmluZ2luYWxseSBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vcmVkdXhqcy9yZXNlbGVjdC9ibG9iL21hc3Rlci9zcmMvaW5kZXguanNcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemU8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcclxuICBmdW5jOiBULFxyXG4gIGVxdWFsaXR5Q2hlY2sgPSBkZWZhdWx0RXF1YWxpdHlDaGVja1xyXG4pOiBUIHtcclxuICBsZXQgbGFzdEFyZ3M6IElBcmd1bWVudHMgfCBudWxsID0gbnVsbDtcclxuICBsZXQgbGFzdFJlc3VsdDogYW55ID0gbnVsbDtcclxuICAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcclxuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcclxuICAgIGlmICghYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoZXF1YWxpdHlDaGVjaywgbGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcclxuICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cclxuICAgICAgbGFzdFJlc3VsdCA9ICg8RnVuY3Rpb24+ZnVuYykuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcclxuICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gIH1cclxuICAoPGFueT5tZW1vaXplZCkucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vIFRoZSBoaWRkZW4gKGZvciBub3cpIGFiaWxpdHkgdG8gcmVzZXQgdGhlIG1lbW9pemF0aW9uXHJcbiAgICBsYXN0QXJncyA9IG51bGw7XHJcbiAgICBsYXN0UmVzdWx0ID0gbnVsbDtcclxuICB9O1xyXG4gIHJldHVybiBtZW1vaXplZCBhcyBUO1xyXG59XHJcbiJdfQ==