/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ensureSelectorMetadata, getSelectorMetadata, getStoreMetadata } from '../internal/internals';
import { memoize } from '../utils/memoize';
/**
 * Function for creating a selector
 * @template T
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
export function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    var wrappedFn = (/** @type {?} */ ((/**
     * @param {...?} args
     * @return {?}
     */
    function wrappedSelectorFn() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        /** @type {?} */
        var returnValue = originalFn.apply(void 0, tslib_1.__spread(args));
        if (returnValue instanceof Function) {
            /** @type {?} */
            var innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    })));
    /** @type {?} */
    var memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    var containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    var fn = (/**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        /** @type {?} */
        var results = [];
        /** @type {?} */
        var selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            var metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push.apply(selectorsToApply, tslib_1.__spread(selectors));
        }
        // Determine arguments from the app state using the selectors
        results.push.apply(results, tslib_1.__spread(selectorsToApply.map((/**
         * @param {?} a
         * @return {?}
         */
        function (a) { return getSelectorFn(a)(state); }))));
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn.apply(void 0, tslib_1.__spread(results));
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    });
    /** @type {?} */
    var selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
export function getSelectorFn(selector) {
    /** @type {?} */
    var metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3ItdXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy91dGlscy9zZWxlY3Rvci11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFFTCxzQkFBc0IsRUFDdEIsbUJBQW1CLEVBQ25CLGdCQUFnQixFQUNqQixNQUFNLHVCQUF1QixDQUFDO0FBQy9CLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7Ozs7Ozs7O0FBUTNDLE1BQU0sVUFBVSxjQUFjLENBQzVCLFNBQTRCLEVBQzVCLFVBQWEsRUFDYixnQkFBZ0U7O1FBRTFELFNBQVMsR0FBRzs7OztJQUFBLFNBQVMsaUJBQWlCO1FBQUMsY0FBYzthQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7WUFBZCx5QkFBYzs7O1lBQ25ELFdBQVcsR0FBRyxVQUFVLGdDQUFJLElBQUksRUFBQztRQUN2QyxJQUFJLFdBQVcsWUFBWSxRQUFRLEVBQUU7O2dCQUM3QixlQUFlLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUMxRCxPQUFPLGVBQWUsQ0FBQztTQUN4QjtRQUNELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUMsR0FBSzs7UUFDQSxVQUFVLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQzs7UUFDL0IsY0FBYyxHQUFHLGdCQUFnQixJQUFJLGdCQUFnQixDQUFDLGNBQWM7O1FBRXBFLEVBQUU7Ozs7SUFBRyxVQUFDLEtBQVU7O1lBQ2QsT0FBTyxHQUFHLEVBQUU7O1lBRVosZ0JBQWdCLEdBQUcsRUFBRTtRQUUzQixJQUFJLGNBQWMsRUFBRTs7O2dCQUVaLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUM7WUFDakQsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osZ0JBQWdCLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2FBQ3ZDO1NBQ0Y7UUFFRCxJQUFJLFNBQVMsRUFBRTtZQUNiLGdCQUFnQixDQUFDLElBQUksT0FBckIsZ0JBQWdCLG1CQUFTLFNBQVMsR0FBRTtTQUNyQztRQUVELDZEQUE2RDtRQUM3RCxPQUFPLENBQUMsSUFBSSxPQUFaLE9BQU8sbUJBQVMsZ0JBQWdCLENBQUMsR0FBRzs7OztRQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUF2QixDQUF1QixFQUFDLEdBQUU7UUFFcEUsbURBQW1EO1FBQ25ELHVEQUF1RDtRQUN2RCx5RUFBeUU7UUFDekUsSUFBSTtZQUNGLE9BQU8sVUFBVSxnQ0FBSSxPQUFPLEdBQUU7U0FDL0I7UUFBQyxPQUFPLEVBQUUsRUFBRTtZQUNYLElBQUksRUFBRSxZQUFZLFNBQVMsRUFBRTtnQkFDM0IsT0FBTyxTQUFTLENBQUM7YUFDbEI7WUFDRCxNQUFNLEVBQUUsQ0FBQztTQUNWO0lBQ0gsQ0FBQyxDQUFBOztRQUVLLGdCQUFnQixHQUFHLHNCQUFzQixDQUFDLFVBQVUsQ0FBQztJQUMzRCxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO0lBQ3pDLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHLEVBQUUsQ0FBQztJQUN6QyxJQUFJLGdCQUFnQixFQUFFO1FBQ3BCLGdCQUFnQixDQUFDLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUM7UUFDbEUsZ0JBQWdCLENBQUMsWUFBWSxHQUFHLGdCQUFnQixDQUFDLFlBQVksQ0FBQztLQUMvRDtJQUNELE9BQU8sVUFBVSxDQUFDO0FBQ3BCLENBQUM7Ozs7Ozs7QUFNRCxNQUFNLFVBQVUsYUFBYSxDQUFDLFFBQWE7O1FBQ25DLFFBQVEsR0FBRyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUM7SUFDNUUsT0FBTyxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsa0JBQWtCLENBQUMsSUFBSSxRQUFRLENBQUM7QUFDL0QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgU2VsZWN0RnJvbVN0YXRlLFxyXG4gIGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEsXHJcbiAgZ2V0U2VsZWN0b3JNZXRhZGF0YSxcclxuICBnZXRTdG9yZU1ldGFkYXRhXHJcbn0gZnJvbSAnLi4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWxzL21lbW9pemUnO1xyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIHNlbGVjdG9yXHJcbiAqIEBwYXJhbSBzZWxlY3RvcnMgVGhlIHNlbGVjdG9ycyB0byB1c2UgdG8gY3JlYXRlIHRoZSBhcmd1bWVudHMgb2YgdGhpcyBmdW5jdGlvblxyXG4gKiBAcGFyYW0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gYmVpbmcgbWFkZSBpbnRvIGEgc2VsZWN0b3JcclxuICogQHBhcmFtIGNyZWF0aW9uTWV0YWRhdGFcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcjxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxyXG4gIHNlbGVjdG9yczogYW55W10gfCB1bmRlZmluZWQsXHJcbiAgb3JpZ2luYWxGbjogVCxcclxuICBjcmVhdGlvbk1ldGFkYXRhPzogeyBjb250YWluZXJDbGFzczogYW55OyBzZWxlY3Rvck5hbWU6IHN0cmluZyB9XHJcbikge1xyXG4gIGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uIHdyYXBwZWRTZWxlY3RvckZuKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBjb25zdCByZXR1cm5WYWx1ZSA9IG9yaWdpbmFsRm4oLi4uYXJncyk7XHJcbiAgICBpZiAocmV0dXJuVmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICBjb25zdCBpbm5lck1lbW9pemVkRm4gPSBtZW1vaXplLmFwcGx5KG51bGwsIFtyZXR1cm5WYWx1ZV0pO1xyXG4gICAgICByZXR1cm4gaW5uZXJNZW1vaXplZEZuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gIH0gYXMgVDtcclxuICBjb25zdCBtZW1vaXplZEZuID0gbWVtb2l6ZSh3cmFwcGVkRm4pO1xyXG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YSAmJiBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xyXG5cclxuICBjb25zdCBmbiA9IChzdGF0ZTogYW55KSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IFtdO1xyXG5cclxuICAgIGlmIChjb250YWluZXJDbGFzcykge1xyXG4gICAgICAvLyBJZiB3ZSBhcmUgb24gYSBzdGF0ZSBjbGFzcywgYWRkIGl0IGFzIHRoZSBmaXJzdCBzZWxlY3RvciBwYXJhbWV0ZXJcclxuICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZXRTdG9yZU1ldGFkYXRhKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgaWYgKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKGNvbnRhaW5lckNsYXNzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWxlY3RvcnMpIHtcclxuICAgICAgc2VsZWN0b3JzVG9BcHBseS5wdXNoKC4uLnNlbGVjdG9ycyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGFyZ3VtZW50cyBmcm9tIHRoZSBhcHAgc3RhdGUgdXNpbmcgdGhlIHNlbGVjdG9yc1xyXG4gICAgcmVzdWx0cy5wdXNoKC4uLnNlbGVjdG9yc1RvQXBwbHkubWFwKGEgPT4gZ2V0U2VsZWN0b3JGbihhKShzdGF0ZSkpKTtcclxuXHJcbiAgICAvLyBpZiB0aGUgbGFtYmRhIHRyaWVzIHRvIGFjY2VzcyBhIHNvbWV0aGluZyBvbiB0aGVcclxuICAgIC8vIHN0YXRlIHRoYXQgZG9lc24ndCBleGlzdCwgaXQgd2lsbCB0aHJvdyBhIFR5cGVFcnJvci5cclxuICAgIC8vIHNpbmNlIHRoaXMgaXMgcXVpdGUgdXN1YWwgYmVoYXZpb3VyLCB3ZSBzaW1wbHkgcmV0dXJuIHVuZGVmaW5lZCBpZiBzby5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBtZW1vaXplZEZuKC4uLnJlc3VsdHMpO1xyXG4gICAgfSBjYXRjaCAoZXgpIHtcclxuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBleDtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBjb25zdCBzZWxlY3Rvck1ldGFEYXRhID0gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YShtZW1vaXplZEZuKTtcclxuICBzZWxlY3Rvck1ldGFEYXRhLm9yaWdpbmFsRm4gPSBvcmlnaW5hbEZuO1xyXG4gIHNlbGVjdG9yTWV0YURhdGEuc2VsZWN0RnJvbUFwcFN0YXRlID0gZm47XHJcbiAgaWYgKGNyZWF0aW9uTWV0YWRhdGEpIHtcclxuICAgIHNlbGVjdG9yTWV0YURhdGEuY29udGFpbmVyQ2xhc3MgPSBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xyXG4gICAgc2VsZWN0b3JNZXRhRGF0YS5zZWxlY3Rvck5hbWUgPSBjcmVhdGlvbk1ldGFkYXRhLnNlbGVjdG9yTmFtZTtcclxuICB9XHJcbiAgcmV0dXJuIG1lbW9pemVkRm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gZ2V0IHRoZSBzZWxlY3RlZCBzbGljZSBmcm9tIHRoZSBhcHAgc3RhdGVcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yRm4oc2VsZWN0b3I6IGFueSk6IFNlbGVjdEZyb21TdGF0ZSB7XHJcbiAgY29uc3QgbWV0YWRhdGEgPSBnZXRTZWxlY3Rvck1ldGFkYXRhKHNlbGVjdG9yKSB8fCBnZXRTdG9yZU1ldGFkYXRhKHNlbGVjdG9yKTtcclxuICByZXR1cm4gKG1ldGFkYXRhICYmIG1ldGFkYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSkgfHwgc2VsZWN0b3I7XHJcbn1cclxuIl19