/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, InjectionToken } from '@angular/core';
import { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';
/** @type {?} */
export var ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
export var FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
export var META_KEY = 'NGXS_META';
/** @type {?} */
export var META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
/** @type {?} */
export var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/** @type {?} */
export var NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/**
 * The NGXS config settings.
 */
var NgxsConfig = /** @class */ (function () {
    function NgxsConfig() {
        /**
         * Defining the default state before module initialization
         * This is convenient if we need to create a define our own set of states.
         * (default: {})
         */
        this.defaultsState = {};
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;
    }
    NgxsConfig.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NgxsConfig.ctorParameters = function () { return []; };
    return NgxsConfig;
}());
export { NgxsConfig };
if (false) {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     * @type {?}
     */
    NgxsConfig.prototype.developmentMode;
    /** @type {?} */
    NgxsConfig.prototype.compatibility;
    /**
     * Determines the execution context to perform async operations inside. An implementation can be
     * provided to override the default behaviour where the async operations are run
     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.
     * These observable behaviours are from:
     *   `\@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`
     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your
     * application doesn't rely on zone.js running change detection then you can switch to the
     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.
     * (default: null)
     * @type {?}
     */
    NgxsConfig.prototype.executionStrategy;
    /**
     * Defining the default state before module initialization
     * This is convenient if we need to create a define our own set of states.
     * (default: {})
     * @type {?}
     */
    NgxsConfig.prototype.defaultsState;
}
/**
 * @record
 */
export function ActionDef() { }
if (false) {
    /** @type {?} */
    ActionDef.prototype.type;
    /* Skipping unhandled member: new (...args: any[]): any;*/
}
/**
 * State context provided to the actions in the state.
 * @record
 * @template T
 */
export function StateContext() { }
if (false) {
    /**
     * Get the current state.
     * @return {?}
     */
    StateContext.prototype.getState = function () { };
    /**
     * Reset the state to a new value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.setState = function (val) { };
    /**
     * Patch the existing state with the provided value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.patchState = function (val) { };
    /**
     * Dispatch a new action and return the dispatched observable.
     * @param {?} actions
     * @return {?}
     */
    StateContext.prototype.dispatch = function (actions) { };
}
/**
 * Plugin interface
 * @record
 */
export function NgxsPlugin() { }
if (false) {
    /**
     * Handle the state/action before its submitted to the state handlers.
     * @param {?} state
     * @param {?} action
     * @param {?} next
     * @return {?}
     */
    NgxsPlugin.prototype.handle = function (state, action, next) { };
}
/**
 * Options that can be provided to the store.
 * @record
 * @template T
 */
export function StoreOptions() { }
if (false) {
    /**
     * Name of the state. Required.
     * @type {?}
     */
    StoreOptions.prototype.name;
    /**
     * Default values for the state. If not provided, uses empty object.
     * @type {?|undefined}
     */
    StoreOptions.prototype.defaults;
    /**
     * Sub states for the given state.
     * @type {?|undefined}
     */
    StoreOptions.prototype.children;
}
/**
 * Actions that can be provided in a action decorator.
 * @record
 */
export function ActionOptions() { }
if (false) {
    /**
     * Cancel the previous uncompleted observable(s).
     * @type {?|undefined}
     */
    ActionOptions.prototype.cancelUncompleted;
}
/** @enum {string} */
var LifecycleHooks = {
    NgxsOnInit: 'ngxsOnInit',
    NgxsAfterBootstrap: 'ngxsAfterBootstrap',
};
export { LifecycleHooks };
/**
 * On init interface
 * @record
 */
export function NgxsOnInit() { }
if (false) {
    /**
     * @param {?=} ctx
     * @return {?}
     */
    NgxsOnInit.prototype.ngxsOnInit = function (ctx) { };
}
/**
 * After bootstrap interface
 * @record
 */
export function NgxsAfterBootstrap() { }
if (false) {
    /**
     * @param {?=} ctx
     * @return {?}
     */
    NgxsAfterBootstrap.prototype.ngxsAfterBootstrap = function (ctx) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ltYm9scy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL3N5bWJvbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFRLE1BQU0sZUFBZSxDQUFDO0FBS2pFLE9BQU8sRUFBRSx3Q0FBd0MsRUFBRSxNQUFNLDJEQUEyRCxDQUFDOztBQUVySCxNQUFNLEtBQU8sZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQU0sa0JBQWtCLENBQUM7O0FBQzNFLE1BQU0sS0FBTyxtQkFBbUIsR0FBRyxJQUFJLGNBQWMsQ0FBTSxxQkFBcUIsQ0FBQzs7QUFDakYsTUFBTSxLQUFPLFFBQVEsR0FBRyxXQUFXOztBQUNuQyxNQUFNLEtBQU8sZ0JBQWdCLEdBQUcsbUJBQW1COztBQUNuRCxNQUFNLEtBQU8saUJBQWlCLEdBQUcsb0JBQW9COztBQUVyRCxNQUFNLEtBQU8sWUFBWSxHQUFHLElBQUksY0FBYyxDQUFDLGNBQWMsQ0FBQzs7OztBQU05RDtJQW1DRTs7Ozs7O1FBRkEsa0JBQWEsR0FBc0IsRUFBRSxDQUFDO1FBR3BDLElBQUksQ0FBQyxhQUFhLEdBQUc7WUFDbkIsMkJBQTJCLEVBQUUsS0FBSztTQUNuQyxDQUFDO1FBQ0YsSUFBSSxDQUFDLGlCQUFpQixHQUFHLHdDQUF3QyxDQUFDO0lBQ3BFLENBQUM7O2dCQXhDRixVQUFVOzs7O0lBeUNYLGlCQUFDO0NBQUEsQUF6Q0QsSUF5Q0M7U0F4Q1ksVUFBVTs7Ozs7Ozs7SUFNckIscUNBQXlCOztJQUN6QixtQ0FPRTs7Ozs7Ozs7Ozs7OztJQVlGLHVDQUErQzs7Ozs7OztJQU0vQyxtQ0FBc0M7Ozs7O0FBVXhDLCtCQUlDOzs7SUFIQyx5QkFBYTs7Ozs7Ozs7QUFVZixrQ0FvQkM7Ozs7OztJQWhCQyxrREFBYzs7Ozs7O0lBS2QscURBQXVDOzs7Ozs7SUFLdkMsdURBQStCOzs7Ozs7SUFLL0IseURBQWlEOzs7Ozs7QUFRbkQsZ0NBS0M7Ozs7Ozs7OztJQURDLGlFQUE2RDs7Ozs7OztBQU0vRCxrQ0FlQzs7Ozs7O0lBWEMsNEJBQWE7Ozs7O0lBS2IsZ0NBQWE7Ozs7O0lBS2IsZ0NBQWlCOzs7Ozs7QUFNbkIsbUNBS0M7Ozs7OztJQURDLDBDQUE0Qjs7OztJQUk1QixZQUFhLFlBQVk7SUFDekIsb0JBQXFCLG9CQUFvQjs7Ozs7OztBQU0zQyxnQ0FFQzs7Ozs7O0lBREMscURBQWdEOzs7Ozs7QUFNbEQsd0NBRUM7Ozs7OztJQURDLHFFQUFrRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7IE9iamVjdEtleU1hcCB9IGZyb20gJy4vaW50ZXJuYWwvaW50ZXJuYWxzJztcclxuaW1wb3J0IHsgTmd4c0V4ZWN1dGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9leGVjdXRpb24vc3ltYm9scyc7XHJcbmltcG9ydCB7IERpc3BhdGNoT3V0c2lkZVpvbmVOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9kaXNwYXRjaC1vdXRzaWRlLXpvbmUtbmd4cy1leGVjdXRpb24tc3RyYXRlZ3knO1xyXG5cclxuZXhwb3J0IGNvbnN0IFJPT1RfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignUk9PVF9TVEFURV9UT0tFTicpO1xyXG5leHBvcnQgY29uc3QgRkVBVFVSRV9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdGRUFUVVJFX1NUQVRFX1RPS0VOJyk7XHJcbmV4cG9ydCBjb25zdCBNRVRBX0tFWSA9ICdOR1hTX01FVEEnO1xyXG5leHBvcnQgY29uc3QgTUVUQV9PUFRJT05TX0tFWSA9ICdOR1hTX09QVElPTlNfTUVUQSc7XHJcbmV4cG9ydCBjb25zdCBTRUxFQ1RPUl9NRVRBX0tFWSA9ICdOR1hTX1NFTEVDVE9SX01FVEEnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE5HWFNfUExVR0lOUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTkdYU19QTFVHSU5TJyk7XHJcbmV4cG9ydCB0eXBlIE5neHNQbHVnaW5GbiA9IChzdGF0ZTogYW55LCBtdXRhdGlvbjogYW55LCBuZXh0OiBOZ3hzTmV4dFBsdWdpbkZuKSA9PiBhbnk7XHJcblxyXG4vKipcclxuICogVGhlIE5HWFMgY29uZmlnIHNldHRpbmdzLlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTmd4c0NvbmZpZyB7XHJcbiAgLyoqXHJcbiAgICogUnVuIGluIGRldmVsb3BtZW50IG1vZGUuIFRoaXMgd2lsbCBhZGQgYWRkaXRpb25hbCBkZWJ1Z2dpbmcgZmVhdHVyZXM6XHJcbiAgICogLSBPYmplY3QuZnJlZXplIG9uIHRoZSBzdGF0ZSBhbmQgYWN0aW9ucyB0byBndWFyYW50ZWUgaW1tdXRhYmlsaXR5XHJcbiAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAqL1xyXG4gIGRldmVsb3BtZW50TW9kZTogYm9vbGVhbjtcclxuICBjb21wYXRpYmlsaXR5OiB7XHJcbiAgICAvKipcclxuICAgICAqIFN1cHBvcnQgYSBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXHJcbiAgICAgKiBUaGlzIHdpbGwgY2lydW12ZW50IHNvbWUgb3B0aW1pc2F0aW9ucyB0aGF0IHZpb2xhdGUgYSBzdHJpY3QgQ1NQIHRocm91Z2ggdGhlIHVzZSBvZiBgbmV3IEZ1bmN0aW9uKC4uLilgLlxyXG4gICAgICogKGRlZmF1bHQ6IGZhbHNlKVxyXG4gICAgICovXHJcbiAgICBzdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3k6IGJvb2xlYW47XHJcbiAgfTtcclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBleGVjdXRpb24gY29udGV4dCB0byBwZXJmb3JtIGFzeW5jIG9wZXJhdGlvbnMgaW5zaWRlLiBBbiBpbXBsZW1lbnRhdGlvbiBjYW4gYmVcclxuICAgKiBwcm92aWRlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgd2hlcmUgdGhlIGFzeW5jIG9wZXJhdGlvbnMgYXJlIHJ1blxyXG4gICAqIG91dHNpZGUgQW5ndWxhcidzIHpvbmUgYnV0IGFsbCBvYnNlcnZhYmxlIGJlaGF2aW91cnMgb2YgTkdYUyBhcmUgcnVuIGJhY2sgaW5zaWRlIEFuZ3VsYXIncyB6b25lLlxyXG4gICAqIFRoZXNlIG9ic2VydmFibGUgYmVoYXZpb3VycyBhcmUgZnJvbTpcclxuICAgKiAgIGBAU2VsZWN0KC4uLilgLCBgc3RvcmUuc2VsZWN0KC4uLilgLCBgYWN0aW9ucy5zdWJzY3JpYmUoLi4uKWAgb3IgYHN0b3JlLmRpc3BhdGNoKC4uLikuc3Vic2NyaWJlKC4uLilgXHJcbiAgICogRXZlcnkgYHpvbmUucnVuYCBjYXVzZXMgQW5ndWxhciB0byBydW4gY2hhbmdlIGRldGVjdGlvbiBvbiB0aGUgd2hvbGUgdHJlZSAoYGFwcC50aWNrKClgKSBzbyBvZiB5b3VyXHJcbiAgICogYXBwbGljYXRpb24gZG9lc24ndCByZWx5IG9uIHpvbmUuanMgcnVubmluZyBjaGFuZ2UgZGV0ZWN0aW9uIHRoZW4geW91IGNhbiBzd2l0Y2ggdG8gdGhlXHJcbiAgICogYE5vb3BOZ3hzRXhlY3V0aW9uU3RyYXRlZ3lgIHRoYXQgZG9lc24ndCBpbnRlcmFjdCB3aXRoIHpvbmVzLlxyXG4gICAqIChkZWZhdWx0OiBudWxsKVxyXG4gICAqL1xyXG4gIGV4ZWN1dGlvblN0cmF0ZWd5OiBUeXBlPE5neHNFeGVjdXRpb25TdHJhdGVneT47XHJcbiAgLyoqXHJcbiAgICogRGVmaW5pbmcgdGhlIGRlZmF1bHQgc3RhdGUgYmVmb3JlIG1vZHVsZSBpbml0aWFsaXphdGlvblxyXG4gICAqIFRoaXMgaXMgY29udmVuaWVudCBpZiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGRlZmluZSBvdXIgb3duIHNldCBvZiBzdGF0ZXMuXHJcbiAgICogKGRlZmF1bHQ6IHt9KVxyXG4gICAqL1xyXG4gIGRlZmF1bHRzU3RhdGU6IE9iamVjdEtleU1hcDxhbnk+ID0ge307XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5jb21wYXRpYmlsaXR5ID0ge1xyXG4gICAgICBzdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3k6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgdGhpcy5leGVjdXRpb25TdHJhdGVneSA9IERpc3BhdGNoT3V0c2lkZVpvbmVOZ3hzRXhlY3V0aW9uU3RyYXRlZ3k7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkRlZiB7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG5cclxuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTdGF0ZU9wZXJhdG9yPFQ+ID0gKGV4aXN0aW5nOiBSZWFkb25seTxUPikgPT4gVDtcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBjb250ZXh0IHByb3ZpZGVkIHRvIHRoZSBhY3Rpb25zIGluIHRoZSBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDb250ZXh0PFQ+IHtcclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAgICovXHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldFN0YXRlKHZhbDogVCB8IFN0YXRlT3BlcmF0b3I8VD4pOiBUO1xyXG5cclxuICAvKipcclxuICAgKiBQYXRjaCB0aGUgZXhpc3Rpbmcgc3RhdGUgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUuXHJcbiAgICovXHJcbiAgcGF0Y2hTdGF0ZSh2YWw6IFBhcnRpYWw8VD4pOiBUO1xyXG5cclxuICAvKipcclxuICAgKiBEaXNwYXRjaCBhIG5ldyBhY3Rpb24gYW5kIHJldHVybiB0aGUgZGlzcGF0Y2hlZCBvYnNlcnZhYmxlLlxyXG4gICAqL1xyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTmd4c05leHRQbHVnaW5GbiA9IChzdGF0ZTogYW55LCBtdXRhdGlvbjogYW55KSA9PiBhbnk7XHJcblxyXG4vKipcclxuICogUGx1Z2luIGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzUGx1Z2luIHtcclxuICAvKipcclxuICAgKiBIYW5kbGUgdGhlIHN0YXRlL2FjdGlvbiBiZWZvcmUgaXRzIHN1Ym1pdHRlZCB0byB0aGUgc3RhdGUgaGFuZGxlcnMuXHJcbiAgICovXHJcbiAgaGFuZGxlKHN0YXRlOiBhbnksIGFjdGlvbjogYW55LCBuZXh0OiBOZ3hzTmV4dFBsdWdpbkZuKTogYW55O1xyXG59XHJcblxyXG4vKipcclxuICogT3B0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZCB0byB0aGUgc3RvcmUuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlT3B0aW9uczxUPiB7XHJcbiAgLyoqXHJcbiAgICogTmFtZSBvZiB0aGUgc3RhdGUuIFJlcXVpcmVkLlxyXG4gICAqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogRGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSBzdGF0ZS4gSWYgbm90IHByb3ZpZGVkLCB1c2VzIGVtcHR5IG9iamVjdC5cclxuICAgKi9cclxuICBkZWZhdWx0cz86IFQ7XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YiBzdGF0ZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZS5cclxuICAgKi9cclxuICBjaGlsZHJlbj86IGFueVtdO1xyXG59XHJcblxyXG4vKipcclxuICogQWN0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZCBpbiBhIGFjdGlvbiBkZWNvcmF0b3IuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbk9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIENhbmNlbCB0aGUgcHJldmlvdXMgdW5jb21wbGV0ZWQgb2JzZXJ2YWJsZShzKS5cclxuICAgKi9cclxuICBjYW5jZWxVbmNvbXBsZXRlZD86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBlbnVtIExpZmVjeWNsZUhvb2tzIHtcclxuICBOZ3hzT25Jbml0ID0gJ25neHNPbkluaXQnLFxyXG4gIE5neHNBZnRlckJvb3RzdHJhcCA9ICduZ3hzQWZ0ZXJCb290c3RyYXAnXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPbiBpbml0IGludGVyZmFjZVxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBOZ3hzT25Jbml0IHtcclxuICBuZ3hzT25Jbml0KGN0eD86IFN0YXRlQ29udGV4dDxhbnk+KTogdm9pZCB8IGFueTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFmdGVyIGJvb3RzdHJhcCBpbnRlcmZhY2VcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmd4c0FmdGVyQm9vdHN0cmFwIHtcclxuICBuZ3hzQWZ0ZXJCb290c3RyYXAoY3R4PzogU3RhdGVDb250ZXh0PGFueT4pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZ3hzTGlmZUN5Y2xlID0gUGFydGlhbDxOZ3hzT25Jbml0PiAmIFBhcnRpYWw8Tmd4c0FmdGVyQm9vdHN0cmFwPjtcclxuIl19