/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';
import { leaveNgxs } from './operators/leave-ngxs';
/** @enum {string} */
var ActionStatus = {
    Dispatched: 'DISPATCHED',
    Successful: 'SUCCESSFUL',
    Canceled: 'CANCELED',
    Errored: 'ERRORED',
};
export { ActionStatus };
/**
 * @record
 * @template T
 */
export function ActionContext() { }
if (false) {
    /** @type {?} */
    ActionContext.prototype.status;
    /** @type {?} */
    ActionContext.prototype.action;
    /** @type {?|undefined} */
    ActionContext.prototype.error;
}
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
var /**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
OrderedSubject = /** @class */ (function (_super) {
    tslib_1.__extends(OrderedSubject, _super);
    function OrderedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._itemQueue = [];
        _this._busyPushingNext = false;
        return _this;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    OrderedSubject.prototype.next = /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._busyPushingNext) {
            this._itemQueue.unshift((/** @type {?} */ (value)));
            return;
        }
        this._busyPushingNext = true;
        _super.prototype.next.call(this, value);
        while (this._itemQueue.length > 0) {
            /** @type {?} */
            var nextValue = this._itemQueue.pop();
            _super.prototype.next.call(this, nextValue);
        }
        this._busyPushingNext = false;
    };
    return OrderedSubject;
}(Subject));
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
export { OrderedSubject };
if (false) {
    /**
     * @type {?}
     * @private
     */
    OrderedSubject.prototype._itemQueue;
    /**
     * @type {?}
     * @private
     */
    OrderedSubject.prototype._busyPushingNext;
}
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
var InternalActions = /** @class */ (function (_super) {
    tslib_1.__extends(InternalActions, _super);
    function InternalActions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InternalActions.decorators = [
        { type: Injectable }
    ];
    return InternalActions;
}(OrderedSubject));
export { InternalActions };
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
var Actions = /** @class */ (function (_super) {
    tslib_1.__extends(Actions, _super);
    function Actions(actions$, internalExecutionStrategy) {
        return _super.call(this, (/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            actions$
                .pipe(leaveNgxs(internalExecutionStrategy))
                .subscribe((/**
             * @param {?} res
             * @return {?}
             */
            function (res) { return observer.next(res); }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) { return observer.error(err); }), (/**
             * @return {?}
             */
            function () { return observer.complete(); }));
        })) || this;
    }
    Actions.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Actions.ctorParameters = function () { return [
        { type: InternalActions },
        { type: InternalNgxsExecutionStrategy }
    ]; };
    return Actions;
}(Observable));
export { Actions };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy1zdHJlYW0uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy9hY3Rpb25zLXN0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFM0MsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sOENBQThDLENBQUM7QUFDN0YsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHdCQUF3QixDQUFDOzs7SUFNakQsWUFBYSxZQUFZO0lBQ3pCLFlBQWEsWUFBWTtJQUN6QixVQUFXLFVBQVU7SUFDckIsU0FBVSxTQUFTOzs7Ozs7O0FBR3JCLG1DQUlDOzs7SUFIQywrQkFBcUI7O0lBQ3JCLCtCQUFVOztJQUNWLDhCQUFjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQmhCOzs7Ozs7Ozs7Ozs7Ozs7OztJQUF1QywwQ0FBVTtJQUFqRDtRQUFBLHFFQWlCQztRQWhCUyxnQkFBVSxHQUFRLEVBQUUsQ0FBQztRQUNyQixzQkFBZ0IsR0FBRyxLQUFLLENBQUM7O0lBZW5DLENBQUM7Ozs7O0lBYkMsNkJBQUk7Ozs7SUFBSixVQUFLLEtBQVM7UUFDWixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN6QixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxtQkFBQSxLQUFLLEVBQUMsQ0FBQyxDQUFDO1lBQ2hDLE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDN0IsaUJBQU0sSUFBSSxZQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOztnQkFDM0IsU0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFO1lBQ3ZDLGlCQUFNLElBQUksWUFBQyxTQUFTLENBQUMsQ0FBQztTQUN2QjtRQUNELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7SUFDaEMsQ0FBQztJQUNILHFCQUFDO0FBQUQsQ0FBQyxBQWpCRCxDQUF1QyxPQUFPLEdBaUI3Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFoQkMsb0NBQTZCOzs7OztJQUM3QiwwQ0FBaUM7Ozs7O0FBb0JuQztJQUNxQywyQ0FBNkI7SUFEbEU7O0lBQ29FLENBQUM7O2dCQURwRSxVQUFVOztJQUN5RCxzQkFBQztDQUFBLEFBRHJFLENBQ3FDLGNBQWMsR0FBa0I7U0FBeEQsZUFBZTs7Ozs7O0FBTzVCO0lBQzZCLG1DQUFlO0lBQzFDLGlCQUNFLFFBQXlCLEVBQ3pCLHlCQUF3RDtlQUV4RDs7OztRQUFNLFVBQUEsUUFBUTtZQUNaLFFBQVE7aUJBQ0wsSUFBSSxDQUFDLFNBQVMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO2lCQUMxQyxTQUFTOzs7O1lBQ1IsVUFBQSxHQUFHLElBQUksT0FBQSxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFsQixDQUFrQjs7OztZQUN6QixVQUFBLEdBQUcsSUFBSSxPQUFBLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQW5CLENBQW1COzs7WUFDMUIsY0FBTSxPQUFBLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBbkIsQ0FBbUIsRUFDMUIsQ0FBQztRQUNOLENBQUMsRUFBQztJQUNKLENBQUM7O2dCQWZGLFVBQVU7Ozs7Z0JBR0csZUFBZTtnQkFuRXBCLDZCQUE2Qjs7SUFnRnRDLGNBQUM7Q0FBQSxBQWhCRCxDQUM2QixVQUFVLEdBZXRDO1NBZlksT0FBTyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgSW50ZXJuYWxOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9pbnRlcm5hbC1uZ3hzLWV4ZWN1dGlvbi1zdHJhdGVneSc7XHJcbmltcG9ydCB7IGxlYXZlTmd4cyB9IGZyb20gJy4vb3BlcmF0b3JzL2xlYXZlLW5neHMnO1xyXG5cclxuLyoqXHJcbiAqIFN0YXR1cyBvZiBhIGRpc3BhdGNoZWQgYWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZW51bSBBY3Rpb25TdGF0dXMge1xyXG4gIERpc3BhdGNoZWQgPSAnRElTUEFUQ0hFRCcsXHJcbiAgU3VjY2Vzc2Z1bCA9ICdTVUNDRVNTRlVMJyxcclxuICBDYW5jZWxlZCA9ICdDQU5DRUxFRCcsXHJcbiAgRXJyb3JlZCA9ICdFUlJPUkVEJ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNvbnRleHQ8VCA9IGFueT4ge1xyXG4gIHN0YXR1czogQWN0aW9uU3RhdHVzO1xyXG4gIGFjdGlvbjogVDtcclxuICBlcnJvcj86IEVycm9yO1xyXG59XHJcblxyXG4vKipcclxuICogQ3VzdG9tIFN1YmplY3QgdGhhdCBlbnN1cmVzIHRoYXQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFycml2ZWQuXHJcbiAqIEEgc3RhbmRhcmQgU3ViamVjdCBkb2VzIG5vdCBoYXZlIHRoaXMgZ3VhcmFudGVlLlxyXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBjb2RlOlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqICAgY29uc3Qgc3ViamVjdCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICBpZiAodmFsdWUgPT09ICdzdGFydCcpIHN1YmplY3QubmV4dCgnZW5kJyk7XHJcbiAgICAgfSk7XHJcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4geyB9KTtcclxuICAgICBzdWJqZWN0Lm5leHQoJ3N0YXJ0Jyk7XHJcbiAqIGBgYFxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIHN0YW5kYXJkIGBTdWJqZWN0PFQ+YCB0aGUgc2Vjb25kIHN1YnNjcmliZXIgd291bGQgcmVjaWV2ZSBgZW5kYCBhbmQgdGhlbiBgc3RhcnRgLlxyXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIGBPcmRlcmVkU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYHN0YXJ0YCBhbmQgdGhlbiBgZW5kYC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBPcmRlcmVkU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xyXG4gIHByaXZhdGUgX2l0ZW1RdWV1ZTogVFtdID0gW107XHJcbiAgcHJpdmF0ZSBfYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XHJcblxyXG4gIG5leHQodmFsdWU/OiBUKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fYnVzeVB1c2hpbmdOZXh0KSB7XHJcbiAgICAgIHRoaXMuX2l0ZW1RdWV1ZS51bnNoaWZ0KHZhbHVlISk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IHRydWU7XHJcbiAgICBzdXBlci5uZXh0KHZhbHVlKTtcclxuICAgIHdoaWxlICh0aGlzLl9pdGVtUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSB0aGlzLl9pdGVtUXVldWUucG9wKCk7XHJcbiAgICAgIHN1cGVyLm5leHQobmV4dFZhbHVlKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIEFjdGlvbiBzdHJlYW0gdGhhdCBpcyBlbWl0dGVkIGFueXRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBJbnRlcm5hbEFjdGlvbnMgZXh0ZW5kcyBPcmRlcmVkU3ViamVjdDxBY3Rpb25Db250ZXh0PiB7fVxyXG5cclxuLyoqXHJcbiAqIEFjdGlvbiBzdHJlYW0gdGhhdCBpcyBlbWl0dGVkIGFueXRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQuXHJcbiAqXHJcbiAqIFlvdSBjYW4gbGlzdGVuIHRvIHRoaXMgaW4gc2VydmljZXMgdG8gcmVhY3Qgd2l0aG91dCBzdG9yZXMuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBBY3Rpb25zIGV4dGVuZHMgT2JzZXJ2YWJsZTxhbnk+IHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICBpbnRlcm5hbEV4ZWN1dGlvblN0cmF0ZWd5OiBJbnRlcm5hbE5neHNFeGVjdXRpb25TdHJhdGVneVxyXG4gICkge1xyXG4gICAgc3VwZXIob2JzZXJ2ZXIgPT4ge1xyXG4gICAgICBhY3Rpb25zJFxyXG4gICAgICAgIC5waXBlKGxlYXZlTmd4cyhpbnRlcm5hbEV4ZWN1dGlvblN0cmF0ZWd5KSlcclxuICAgICAgICAuc3Vic2NyaWJlKFxyXG4gICAgICAgICAgcmVzID0+IG9ic2VydmVyLm5leHQocmVzKSxcclxuICAgICAgICAgIGVyciA9PiBvYnNlcnZlci5lcnJvcihlcnIpLFxyXG4gICAgICAgICAgKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKVxyXG4gICAgICAgICk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIl19