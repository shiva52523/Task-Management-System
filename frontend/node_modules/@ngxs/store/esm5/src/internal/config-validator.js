/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, isDevMode } from '@angular/core';
import { isAngularInTestMode } from '../utils/angular';
import { NgxsConfig } from '../symbols';
var ConfigValidator = /** @class */ (function () {
    function ConfigValidator(_config) {
        this._config = _config;
    }
    /**
     * @return {?}
     */
    ConfigValidator.prototype.verifyDevMode = /**
     * @return {?}
     */
    function () {
        if (isAngularInTestMode()) {
            return;
        }
        /** @type {?} */
        var isNgxsDevMode = this._config.developmentMode;
        /** @type {?} */
        var isNgDevMode = isDevMode();
        /** @type {?} */
        var incorrectProduction = !isNgDevMode && isNgxsDevMode;
        /** @type {?} */
        var incorrectDevelopment = isNgDevMode && !isNgxsDevMode;
        /** @type {?} */
        var example = 'NgxsModule.forRoot(states, { developmentMode: !environment.production })';
        if (incorrectProduction) {
            console.warn('Angular is running in production mode but NGXS is still running in the development mode!\n', 'Please set developmentMode to false on the NgxsModule options when in production mode.\n', example);
        }
        else if (incorrectDevelopment) {
            console.warn('RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\n', example);
        }
    };
    ConfigValidator.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ConfigValidator.ctorParameters = function () { return [
        { type: NgxsConfig }
    ]; };
    return ConfigValidator;
}());
export { ConfigValidator };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ConfigValidator.prototype._config;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLXZhbGlkYXRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL2NvbmZpZy12YWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXRELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFeEM7SUFFRSx5QkFBb0IsT0FBbUI7UUFBbkIsWUFBTyxHQUFQLE9BQU8sQ0FBWTtJQUFHLENBQUM7Ozs7SUFFcEMsdUNBQWE7OztJQUFwQjtRQUNFLElBQUksbUJBQW1CLEVBQUUsRUFBRTtZQUN6QixPQUFPO1NBQ1I7O1lBRUssYUFBYSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsZUFBZTs7WUFDNUMsV0FBVyxHQUFHLFNBQVMsRUFBRTs7WUFDekIsbUJBQW1CLEdBQUcsQ0FBQyxXQUFXLElBQUksYUFBYTs7WUFDbkQsb0JBQW9CLEdBQUcsV0FBVyxJQUFJLENBQUMsYUFBYTs7WUFDcEQsT0FBTyxHQUFHLDBFQUEwRTtRQUUxRixJQUFJLG1CQUFtQixFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxJQUFJLENBQ1YsNEZBQTRGLEVBQzVGLDBGQUEwRixFQUMxRixPQUFPLENBQ1IsQ0FBQztTQUNIO2FBQU0sSUFBSSxvQkFBb0IsRUFBRTtZQUMvQixPQUFPLENBQUMsSUFBSSxDQUNWLDhHQUE4RyxFQUM5RyxPQUFPLENBQ1IsQ0FBQztTQUNIO0lBQ0gsQ0FBQzs7Z0JBM0JGLFVBQVU7Ozs7Z0JBRkYsVUFBVTs7SUE4Qm5CLHNCQUFDO0NBQUEsQUE1QkQsSUE0QkM7U0EzQlksZUFBZTs7Ozs7O0lBQ2Qsa0NBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgaXNEZXZNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBpc0FuZ3VsYXJJblRlc3RNb2RlIH0gZnJvbSAnLi4vdXRpbHMvYW5ndWxhcic7XHJcbmltcG9ydCB7IE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIENvbmZpZ1ZhbGlkYXRvciB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnKSB7fVxyXG5cclxuICBwdWJsaWMgdmVyaWZ5RGV2TW9kZSgpOiB2b2lkIHtcclxuICAgIGlmIChpc0FuZ3VsYXJJblRlc3RNb2RlKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzTmd4c0Rldk1vZGUgPSB0aGlzLl9jb25maWcuZGV2ZWxvcG1lbnRNb2RlO1xyXG4gICAgY29uc3QgaXNOZ0Rldk1vZGUgPSBpc0Rldk1vZGUoKTtcclxuICAgIGNvbnN0IGluY29ycmVjdFByb2R1Y3Rpb24gPSAhaXNOZ0Rldk1vZGUgJiYgaXNOZ3hzRGV2TW9kZTtcclxuICAgIGNvbnN0IGluY29ycmVjdERldmVsb3BtZW50ID0gaXNOZ0Rldk1vZGUgJiYgIWlzTmd4c0Rldk1vZGU7XHJcbiAgICBjb25zdCBleGFtcGxlID0gJ05neHNNb2R1bGUuZm9yUm9vdChzdGF0ZXMsIHsgZGV2ZWxvcG1lbnRNb2RlOiAhZW52aXJvbm1lbnQucHJvZHVjdGlvbiB9KSc7XHJcblxyXG4gICAgaWYgKGluY29ycmVjdFByb2R1Y3Rpb24pIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICdBbmd1bGFyIGlzIHJ1bm5pbmcgaW4gcHJvZHVjdGlvbiBtb2RlIGJ1dCBOR1hTIGlzIHN0aWxsIHJ1bm5pbmcgaW4gdGhlIGRldmVsb3BtZW50IG1vZGUhXFxuJyxcclxuICAgICAgICAnUGxlYXNlIHNldCBkZXZlbG9wbWVudE1vZGUgdG8gZmFsc2Ugb24gdGhlIE5neHNNb2R1bGUgb3B0aW9ucyB3aGVuIGluIHByb2R1Y3Rpb24gbW9kZS5cXG4nLFxyXG4gICAgICAgIGV4YW1wbGVcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSBpZiAoaW5jb3JyZWN0RGV2ZWxvcG1lbnQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICdSRUNPTU1FTkRBVElPTjogU2V0IGRldmVsb3BtZW50TW9kZSB0byB0cnVlIG9uIHRoZSBOZ3hzTW9kdWxlIHdoZW4gQW5ndWxhciBpcyBydW5uaW5nIGluIGRldmVsb3BtZW50IG1vZGUuXFxuJyxcclxuICAgICAgICBleGFtcGxlXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==