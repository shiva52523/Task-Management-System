/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Injector, Optional, SkipSelf } from '@angular/core';
import { forkJoin, from, Observable, of, throwError } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { InternalStateOperations } from '../internal/state-operations';
/**
 * State factory class
 * @ignore
 */
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _internalStateOperations) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._internalStateOperations = _internalStateOperations;
        this._connected = false;
        this._states = [];
        this._statesByName = {};
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "statesByName", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "stateTreeRef", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._internalStateOperations.getRootStateOperations().getState();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    StateFactory.cloneDefaults = /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    function (defaults) {
        /** @type {?} */
        var value = {};
        if (Array.isArray(defaults)) {
            value = tslib_1.__spread(defaults);
        }
        else if (isObject(defaults)) {
            value = tslib_1.__assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    };
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.checkStatesAreValid = /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        stateClasses.forEach(StoreValidators.getValidStateMeta);
    };
    /**
     * Add a new state to the global defs.
     */
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.add = /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_1, _a;
        StateFactory.checkStatesAreValid(stateClasses);
        var newStates = this.addToStatesMap(stateClasses).newStates;
        if (!newStates.length)
            return [];
        /** @type {?} */
        var stateGraph = buildGraph(newStates);
        /** @type {?} */
        var sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        var depths = findFullParentPath(stateGraph);
        /** @type {?} */
        var nameGraph = nameToState(newStates);
        /** @type {?} */
        var bootstrappedStores = [];
        try {
            for (var sortedStates_1 = tslib_1.__values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name_1 = sortedStates_1_1.value;
                /** @type {?} */
                var stateClass = nameGraph[name_1];
                /** @type {?} */
                var depth = depths[name_1];
                /** @type {?} */
                var meta = (/** @type {?} */ (stateClass[META_KEY]));
                this.addRuntimeInfoToMeta(meta, depth);
                /** @type {?} */
                var stateMap = {
                    name: name_1,
                    depth: depth,
                    actions: meta.actions,
                    instance: this._injector.get(stateClass),
                    defaults: StateFactory.cloneDefaults(meta.defaults)
                };
                // ensure our store hasn't already been added
                // but don't throw since it could be lazy
                // loaded from different paths
                if (!this.hasBeenMountedAndBootstrapped(name_1, depth)) {
                    bootstrappedStores.push(stateMap);
                }
                this.states.push(stateMap);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return bootstrappedStores;
    };
    /**
     * Add a set of states to the store and return the defaults
     */
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addAndReturnDefaults = /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        /** @type {?} */
        var classes = stateClasses || [];
        /** @type {?} */
        var states = this.add(classes);
        /** @type {?} */
        var defaults = states.reduce((/**
         * @param {?} result
         * @param {?} meta
         * @return {?}
         */
        function (result, meta) { return setValue(result, meta.depth, meta.defaults); }), {});
        return { defaults: defaults, states: states };
    };
    /**
     * Bind the actions to the handlers
     */
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    StateFactory.prototype.connectActionHandlers = /**
     * Bind the actions to the handlers
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._connected)
            return;
        this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; })), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var action = _a.action;
            return _this.invokeActions(_this._actions, (/** @type {?} */ (action))).pipe(map((/**
             * @return {?}
             */
            function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); })), defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                return of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error })));
            })));
        })))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return _this._actionResults.next(ctx); }));
        this._connected = true;
    };
    /**
     * Invoke actions on the states.
     */
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    StateFactory.prototype.invokeActions = /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    function (actions$, action) {
        var e_2, _a, e_3, _b;
        /** @type {?} */
        var results = [];
        try {
            for (var _c = tslib_1.__values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metadata = _d.value;
                /** @type {?} */
                var type = (/** @type {?} */ (getActionTypeFromInstance(action)));
                /** @type {?} */
                var actionMetas = metadata.actions[type];
                if (actionMetas) {
                    try {
                        for (var actionMetas_1 = tslib_1.__values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                            var actionMeta = actionMetas_1_1.value;
                            /** @type {?} */
                            var stateContext = this._stateContextFactory.createStateContext(metadata);
                            try {
                                /** @type {?} */
                                var result = metadata.instance[actionMeta.fn](stateContext, action);
                                if (result instanceof Promise) {
                                    result = from(result);
                                }
                                if (result instanceof Observable) {
                                    result = result.pipe(actionMeta.options.cancelUncompleted
                                        ? // todo: ofActionDispatched should be used with action class
                                            takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action)))))
                                        : map((/**
                                         * @param {?} r
                                         * @return {?}
                                         */
                                        function (r) { return r; }))); // map acts like a noop
                                }
                                else {
                                    result = of({}).pipe(shareReplay());
                                }
                                results.push(result);
                            }
                            catch (e) {
                                results.push(throwError(e));
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    };
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addToStatesMap = /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_4, _a;
        /** @type {?} */
        var newStates = [];
        /** @type {?} */
        var statesMap = this.statesByName;
        try {
            for (var stateClasses_1 = tslib_1.__values(stateClasses), stateClasses_1_1 = stateClasses_1.next(); !stateClasses_1_1.done; stateClasses_1_1 = stateClasses_1.next()) {
                var stateClass = stateClasses_1_1.value;
                /** @type {?} */
                var stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
                /** @type {?} */
                var unmountedState = !statesMap[stateName];
                if (unmountedState) {
                    newStates.push(stateClass);
                    statesMap[stateName] = stateClass;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (stateClasses_1_1 && !stateClasses_1_1.done && (_a = stateClasses_1.return)) _a.call(stateClasses_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return { newStates: newStates };
    };
    /**
     * @private
     * @param {?} meta
     * @param {?} depth
     * @return {?}
     */
    StateFactory.prototype.addRuntimeInfoToMeta = /**
     * @private
     * @param {?} meta
     * @param {?} depth
     * @return {?}
     */
    function (meta, depth) {
        meta.path = depth;
        meta.selectFromAppState = propGetter(depth.split('.'), this._config);
    };
    /**
     * @description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @param name
     * @param path
     */
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    StateFactory.prototype.hasBeenMountedAndBootstrapped = /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    function (name, path) {
        /** @type {?} */
        var valueIsBootstrapped = getValue(this.stateTreeRef, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrapped;
    };
    StateFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateFactory.ctorParameters = function () { return [
        { type: Injector },
        { type: NgxsConfig },
        { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: StateContextFactory },
        { type: InternalStateOperations }
    ]; };
    return StateFactory;
}());
export { StateFactory };
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._internalStateOperations;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFDTCxVQUFVLEVBQ1YsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLEVBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNsRCxPQUFPLEVBQ0wsVUFBVSxFQUNWLGtCQUFrQixFQUNsQixRQUFRLEVBR1IsV0FBVyxFQUVYLFVBQVUsRUFLVixlQUFlLEVBQ2hCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDNUQsT0FBTyxFQUErQixlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDNUQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOEJBQThCLENBQUM7Ozs7O0FBTXZFO0lBTUUsc0JBQ1UsU0FB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R0FBWSxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxTQUFTO1FBQ3BGLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxtQkFBbUIsQ0FBQztJQUN4RCxDQUFDOztnQkE3TUYsVUFBVTs7OztnQkF4Q1UsUUFBUTtnQkFZVixVQUFVO2dCQXVDRCxZQUFZLHVCQUZuQyxRQUFRLFlBQ1IsUUFBUTtnQkFwQnlCLGVBQWU7Z0JBQzVDLCtCQUErQjtnQkFDL0IsbUJBQW1CO2dCQUVuQix1QkFBdUI7O0lBb05oQyxtQkFBQztDQUFBLEFBOU1ELElBOE1DO1NBN01ZLFlBQVk7Ozs7OztJQUN2QixrQ0FBMkI7Ozs7O0lBQzNCLCtCQUFvQzs7Ozs7SUFDcEMscUNBQXlDOzs7OztJQUd2QyxpQ0FBMkI7Ozs7O0lBQzNCLCtCQUEyQjs7Ozs7SUFDM0Isc0NBRW9DOzs7OztJQUNwQyxnQ0FBaUM7Ozs7O0lBQ2pDLHNDQUF1RDs7Ozs7SUFDdkQsNENBQWlEOzs7OztJQUNqRCxnREFBeUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciwgT3B0aW9uYWwsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGZvcmtKb2luLCBmcm9tLCBPYnNlcnZhYmxlLCBvZiwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge1xyXG4gIGNhdGNoRXJyb3IsXHJcbiAgZGVmYXVsdElmRW1wdHksXHJcbiAgZmlsdGVyLFxyXG4gIG1hcCxcclxuICBtZXJnZU1hcCxcclxuICBzaGFyZVJlcGxheSxcclxuICB0YWtlVW50aWxcclxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xyXG5pbXBvcnQge1xyXG4gIGJ1aWxkR3JhcGgsXHJcbiAgZmluZEZ1bGxQYXJlbnRQYXRoLFxyXG4gIGlzT2JqZWN0LFxyXG4gIE1hcHBlZFN0b3JlLFxyXG4gIE1ldGFEYXRhTW9kZWwsXHJcbiAgbmFtZVRvU3RhdGUsXHJcbiAgT2JqZWN0S2V5TWFwLFxyXG4gIHByb3BHZXR0ZXIsXHJcbiAgU3RhdGVDbGFzcyxcclxuICBTdGF0ZUtleUdyYXBoLFxyXG4gIFN0YXRlc0FuZERlZmF1bHRzLFxyXG4gIFN0YXRlc0J5TmFtZSxcclxuICB0b3BvbG9naWNhbFNvcnRcclxufSBmcm9tICcuL2ludGVybmFscyc7XHJcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIGdldFZhbHVlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgb2ZBY3Rpb25EaXNwYXRjaGVkIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29mLWFjdGlvbic7XHJcbmltcG9ydCB7IEFjdGlvbkNvbnRleHQsIEFjdGlvblN0YXR1cywgSW50ZXJuYWxBY3Rpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1jb250ZXh0LWZhY3RvcnknO1xyXG5pbXBvcnQgeyBTdG9yZVZhbGlkYXRvcnMgfSBmcm9tICcuLi91dGlscy9zdG9yZS12YWxpZGF0b3JzJztcclxuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuLi9pbnRlcm5hbC9zdGF0ZS1vcGVyYXRpb25zJztcclxuXHJcbi8qKlxyXG4gKiBTdGF0ZSBmYWN0b3J5IGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFN0YXRlRmFjdG9yeSB7XHJcbiAgcHJpdmF0ZSBfY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcbiAgcHJpdmF0ZSBfc3RhdGVzQnlOYW1lOiBTdGF0ZXNCeU5hbWUgPSB7fTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXHJcbiAgICBwcml2YXRlIF9jb25maWc6IE5neHNDb25maWcsXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgQFNraXBTZWxmKClcclxuICAgIHByaXZhdGUgX3BhcmVudEZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcclxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcclxuICAgIHByaXZhdGUgX2FjdGlvblJlc3VsdHM6IEludGVybmFsRGlzcGF0Y2hlZEFjdGlvblJlc3VsdHMsXHJcbiAgICBwcml2YXRlIF9zdGF0ZUNvbnRleHRGYWN0b3J5OiBTdGF0ZUNvbnRleHRGYWN0b3J5LFxyXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zXHJcbiAgKSB7fVxyXG5cclxuICBwdWJsaWMgZ2V0IHN0YXRlcygpOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXMgOiB0aGlzLl9zdGF0ZXM7XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgZ2V0IHN0YXRlc0J5TmFtZSgpOiBTdGF0ZXNCeU5hbWUge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlc0J5TmFtZSA6IHRoaXMuX3N0YXRlc0J5TmFtZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IHN0YXRlVHJlZVJlZigpOiBPYmplY3RLZXlNYXA8YW55PiB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpLmdldFN0YXRlKCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXRpYyBjbG9uZURlZmF1bHRzKGRlZmF1bHRzOiBhbnkpOiBhbnkge1xyXG4gICAgbGV0IHZhbHVlID0ge307XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XHJcbiAgICAgIHZhbHVlID0gWy4uLmRlZmF1bHRzXTtcclxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVmYXVsdHMpKSB7XHJcbiAgICAgIHZhbHVlID0geyAuLi5kZWZhdWx0cyB9O1xyXG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhbHVlID0ge307XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgc3RhdGljIGNoZWNrU3RhdGVzQXJlVmFsaWQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiB2b2lkIHtcclxuICAgIHN0YXRlQ2xhc3Nlcy5mb3JFYWNoKFN0b3JlVmFsaWRhdG9ycy5nZXRWYWxpZFN0YXRlTWV0YSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBuZXcgc3RhdGUgdG8gdGhlIGdsb2JhbCBkZWZzLlxyXG4gICAqL1xyXG4gIGFkZChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NbXSk6IE1hcHBlZFN0b3JlW10ge1xyXG4gICAgU3RhdGVGYWN0b3J5LmNoZWNrU3RhdGVzQXJlVmFsaWQoc3RhdGVDbGFzc2VzKTtcclxuICAgIGNvbnN0IHsgbmV3U3RhdGVzIH0gPSB0aGlzLmFkZFRvU3RhdGVzTWFwKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBpZiAoIW5ld1N0YXRlcy5sZW5ndGgpIHJldHVybiBbXTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZUdyYXBoOiBTdGF0ZUtleUdyYXBoID0gYnVpbGRHcmFwaChuZXdTdGF0ZXMpO1xyXG4gICAgY29uc3Qgc29ydGVkU3RhdGVzOiBzdHJpbmdbXSA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcclxuICAgIGNvbnN0IGRlcHRoczogT2JqZWN0S2V5TWFwPHN0cmluZz4gPSBmaW5kRnVsbFBhcmVudFBhdGgoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBuYW1lR3JhcGg6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiA9IG5hbWVUb1N0YXRlKG5ld1N0YXRlcyk7XHJcbiAgICBjb25zdCBib290c3RyYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3MgPSBuYW1lR3JhcGhbbmFtZV07XHJcbiAgICAgIGNvbnN0IGRlcHRoOiBzdHJpbmcgPSBkZXB0aHNbbmFtZV07XHJcbiAgICAgIGNvbnN0IG1ldGE6IE1ldGFEYXRhTW9kZWwgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XHJcblxyXG4gICAgICB0aGlzLmFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGEsIGRlcHRoKTtcclxuXHJcbiAgICAgIGNvbnN0IHN0YXRlTWFwOiBNYXBwZWRTdG9yZSA9IHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGRlcHRoLFxyXG4gICAgICAgIGFjdGlvbnM6IG1ldGEuYWN0aW9ucyxcclxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxyXG4gICAgICAgIGRlZmF1bHRzOiBTdGF0ZUZhY3RvcnkuY2xvbmVEZWZhdWx0cyhtZXRhLmRlZmF1bHRzKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gZW5zdXJlIG91ciBzdG9yZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGFkZGVkXHJcbiAgICAgIC8vIGJ1dCBkb24ndCB0aHJvdyBzaW5jZSBpdCBjb3VsZCBiZSBsYXp5XHJcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xyXG4gICAgICBpZiAoIXRoaXMuaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZSwgZGVwdGgpKSB7XHJcbiAgICAgICAgYm9vdHN0cmFwcGVkU3RvcmVzLnB1c2goc3RhdGVNYXApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlTWFwKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYm9vdHN0cmFwcGVkU3RvcmVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsdHNcclxuICAgKi9cclxuICBhZGRBbmRSZXR1cm5EZWZhdWx0cyhzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NbXSk6IFN0YXRlc0FuZERlZmF1bHRzIHtcclxuICAgIGNvbnN0IGNsYXNzZXM6IFN0YXRlQ2xhc3NbXSA9IHN0YXRlQ2xhc3NlcyB8fCBbXTtcclxuXHJcbiAgICBjb25zdCBzdGF0ZXM6IE1hcHBlZFN0b3JlW10gPSB0aGlzLmFkZChjbGFzc2VzKTtcclxuICAgIGNvbnN0IGRlZmF1bHRzID0gc3RhdGVzLnJlZHVjZShcclxuICAgICAgKHJlc3VsdDogYW55LCBtZXRhOiBNYXBwZWRTdG9yZSkgPT4gc2V0VmFsdWUocmVzdWx0LCBtZXRhLmRlcHRoLCBtZXRhLmRlZmF1bHRzKSxcclxuICAgICAge31cclxuICAgICk7XHJcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIHRoZSBhY3Rpb25zIHRvIHRoZSBoYW5kbGVyc1xyXG4gICAqL1xyXG4gIGNvbm5lY3RBY3Rpb25IYW5kbGVycygpIHtcclxuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHJldHVybjtcclxuICAgIHRoaXMuX2FjdGlvbnNcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcclxuICAgICAgICBtZXJnZU1hcCgoeyBhY3Rpb24gfSkgPT5cclxuICAgICAgICAgIHRoaXMuaW52b2tlQWN0aW9ucyh0aGlzLl9hY3Rpb25zLCBhY3Rpb24hKS5waXBlKFxyXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXHJcbiAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5DYW5jZWxlZCB9KSxcclxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PlxyXG4gICAgICAgICAgICAgIG9mKDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5FcnJvcmVkLCBlcnJvciB9KVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgKVxyXG4gICAgICApXHJcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcclxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnZva2UgYWN0aW9ucyBvbiB0aGUgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGludm9rZUFjdGlvbnMoYWN0aW9ucyQ6IEludGVybmFsQWN0aW9ucywgYWN0aW9uOiBhbnkpIHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XHJcbiAgICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbikhO1xyXG4gICAgICBjb25zdCBhY3Rpb25NZXRhcyA9IG1ldGFkYXRhLmFjdGlvbnNbdHlwZV07XHJcblxyXG4gICAgICBpZiAoYWN0aW9uTWV0YXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk1ldGEgb2YgYWN0aW9uTWV0YXMpIHtcclxuICAgICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuX3N0YXRlQ29udGV4dEZhY3RvcnkuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YS5pbnN0YW5jZVthY3Rpb25NZXRhLmZuXShzdGF0ZUNvbnRleHQsIGFjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZyb20ocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcclxuICAgICAgICAgICAgICAgIGFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZFxyXG4gICAgICAgICAgICAgICAgICA/IC8vIHRvZG86IG9mQWN0aW9uRGlzcGF0Y2hlZCBzaG91bGQgYmUgdXNlZCB3aXRoIGFjdGlvbiBjbGFzc1xyXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChhY3Rpb25zJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24gYXMgYW55KSkpXHJcbiAgICAgICAgICAgICAgICAgIDogbWFwKHIgPT4gcilcclxuICAgICAgICAgICAgICApOyAvLyBtYXAgYWN0cyBsaWtlIGEgbm9vcFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlc3VsdCA9IG9mKHt9KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgcmVzdWx0cy5wdXNoKG9mKHt9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhZGRUb1N0YXRlc01hcChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NbXSk6IHsgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzW10gfSB7XHJcbiAgICBjb25zdCBuZXdTdGF0ZXM6IFN0YXRlQ2xhc3NbXSA9IFtdO1xyXG4gICAgY29uc3Qgc3RhdGVzTWFwOiBTdGF0ZXNCeU5hbWUgPSB0aGlzLnN0YXRlc0J5TmFtZTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IHN0YXRlQ2xhc3Mgb2Ygc3RhdGVDbGFzc2VzKSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlTmFtZTogc3RyaW5nID0gU3RvcmVWYWxpZGF0b3JzLmNoZWNrU3RhdGVOYW1lSXNVbmlxdWUoc3RhdGVDbGFzcywgc3RhdGVzTWFwKTtcclxuICAgICAgY29uc3QgdW5tb3VudGVkU3RhdGU6IGJvb2xlYW4gPSAhc3RhdGVzTWFwW3N0YXRlTmFtZV07XHJcbiAgICAgIGlmICh1bm1vdW50ZWRTdGF0ZSkge1xyXG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKHN0YXRlQ2xhc3MpO1xyXG4gICAgICAgIHN0YXRlc01hcFtzdGF0ZU5hbWVdID0gc3RhdGVDbGFzcztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7IG5ld1N0YXRlcyB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhOiBNZXRhRGF0YU1vZGVsLCBkZXB0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBtZXRhLnBhdGggPSBkZXB0aDtcclxuICAgIG1ldGEuc2VsZWN0RnJvbUFwcFN0YXRlID0gcHJvcEdldHRlcihkZXB0aC5zcGxpdCgnLicpLCB0aGlzLl9jb25maWcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQGRlc2NyaXB0aW9uXHJcbiAgICogdGhlIG1ldGhvZCBjaGVja3MgaWYgdGhlIHN0YXRlIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIHRyZWVcclxuICAgKiBhbmQgY29tcGxldGVkIHRoZSBsaWZlIGN5Y2xlXHJcbiAgICogQHBhcmFtIG5hbWVcclxuICAgKiBAcGFyYW0gcGF0aFxyXG4gICAqL1xyXG4gIHByaXZhdGUgaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHZhbHVlSXNCb290c3RyYXBwZWQ6IGJvb2xlYW4gPSBnZXRWYWx1ZSh0aGlzLnN0YXRlVHJlZVJlZiwgcGF0aCkgIT09IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlc0J5TmFtZVtuYW1lXSAmJiB2YWx1ZUlzQm9vdHN0cmFwcGVkO1xyXG4gIH1cclxufVxyXG4iXX0=