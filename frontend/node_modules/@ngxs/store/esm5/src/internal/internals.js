/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { META_KEY, META_OPTIONS_KEY, SELECTOR_META_KEY } from '../symbols';
/**
 * @record
 * @template T
 */
export function ObjectKeyMap() { }
/**
 * @record
 * @template T, U
 */
export function StateClass() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
    /* Skipping unhandled member: new (...args: any[]): T;*/
}
/**
 * @record
 */
export function ActionHandlerMetaData() { }
if (false) {
    /** @type {?} */
    ActionHandlerMetaData.prototype.fn;
    /** @type {?} */
    ActionHandlerMetaData.prototype.options;
    /** @type {?} */
    ActionHandlerMetaData.prototype.type;
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.selectFromAppState;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
    /** @type {?} */
    MetaDataModel.prototype.instance;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectFromAppState;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.depth;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    var copyOfPaths = tslib_1.__spread(paths);
    return (/**
     * @param {?} obj
     * @return {?}
     */
    function (obj) { return copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    function (acc, part) { return acc && acc[part]; }), obj); });
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    var segments = paths;
    /** @type {?} */
    var seg = 'store.' + segments[0];
    /** @type {?} */
    var i = 0;
    /** @type {?} */
    var l = segments.length;
    /** @type {?} */
    var expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    var fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    var findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    function (stateClass) {
        /** @type {?} */
        var meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        function (g) { return g === stateClass; }));
        if (!meta) {
            throw new Error("Child state not found: " + stateClass + ". \r\nYou may have forgotten to add states to module");
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    function (result, stateClass) {
        var _a = (/** @type {?} */ (stateClass[META_KEY])), name = _a.name, children = _a.children;
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    function (result, stateClass) {
        /** @type {?} */
        var meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj) {
    if (newObj === void 0) { newObj = {}; }
    /** @type {?} */
    var visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    function (child, keyToFind) {
        for (var key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                var parent_1 = visit(child, key);
                return parent_1 !== null ? parent_1 + "." + key : key;
            }
        }
        return null;
    });
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            var parent_2 = visit(obj, key);
            newObj[key] = parent_2 ? parent_2 + "." + key : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    var sorted = [];
    /** @type {?} */
    var visited = {};
    /** @type {?} */
    var visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    function (name, ancestors) {
        if (ancestors === void 0) { ancestors = []; }
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        function (dep) {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    function (k) { return visit(k); }));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
/** @type {?} */
var DOLLAR_CHAR_CODE = 36;
/**
 * If `foo$` => make it just `foo`
 *
 * @ignore
 * @param {?} name
 * @return {?}
 */
export function removeDollarAtTheEnd(name) {
    /** @type {?} */
    var lastCharIndex = name.length - 1;
    /** @type {?} */
    var dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUVMLFFBQVEsRUFDUixnQkFBZ0IsRUFFaEIsaUJBQWlCLEVBRWxCLE1BQU0sWUFBWSxDQUFDOzs7OztBQUdwQixrQ0FFQzs7Ozs7QUFHRCxnQ0FLQzs7Ozs7Ozs7Ozs7QUFLRCwyQ0FJQzs7O0lBSEMsbUNBQW9COztJQUNwQix3Q0FBdUI7O0lBQ3ZCLHFDQUFhOzs7Ozs7QUFHZixxQ0FNQzs7Ozs7SUFMQyxxREFBYzs7Ozs7SUFFZCx3REFBb0I7Ozs7O0lBRXBCLDREQUFpRDs7Ozs7QUFHbkQsbUNBUUM7OztJQVBDLDZCQUFvQjs7SUFDcEIsZ0NBQStDOztJQUMvQyxpQ0FBYzs7SUFDZCw2QkFBb0I7O0lBQ3BCLDJDQUEyQzs7SUFDM0MsaUNBQXdCOztJQUN4QixpQ0FBYzs7Ozs7QUFLaEIsMkNBS0M7OztJQUpDLG1EQUEyQzs7SUFDM0MsMkNBQTRCOztJQUM1QiwrQ0FBb0I7O0lBQ3BCLDZDQUE0Qjs7Ozs7QUFHOUIsaUNBTUM7OztJQUxDLDJCQUFhOztJQUNiLDhCQUErQzs7SUFDL0MsK0JBQWM7O0lBQ2QsK0JBQWM7O0lBQ2QsNEJBQWM7Ozs7O0FBR2hCLHVDQUdDOzs7SUFGQyxxQ0FBYzs7SUFDZCxtQ0FBc0I7Ozs7Ozs7OztBQVF4QixNQUFNLFVBQVUsbUJBQW1CLENBQUMsTUFBa0I7SUFDcEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7O1lBQzlCLGVBQWUsR0FBa0I7WUFDckMsSUFBSSxFQUFFLElBQUk7WUFDVixPQUFPLEVBQUUsRUFBRTtZQUNYLFFBQVEsRUFBRSxFQUFFO1lBQ1osSUFBSSxFQUFFLElBQUk7WUFDVixrQkFBa0IsRUFBRSxJQUFJO1lBQ3hCLFFBQVEsRUFBRSxFQUFFO1lB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QUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUM5RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBBY3Rpb25PcHRpb25zLFxyXG4gIE1FVEFfS0VZLFxyXG4gIE1FVEFfT1BUSU9OU19LRVksXHJcbiAgTmd4c0NvbmZpZyxcclxuICBTRUxFQ1RPUl9NRVRBX0tFWSxcclxuICBTdG9yZU9wdGlvbnNcclxufSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPYmplY3RLZXlNYXA8VD4ge1xyXG4gIFtrZXk6IHN0cmluZ106IFQ7XHJcbn1cclxuXHJcbi8vIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzNjc0Mzg5XHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDbGFzczxUID0gYW55LCBVID0gYW55PiB7XHJcbiAgW01FVEFfS0VZXT86IE1ldGFEYXRhTW9kZWw7XHJcbiAgW01FVEFfT1BUSU9OU19LRVldPzogU3RvcmVPcHRpb25zPFU+O1xyXG5cclxuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU3RhdGVLZXlHcmFwaCA9IE9iamVjdEtleU1hcDxzdHJpbmdbXT47XHJcbmV4cG9ydCB0eXBlIFN0YXRlc0J5TmFtZSA9IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uSGFuZGxlck1ldGFEYXRhIHtcclxuICBmbjogc3RyaW5nIHwgc3ltYm9sO1xyXG4gIG9wdGlvbnM6IEFjdGlvbk9wdGlvbnM7XHJcbiAgdHlwZTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlT3BlcmF0aW9uczxUPiB7XHJcbiAgZ2V0U3RhdGUoKTogVDtcclxuXHJcbiAgc2V0U3RhdGUodmFsOiBUKTogVDtcclxuXHJcbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFEYXRhTW9kZWwge1xyXG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XHJcbiAgYWN0aW9uczogT2JqZWN0S2V5TWFwPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHBhdGg6IHN0cmluZyB8IG51bGw7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGUgfCBudWxsO1xyXG4gIGNoaWxkcmVuPzogU3RhdGVDbGFzc1tdO1xyXG4gIGluc3RhbmNlOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNlbGVjdEZyb21TdGF0ZSA9IChzdGF0ZTogYW55KSA9PiBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XHJcbiAgc2VsZWN0RnJvbUFwcFN0YXRlOiBTZWxlY3RGcm9tU3RhdGUgfCBudWxsO1xyXG4gIG9yaWdpbmFsRm46IEZ1bmN0aW9uIHwgbnVsbDtcclxuICBjb250YWluZXJDbGFzczogYW55O1xyXG4gIHNlbGVjdG9yTmFtZTogc3RyaW5nIHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNYXBwZWRTdG9yZSB7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBpbnN0YW5jZTogYW55O1xyXG4gIGRlcHRoOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVzQW5kRGVmYXVsdHMge1xyXG4gIGRlZmF1bHRzOiBhbnk7XHJcbiAgc3RhdGVzOiBNYXBwZWRTdG9yZVtdO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgY2xhc3MgYW5kIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTdG9yZU1ldGFkYXRhKHRhcmdldDogU3RhdGVDbGFzcyk6IE1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KE1FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBuYW1lOiBudWxsLFxyXG4gICAgICBhY3Rpb25zOiB7fSxcclxuICAgICAgZGVmYXVsdHM6IHt9LFxyXG4gICAgICBwYXRoOiBudWxsLFxyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgaW5zdGFuY2U6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcbiAgcmV0dXJuIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHN0YXRlIGNsYXNzIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzKTogTWV0YURhdGFNb2RlbCB7XHJcbiAgcmV0dXJuIHRhcmdldFtNRVRBX0tFWV0hO1xyXG59XHJcblxyXG4vKipcclxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgc2VsZWN0b3IgYW5kIHJldHVybnMgaXQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhKHRhcmdldDogRnVuY3Rpb24pOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KFNFTEVDVE9SX01FVEFfS0VZKSkge1xyXG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XHJcbiAgICAgIHNlbGVjdEZyb21BcHBTdGF0ZTogbnVsbCxcclxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcclxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXHJcbiAgICAgIHNlbGVjdG9yTmFtZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBTRUxFQ1RPUl9NRVRBX0tFWSwgeyB2YWx1ZTogZGVmYXVsdE1ldGFkYXRhIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0OiBhbnkpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIHJldHVybiB0YXJnZXRbU0VMRUNUT1JfTUVUQV9LRVldO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcclxuICpcclxuICogICAgZ2V0VmFsdWUoeyBmb286IGJhcjogW10gfSwgJ2Zvby5iYXInKSAvLz0+IFtdXHJcbiAqXHJcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGFzIGZhc3QgYXMgdGhlIGBmYXN0UHJvcEdldHRlcmAgYnV0IGlzIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBjb21wbGlhbnQuXHJcbiAqIFNlZSBwZXJmIGhpdDogaHR0cHM6Ly9qc3BlcmYuY29tL2Zhc3QtdmFsdWUtZ2V0dGVyLWdpdmVuLXBhdGgvMVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XHJcbiAgY29uc3QgY29weU9mUGF0aHMgPSBbLi4ucGF0aHNdO1xyXG4gIHJldHVybiBvYmogPT4gY29weU9mUGF0aHMucmVkdWNlKChhY2M6IGFueSwgcGFydDogc3RyaW5nKSA9PiBhY2MgJiYgYWNjW3BhcnRdLCBvYmopO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbjpcclxuICogLSBwbHVjayAoT2JzZXJ2YWJsZSBvcGVyYXRvcilcclxuICogLSBtZW1vaXplXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIGZhc3RQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XHJcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRocztcclxuICBsZXQgc2VnID0gJ3N0b3JlLicgKyBzZWdtZW50c1swXTtcclxuICBsZXQgaSA9IDA7XHJcbiAgY29uc3QgbCA9IHNlZ21lbnRzLmxlbmd0aDtcclxuXHJcbiAgbGV0IGV4cHIgPSBzZWc7XHJcbiAgd2hpbGUgKCsraSA8IGwpIHtcclxuICAgIGV4cHIgPSBleHByICsgJyAmJiAnICsgKHNlZyA9IHNlZyArICcuJyArIHNlZ21lbnRzW2ldKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZuID0gbmV3IEZ1bmN0aW9uKCdzdG9yZScsICdyZXR1cm4gJyArIGV4cHIgKyAnOycpO1xyXG5cclxuICByZXR1cm4gPCh4OiBhbnkpID0+IGFueT5mbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJvcEdldHRlcihwYXRoczogc3RyaW5nW10sIGNvbmZpZzogTmd4c0NvbmZpZykge1xyXG4gIGlmIChjb25maWcgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkuc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5KSB7XHJcbiAgICByZXR1cm4gY29tcGxpYW50UHJvcEdldHRlcihwYXRocyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYXN0UHJvcEdldHRlcihwYXRocyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RhdGVzLCBpdCB3aWxsIHJldHVybiBhIG9iamVjdCBncmFwaC4gRXhhbXBsZTpcclxuICogICAgY29uc3Qgc3RhdGVzID0gW1xyXG4gKiAgICAgIENhcnQsXHJcbiAqICAgICAgQ2FydFNhdmVkLFxyXG4gKiAgICAgIENhcnRTYXZlZEl0ZW1zXHJcbiAqICAgIF1cclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHcmFwaChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NbXSk6IFN0YXRlS2V5R3JhcGgge1xyXG4gIGNvbnN0IGZpbmROYW1lID0gKHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3MpID0+IHtcclxuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzZXMuZmluZChnID0+IGcgPT09IHN0YXRlQ2xhc3MpO1xyXG4gICAgaWYgKCFtZXRhKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2hpbGQgc3RhdGUgbm90IGZvdW5kOiAke3N0YXRlQ2xhc3N9LiBcXHJcXG5Zb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGFkZCBzdGF0ZXMgdG8gbW9kdWxlYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtZXRhW01FVEFfS0VZXSEubmFtZSE7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHN0YXRlQ2xhc3Nlcy5yZWR1Y2U8U3RhdGVLZXlHcmFwaD4oXHJcbiAgICAocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICAgIGNvbnN0IHsgbmFtZSwgY2hpbGRyZW4gfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcclxuICAgICAgcmVzdWx0W25hbWUhXSA9IChjaGlsZHJlbiB8fCBbXSkubWFwKGZpbmROYW1lKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICB7fVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHN0YXRlcyBhcnJheSwgcmV0dXJucyBvYmplY3QgZ3JhcGhcclxuICogcmV0dXJuaW5nIHRoZSBuYW1lIGFuZCBzdGF0ZSBtZXRhZGF0YS4gRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiB7IG1ldGFkYXRhIH1cclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBuYW1lVG9TdGF0ZShzdGF0ZXM6IFN0YXRlQ2xhc3NbXSk6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiB7XHJcbiAgcmV0dXJuIHN0YXRlcy5yZWR1Y2U8T2JqZWN0S2V5TWFwPFN0YXRlQ2xhc3M+PihcclxuICAgIChyZXN1bHQ6IE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPiwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xyXG4gICAgICByZXN1bHRbbWV0YS5uYW1lIV0gPSBzdGF0ZUNsYXNzO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIHt9XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgb2JqZWN0IHJlbGF0aW9uc2hpcCBncmFwaCB3aWxsIHJldHVybiB0aGUgZnVsbCBwYXRoXHJcbiAqIGZvciB0aGUgY2hpbGQgaXRlbXMuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHIgPSB7XHJcbiAqICAgIGNhcnQ6ICdjYXJ0JyxcclxuICogICAgc2F2ZWQ6ICdjYXJ0LnNhdmVkJyxcclxuICogICAgaXRlbXM6ICdjYXJ0LnNhdmVkLml0ZW1zJ1xyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGdWxsUGFyZW50UGF0aChcclxuICBvYmo6IFN0YXRlS2V5R3JhcGgsXHJcbiAgbmV3T2JqOiBPYmplY3RLZXlNYXA8c3RyaW5nPiA9IHt9XHJcbik6IE9iamVjdEtleU1hcDxzdHJpbmc+IHtcclxuICBjb25zdCB2aXNpdCA9IChjaGlsZDogU3RhdGVLZXlHcmFwaCwga2V5VG9GaW5kOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XHJcbiAgICAgIGlmIChjaGlsZC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGNoaWxkW2tleV0uaW5kZXhPZihrZXlUb0ZpbmQpID49IDApIHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB2aXNpdChjaGlsZCwga2V5KTtcclxuICAgICAgICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG5cclxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICBjb25zdCBwYXJlbnQgPSB2aXNpdChvYmosIGtleSk7XHJcbiAgICAgIG5ld09ialtrZXldID0gcGFyZW50ID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG5ld09iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgb2JqZWN0IGdyYXBoLCBpdCB3aWxsIHJldHVybiB0aGUgaXRlbXMgdG9wb2xvZ2ljYWxseSBzb3J0ZWQgRXhhbXBsZTpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogd291bGQgcmV0dXJuOlxyXG4gKlxyXG4gKiAgY29uc3QgcmVzdWx0cyA9IFtcclxuICogICAgJ2l0ZW1zJyxcclxuICogICAgJ3NhdmVkJyxcclxuICogICAgJ2NhcnQnXHJcbiAqICBdO1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdG9wb2xvZ2ljYWxTb3J0KGdyYXBoOiBTdGF0ZUtleUdyYXBoKTogc3RyaW5nW10ge1xyXG4gIGNvbnN0IHNvcnRlZDogc3RyaW5nW10gPSBbXTtcclxuICBjb25zdCB2aXNpdGVkOiBPYmplY3RLZXlNYXA8Ym9vbGVhbj4gPSB7fTtcclxuXHJcbiAgY29uc3QgdmlzaXQgPSAobmFtZTogc3RyaW5nLCBhbmNlc3RvcnM6IHN0cmluZ1tdID0gW10pID0+IHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShhbmNlc3RvcnMpKSB7XHJcbiAgICAgIGFuY2VzdG9ycyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGFuY2VzdG9ycy5wdXNoKG5hbWUpO1xyXG4gICAgdmlzaXRlZFtuYW1lXSA9IHRydWU7XHJcblxyXG4gICAgZ3JhcGhbbmFtZV0uZm9yRWFjaCgoZGVwOiBzdHJpbmcpID0+IHtcclxuICAgICAgaWYgKGFuY2VzdG9ycy5pbmRleE9mKGRlcCkgPj0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBDaXJjdWxhciBkZXBlbmRlbmN5ICcke2RlcH0nIGlzIHJlcXVpcmVkIGJ5ICcke25hbWV9JzogJHthbmNlc3RvcnMuam9pbignIC0+ICcpfWBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodmlzaXRlZFtkZXBdKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2aXNpdChkZXAsIGFuY2VzdG9ycy5zbGljZSgwKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoc29ydGVkLmluZGV4T2YobmFtZSkgPCAwKSB7XHJcbiAgICAgIHNvcnRlZC5wdXNoKG5hbWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIE9iamVjdC5rZXlzKGdyYXBoKS5mb3JFYWNoKGsgPT4gdmlzaXQoaykpO1xyXG5cclxuICByZXR1cm4gc29ydGVkLnJldmVyc2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmo6IGFueSkge1xyXG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG5jb25zdCBET0xMQVJfQ0hBUl9DT0RFID0gMzY7XHJcblxyXG4vKipcclxuICogSWYgYGZvbyRgID0+IG1ha2UgaXQganVzdCBgZm9vYFxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRG9sbGFyQXRUaGVFbmQobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCBsYXN0Q2hhckluZGV4ID0gbmFtZS5sZW5ndGggLSAxO1xyXG4gIGNvbnN0IGRvbGxhckF0VGhlRW5kID0gbmFtZS5jaGFyQ29kZUF0KGxhc3RDaGFySW5kZXgpID09PSBET0xMQVJfQ0hBUl9DT0RFO1xyXG4gIHJldHVybiBkb2xsYXJBdFRoZUVuZCA/IG5hbWUuc2xpY2UoMCwgbGFzdENoYXJJbmRleCkgOiBuYW1lO1xyXG59XHJcbiJdfQ==