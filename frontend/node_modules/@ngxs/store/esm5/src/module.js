/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { NgModule, Optional, Inject, InjectionToken, APP_BOOTSTRAP_LISTENER } from '@angular/core';
import { NgxsBootstrapper } from '@ngxs/store/internals';
import { ROOT_STATE_TOKEN, FEATURE_STATE_TOKEN, NgxsConfig } from './symbols';
import { NGXS_EXECUTION_STRATEGY } from './execution/symbols';
import { StateFactory } from './internal/state-factory';
import { StateContextFactory } from './internal/state-context-factory';
import { Actions, InternalActions } from './actions-stream';
import { ConfigValidator } from './internal/config-validator';
import { LifecycleStateManager } from './internal/lifecycle-state-manager';
import { InternalDispatcher, InternalDispatchedActionResults } from './internal/dispatcher';
import { InternalStateOperations } from './internal/state-operations';
import { Store } from './store';
import { SelectFactory } from './decorators/select';
import { StateStream } from './internal/state-stream';
import { PluginManager } from './plugin-manager';
import { InitState, UpdateState } from './actions/actions';
import { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';
import { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';
/**
 * Root module
 * @ignore
 */
var NgxsRootModule = /** @class */ (function () {
    function NgxsRootModule(factory, internalStateOperations, store, select, states, lifecycleStateManager) {
        if (states === void 0) { states = []; }
        // add stores to the state graph and return their defaults
        /** @type {?} */
        var results = factory.addAndReturnDefaults(states);
        internalStateOperations.setStateToTheCurrentWithNew(results);
        // connect our actions stream
        factory.connectActionHandlers();
        // dispatch the init action and invoke init and bootstrap functions after
        lifecycleStateManager.ngxsBootstrap(new InitState(), results);
    }
    NgxsRootModule.decorators = [
        { type: NgModule }
    ];
    /** @nocollapse */
    NgxsRootModule.ctorParameters = function () { return [
        { type: StateFactory },
        { type: InternalStateOperations },
        { type: Store },
        { type: SelectFactory },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [ROOT_STATE_TOKEN,] }] },
        { type: LifecycleStateManager }
    ]; };
    return NgxsRootModule;
}());
export { NgxsRootModule };
/**
 * Feature module
 * @ignore
 */
var NgxsFeatureModule = /** @class */ (function () {
    function NgxsFeatureModule(store, internalStateOperations, factory, states, lifecycleStateManager) {
        // Since FEATURE_STATE_TOKEN is a multi token, we need to
        // flatten it [[Feature1State, Feature2State], [Feature3State]]
        /** @type {?} */
        var flattenedStates = ((/** @type {?} */ ([]))).concat.apply(((/** @type {?} */ ([]))), tslib_1.__spread(states));
        // add stores to the state graph and return their defaults
        /** @type {?} */
        var results = factory.addAndReturnDefaults(flattenedStates);
        if (results.states.length) {
            internalStateOperations.setStateToTheCurrentWithNew(results);
            // dispatch the update action and invoke init and bootstrap functions after
            lifecycleStateManager.ngxsBootstrap(new UpdateState(), results);
        }
    }
    NgxsFeatureModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    /** @nocollapse */
    NgxsFeatureModule.ctorParameters = function () { return [
        { type: Store },
        { type: InternalStateOperations },
        { type: StateFactory },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [FEATURE_STATE_TOKEN,] }] },
        { type: LifecycleStateManager }
    ]; };
    return NgxsFeatureModule;
}());
export { NgxsFeatureModule };
/**
 * @param {?} options
 * @return {?}
 */
export function ngxsConfigFactory(options) {
    /** @type {?} */
    var config = Object.assign(new NgxsConfig(), options);
    return config;
}
/**
 * @param {?} bootstrapper
 * @return {?}
 */
export function appBootstrapListenerFactory(bootstrapper) {
    return (/**
     * @return {?}
     */
    function () { return bootstrapper.bootstrap(); });
}
/** @type {?} */
export var ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');
/**
 * Ngxs Module
 */
var NgxsModule = /** @class */ (function () {
    function NgxsModule() {
    }
    /**
     * Root module factory
     */
    /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    NgxsModule.forRoot = /**
     * Root module factory
     * @param {?=} states
     * @param {?=} options
     * @return {?}
     */
    function (states, options) {
        if (states === void 0) { states = []; }
        if (options === void 0) { options = {}; }
        return {
            ngModule: NgxsRootModule,
            providers: tslib_1.__spread([
                StateFactory,
                StateContextFactory,
                Actions,
                InternalActions,
                NgxsBootstrapper,
                ConfigValidator,
                LifecycleStateManager,
                InternalDispatcher,
                InternalDispatchedActionResults,
                InternalStateOperations,
                InternalNgxsExecutionStrategy,
                Store,
                StateStream,
                SelectFactory,
                PluginManager
            ], states, [
                {
                    provide: NGXS_EXECUTION_STRATEGY,
                    useClass: options.executionStrategy || DispatchOutsideZoneNgxsExecutionStrategy
                },
                {
                    provide: ROOT_STATE_TOKEN,
                    useValue: states
                },
                {
                    provide: ROOT_OPTIONS,
                    useValue: options
                },
                {
                    provide: NgxsConfig,
                    useFactory: ngxsConfigFactory,
                    deps: [ROOT_OPTIONS]
                },
                {
                    provide: APP_BOOTSTRAP_LISTENER,
                    useFactory: appBootstrapListenerFactory,
                    multi: true,
                    deps: [NgxsBootstrapper]
                }
            ])
        };
    };
    /**
     * Feature module factory
     */
    /**
     * Feature module factory
     * @param {?=} states
     * @return {?}
     */
    NgxsModule.forFeature = /**
     * Feature module factory
     * @param {?=} states
     * @return {?}
     */
    function (states) {
        if (states === void 0) { states = []; }
        return {
            ngModule: NgxsFeatureModule,
            providers: tslib_1.__spread([
                StateFactory,
                PluginManager
            ], states, [
                {
                    provide: FEATURE_STATE_TOKEN,
                    multi: true,
                    useValue: states
                }
            ])
        };
    };
    NgxsModule.decorators = [
        { type: NgModule, args: [{},] }
    ];
    return NgxsModule;
}());
export { NgxsModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kdWxlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvbW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLFFBQVEsRUFFUixRQUFRLEVBQ1IsTUFBTSxFQUNOLGNBQWMsRUFDZCxzQkFBc0IsRUFDdkIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFekQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLG1CQUFtQixFQUFFLFVBQVUsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUM5RSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDeEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDdkUsT0FBTyxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDOUQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDM0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLCtCQUErQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUYsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDdEUsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3RELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRCxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxNQUFN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YUFBYTtnQkFDYixhQUFhO2VBQ1YsTUFBTTtnQkFDVDtvQkFDRSxPQUFPLEVBQUUsdUJBQXVCO29CQUNoQyxRQUFRLEVBQUUsT0FBTyxDQUFDLGlCQUFpQixJQUFJLHdDQUF3QztpQkFDaEY7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLGdCQUFnQjtvQkFDekIsUUFBUSxFQUFFLE1BQU07aUJBQ2pCO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxZQUFZO29CQUNyQixRQUFRLEVBQUUsT0FBTztpQkFDbEI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLFVBQVU7b0JBQ25CLFVBQVUsRUFBRSxpQkFBaUI7b0JBQzdCLElBQUksRUFBRSxDQUFDLFlBQVksQ0FBQztpQkFDckI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLHNCQUFzQjtvQkFDL0IsVUFBVSxFQUFFLDJCQUEyQjtvQkFDdkMsS0FBSyxFQUFFLElBQUk7b0JBQ1gsSUFBSSxFQUFFLENBQUMsZ0JBQWdCLENBQUM7aUJBQ3pCO2NBQ0Y7U0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHOzs7Ozs7SUFDSSxxQkFBVTs7Ozs7SUFBakIsVUFBa0IsTUFBeUI7UUFBekIsdUJBQUEsRUFBQSxXQUF5QjtRQUN6QyxPQUFPO1lBQ0wsUUFBUSxFQUFFLGlCQUFpQjtZQUMzQixTQUFTO2dCQUNQLFlBQVk7Z0JBQ1osYUFBYTtlQUNWLE1BQU07Z0JBQ1Q7b0JBQ0UsT0FBTyxFQUFFLG1CQUFtQjtvQkFDNUIsS0FBSyxFQUFFLElBQUk7b0JBQ1gsUUFBUSxFQUFFLE1BQU07aUJBQ2pCO2NBQ0Y7U0FDRixDQUFDO0lBQ0osQ0FBQzs7Z0JBckVGLFFBQVEsU0FBQyxFQUFFOztJQXNFWixpQkFBQztDQUFBLEFBdEVELElBc0VDO1NBckVZLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIE5nTW9kdWxlLFxyXG4gIE1vZHVsZVdpdGhQcm92aWRlcnMsXHJcbiAgT3B0aW9uYWwsXHJcbiAgSW5qZWN0LFxyXG4gIEluamVjdGlvblRva2VuLFxyXG4gIEFQUF9CT09UU1RSQVBfTElTVEVORVJcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IE5neHNCb290c3RyYXBwZXIgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xyXG5cclxuaW1wb3J0IHsgUk9PVF9TVEFURV9UT0tFTiwgRkVBVFVSRV9TVEFURV9UT0tFTiwgTmd4c0NvbmZpZyB9IGZyb20gJy4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE5HWFNfRVhFQ1VUSU9OX1NUUkFURUdZIH0gZnJvbSAnLi9leGVjdXRpb24vc3ltYm9scyc7XHJcbmltcG9ydCB7IFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtZmFjdG9yeSc7XHJcbmltcG9ydCB7IFN0YXRlQ29udGV4dEZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XHJcbmltcG9ydCB7IEFjdGlvbnMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4vYWN0aW9ucy1zdHJlYW0nO1xyXG5pbXBvcnQgeyBDb25maWdWYWxpZGF0b3IgfSBmcm9tICcuL2ludGVybmFsL2NvbmZpZy12YWxpZGF0b3InO1xyXG5pbXBvcnQgeyBMaWZlY3ljbGVTdGF0ZU1hbmFnZXIgfSBmcm9tICcuL2ludGVybmFsL2xpZmVjeWNsZS1zdGF0ZS1tYW5hZ2VyJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVyLCBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi9pbnRlcm5hbC9kaXNwYXRjaGVyJztcclxuaW1wb3J0IHsgSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMnO1xyXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJy4vc3RvcmUnO1xyXG5pbXBvcnQgeyBTZWxlY3RGYWN0b3J5IH0gZnJvbSAnLi9kZWNvcmF0b3JzL3NlbGVjdCc7XHJcbmltcG9ydCB7IFN0YXRlU3RyZWFtIH0gZnJvbSAnLi9pbnRlcm5hbC9zdGF0ZS1zdHJlYW0nO1xyXG5pbXBvcnQgeyBQbHVnaW5NYW5hZ2VyIH0gZnJvbSAnLi9wbHVnaW4tbWFuYWdlcic7XHJcbmltcG9ydCB7IEluaXRTdGF0ZSwgVXBkYXRlU3RhdGUgfSBmcm9tICcuL2FjdGlvbnMvYWN0aW9ucyc7XHJcbmltcG9ydCB7IFN0YXRlQ2xhc3MgfSBmcm9tICcuL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IERpc3BhdGNoT3V0c2lkZVpvbmVOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9kaXNwYXRjaC1vdXRzaWRlLXpvbmUtbmd4cy1leGVjdXRpb24tc3RyYXRlZ3knO1xyXG5pbXBvcnQgeyBJbnRlcm5hbE5neHNFeGVjdXRpb25TdHJhdGVneSB9IGZyb20gJy4vZXhlY3V0aW9uL2ludGVybmFsLW5neHMtZXhlY3V0aW9uLXN0cmF0ZWd5JztcclxuXHJcbi8qKlxyXG4gKiBSb290IG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ATmdNb2R1bGUoKVxyXG5leHBvcnQgY2xhc3MgTmd4c1Jvb3RNb2R1bGUge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZmFjdG9yeTogU3RhdGVGYWN0b3J5LFxyXG4gICAgaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxyXG4gICAgc3RvcmU6IFN0b3JlLFxyXG4gICAgc2VsZWN0OiBTZWxlY3RGYWN0b3J5LFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBJbmplY3QoUk9PVF9TVEFURV9UT0tFTilcclxuICAgIHN0YXRlczogU3RhdGVDbGFzc1tdID0gW10sXHJcbiAgICBsaWZlY3ljbGVTdGF0ZU1hbmFnZXI6IExpZmVjeWNsZVN0YXRlTWFuYWdlclxyXG4gICkge1xyXG4gICAgLy8gYWRkIHN0b3JlcyB0byB0aGUgc3RhdGUgZ3JhcGggYW5kIHJldHVybiB0aGVpciBkZWZhdWx0c1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGZhY3RvcnkuYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVzKTtcclxuXHJcbiAgICBpbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5zZXRTdGF0ZVRvVGhlQ3VycmVudFdpdGhOZXcocmVzdWx0cyk7XHJcblxyXG4gICAgLy8gY29ubmVjdCBvdXIgYWN0aW9ucyBzdHJlYW1cclxuICAgIGZhY3RvcnkuY29ubmVjdEFjdGlvbkhhbmRsZXJzKCk7XHJcblxyXG4gICAgLy8gZGlzcGF0Y2ggdGhlIGluaXQgYWN0aW9uIGFuZCBpbnZva2UgaW5pdCBhbmQgYm9vdHN0cmFwIGZ1bmN0aW9ucyBhZnRlclxyXG4gICAgbGlmZWN5Y2xlU3RhdGVNYW5hZ2VyLm5neHNCb290c3RyYXAobmV3IEluaXRTdGF0ZSgpLCByZXN1bHRzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZWF0dXJlIG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ATmdNb2R1bGUoe30pXHJcbmV4cG9ydCBjbGFzcyBOZ3hzRmVhdHVyZU1vZHVsZSB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBzdG9yZTogU3RvcmUsXHJcbiAgICBpbnRlcm5hbFN0YXRlT3BlcmF0aW9uczogSW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMsXHJcbiAgICBmYWN0b3J5OiBTdGF0ZUZhY3RvcnksXHJcbiAgICBAT3B0aW9uYWwoKVxyXG4gICAgQEluamVjdChGRUFUVVJFX1NUQVRFX1RPS0VOKVxyXG4gICAgc3RhdGVzOiBhbnlbXVtdLFxyXG4gICAgbGlmZWN5Y2xlU3RhdGVNYW5hZ2VyOiBMaWZlY3ljbGVTdGF0ZU1hbmFnZXJcclxuICApIHtcclxuICAgIC8vIFNpbmNlIEZFQVRVUkVfU1RBVEVfVE9LRU4gaXMgYSBtdWx0aSB0b2tlbiwgd2UgbmVlZCB0b1xyXG4gICAgLy8gZmxhdHRlbiBpdCBbW0ZlYXR1cmUxU3RhdGUsIEZlYXR1cmUyU3RhdGVdLCBbRmVhdHVyZTNTdGF0ZV1dXHJcbiAgICBjb25zdCBmbGF0dGVuZWRTdGF0ZXMgPSAoW10gYXMgYW55W10pLmNvbmNhdCguLi5zdGF0ZXMpO1xyXG5cclxuICAgIC8vIGFkZCBzdG9yZXMgdG8gdGhlIHN0YXRlIGdyYXBoIGFuZCByZXR1cm4gdGhlaXIgZGVmYXVsdHNcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBmYWN0b3J5LmFkZEFuZFJldHVybkRlZmF1bHRzKGZsYXR0ZW5lZFN0YXRlcyk7XHJcblxyXG4gICAgaWYgKHJlc3VsdHMuc3RhdGVzLmxlbmd0aCkge1xyXG4gICAgICBpbnRlcm5hbFN0YXRlT3BlcmF0aW9ucy5zZXRTdGF0ZVRvVGhlQ3VycmVudFdpdGhOZXcocmVzdWx0cyk7XHJcbiAgICAgIC8vIGRpc3BhdGNoIHRoZSB1cGRhdGUgYWN0aW9uIGFuZCBpbnZva2UgaW5pdCBhbmQgYm9vdHN0cmFwIGZ1bmN0aW9ucyBhZnRlclxyXG4gICAgICBsaWZlY3ljbGVTdGF0ZU1hbmFnZXIubmd4c0Jvb3RzdHJhcChuZXcgVXBkYXRlU3RhdGUoKSwgcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBNb2R1bGVPcHRpb25zID0gUGFydGlhbDxOZ3hzQ29uZmlnPjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBuZ3hzQ29uZmlnRmFjdG9yeShvcHRpb25zOiBNb2R1bGVPcHRpb25zKTogTmd4c0NvbmZpZyB7XHJcbiAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihuZXcgTmd4c0NvbmZpZygpLCBvcHRpb25zKTtcclxuICByZXR1cm4gY29uZmlnO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXBwQm9vdHN0cmFwTGlzdGVuZXJGYWN0b3J5KGJvb3RzdHJhcHBlcjogTmd4c0Jvb3RzdHJhcHBlcikge1xyXG4gIHJldHVybiAoKSA9PiBib290c3RyYXBwZXIuYm9vdHN0cmFwKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBST09UX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TW9kdWxlT3B0aW9ucz4oJ1JPT1RfT1BUSU9OUycpO1xyXG5cclxuLyoqXHJcbiAqIE5neHMgTW9kdWxlXHJcbiAqL1xyXG5ATmdNb2R1bGUoe30pXHJcbmV4cG9ydCBjbGFzcyBOZ3hzTW9kdWxlIHtcclxuICAvKipcclxuICAgKiBSb290IG1vZHVsZSBmYWN0b3J5XHJcbiAgICovXHJcbiAgc3RhdGljIGZvclJvb3Qoc3RhdGVzOiBTdGF0ZUNsYXNzW10gPSBbXSwgb3B0aW9uczogTW9kdWxlT3B0aW9ucyA9IHt9KTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogTmd4c1Jvb3RNb2R1bGUsXHJcbiAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIFN0YXRlRmFjdG9yeSxcclxuICAgICAgICBTdGF0ZUNvbnRleHRGYWN0b3J5LFxyXG4gICAgICAgIEFjdGlvbnMsXHJcbiAgICAgICAgSW50ZXJuYWxBY3Rpb25zLFxyXG4gICAgICAgIE5neHNCb290c3RyYXBwZXIsXHJcbiAgICAgICAgQ29uZmlnVmFsaWRhdG9yLFxyXG4gICAgICAgIExpZmVjeWNsZVN0YXRlTWFuYWdlcixcclxuICAgICAgICBJbnRlcm5hbERpc3BhdGNoZXIsXHJcbiAgICAgICAgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcclxuICAgICAgICBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyxcclxuICAgICAgICBJbnRlcm5hbE5neHNFeGVjdXRpb25TdHJhdGVneSxcclxuICAgICAgICBTdG9yZSxcclxuICAgICAgICBTdGF0ZVN0cmVhbSxcclxuICAgICAgICBTZWxlY3RGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IE5HWFNfRVhFQ1VUSU9OX1NUUkFURUdZLFxyXG4gICAgICAgICAgdXNlQ2xhc3M6IG9wdGlvbnMuZXhlY3V0aW9uU3RyYXRlZ3kgfHwgRGlzcGF0Y2hPdXRzaWRlWm9uZU5neHNFeGVjdXRpb25TdHJhdGVneVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogUk9PVF9TVEFURV9UT0tFTixcclxuICAgICAgICAgIHVzZVZhbHVlOiBzdGF0ZXNcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IFJPT1RfT1BUSU9OUyxcclxuICAgICAgICAgIHVzZVZhbHVlOiBvcHRpb25zXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBOZ3hzQ29uZmlnLFxyXG4gICAgICAgICAgdXNlRmFjdG9yeTogbmd4c0NvbmZpZ0ZhY3RvcnksXHJcbiAgICAgICAgICBkZXBzOiBbUk9PVF9PUFRJT05TXVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgcHJvdmlkZTogQVBQX0JPT1RTVFJBUF9MSVNURU5FUixcclxuICAgICAgICAgIHVzZUZhY3Rvcnk6IGFwcEJvb3RzdHJhcExpc3RlbmVyRmFjdG9yeSxcclxuICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgICAgZGVwczogW05neHNCb290c3RyYXBwZXJdXHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmVhdHVyZSBtb2R1bGUgZmFjdG9yeVxyXG4gICAqL1xyXG4gIHN0YXRpYyBmb3JGZWF0dXJlKHN0YXRlczogU3RhdGVDbGFzc1tdID0gW10pOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBOZ3hzRmVhdHVyZU1vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgU3RhdGVGYWN0b3J5LFxyXG4gICAgICAgIFBsdWdpbk1hbmFnZXIsXHJcbiAgICAgICAgLi4uc3RhdGVzLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3ZpZGU6IEZFQVRVUkVfU1RBVEVfVE9LRU4sXHJcbiAgICAgICAgICBtdWx0aTogdHJ1ZSxcclxuICAgICAgICAgIHVzZVZhbHVlOiBzdGF0ZXNcclxuICAgICAgICB9XHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdfQ==