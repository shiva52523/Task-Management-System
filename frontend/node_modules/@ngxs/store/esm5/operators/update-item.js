/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { isStateOperator, isPredicate, isNumber, invalidIndex } from './utils';
/**
 * @template T
 * @param {?} selector - Index of item in the array or a predicate function
 * that can be provided in `Array.prototype.findIndex`
 * @param {?} operatorOrValue - New value under the `selector` index or a
 * function that can be applied to an existing value
 * @return {?}
 */
export function updateItem(selector, operatorOrValue) {
    return (/**
     * @param {?} existing
     * @return {?}
     */
    function updateItemOperator(existing) {
        /** @type {?} */
        var index = -1;
        if (isPredicate(selector)) {
            index = existing.findIndex(selector);
        }
        else if (isNumber(selector)) {
            index = selector;
        }
        if (invalidIndex(index)) {
            return existing;
        }
        /** @type {?} */
        var value = (/** @type {?} */ (null));
        // Need to check if the new item value will change the existing item value
        // then, only if it will change it then clone the array and set the item
        if (isStateOperator(operatorOrValue)) {
            value = operatorOrValue(existing[index]);
        }
        else {
            value = operatorOrValue;
        }
        // If the value hasn't been mutated
        // then we just return `existing` array
        if (value === existing[index]) {
            return existing;
        }
        /** @type {?} */
        var clone = tslib_1.__spread(existing);
        clone[index] = value;
        return clone;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlLWl0ZW0uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS9vcGVyYXRvcnMvIiwic291cmNlcyI6WyJ1cGRhdGUtaXRlbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUVBLE9BQU8sRUFBRSxlQUFlLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsTUFBTSxTQUFTLENBQUM7Ozs7Ozs7OztBQVMvRSxNQUFNLFVBQVUsVUFBVSxDQUN4QixRQUErQixFQUMvQixlQUFxQztJQUVyQzs7OztJQUFPLFNBQVMsa0JBQWtCLENBQUMsUUFBdUI7O1lBQ3BELEtBQUssR0FBRyxDQUFDLENBQUM7UUFFZCxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUN6QixLQUFLLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN0QzthQUFNLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzdCLEtBQUssR0FBRyxRQUFRLENBQUM7U0FDbEI7UUFFRCxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN2QixPQUFPLFFBQVEsQ0FBQztTQUNqQjs7WUFFRyxLQUFLLEdBQU0sbUJBQUEsSUFBSSxFQUFDO1FBQ3BCLDBFQUEwRTtRQUMxRSx3RUFBd0U7UUFDeEUsSUFBSSxlQUFlLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDcEMsS0FBSyxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUMxQzthQUFNO1lBQ0wsS0FBSyxHQUFHLGVBQWUsQ0FBQztTQUN6QjtRQUVELG1DQUFtQztRQUNuQyx1Q0FBdUM7UUFDdkMsSUFBSSxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzdCLE9BQU8sUUFBUSxDQUFDO1NBQ2pCOztZQUVLLEtBQUssb0JBQU8sUUFBUSxDQUFDO1FBQzNCLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUM7UUFDckIsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLEVBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RhdGVPcGVyYXRvciB9IGZyb20gJ0BuZ3hzL3N0b3JlJztcclxuXHJcbmltcG9ydCB7IGlzU3RhdGVPcGVyYXRvciwgaXNQcmVkaWNhdGUsIGlzTnVtYmVyLCBpbnZhbGlkSW5kZXggfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBzZWxlY3RvciAtIEluZGV4IG9mIGl0ZW0gaW4gdGhlIGFycmF5IG9yIGEgcHJlZGljYXRlIGZ1bmN0aW9uXHJcbiAqIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YFxyXG4gKiBAcGFyYW0gb3BlcmF0b3JPclZhbHVlIC0gTmV3IHZhbHVlIHVuZGVyIHRoZSBgc2VsZWN0b3JgIGluZGV4IG9yIGFcclxuICogZnVuY3Rpb24gdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhbiBleGlzdGluZyB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUl0ZW08VD4oXHJcbiAgc2VsZWN0b3I6IG51bWJlciB8IFByZWRpY2F0ZTxUPixcclxuICBvcGVyYXRvck9yVmFsdWU6IFQgfCBTdGF0ZU9wZXJhdG9yPFQ+XHJcbik6IFN0YXRlT3BlcmF0b3I8VFtdPiB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZUl0ZW1PcGVyYXRvcihleGlzdGluZzogUmVhZG9ubHk8VFtdPikge1xyXG4gICAgbGV0IGluZGV4ID0gLTE7XHJcblxyXG4gICAgaWYgKGlzUHJlZGljYXRlKHNlbGVjdG9yKSkge1xyXG4gICAgICBpbmRleCA9IGV4aXN0aW5nLmZpbmRJbmRleChzZWxlY3Rvcik7XHJcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHNlbGVjdG9yKSkge1xyXG4gICAgICBpbmRleCA9IHNlbGVjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpbnZhbGlkSW5kZXgoaW5kZXgpKSB7XHJcbiAgICAgIHJldHVybiBleGlzdGluZztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdmFsdWU6IFQgPSBudWxsITtcclxuICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIG5ldyBpdGVtIHZhbHVlIHdpbGwgY2hhbmdlIHRoZSBleGlzdGluZyBpdGVtIHZhbHVlXHJcbiAgICAvLyB0aGVuLCBvbmx5IGlmIGl0IHdpbGwgY2hhbmdlIGl0IHRoZW4gY2xvbmUgdGhlIGFycmF5IGFuZCBzZXQgdGhlIGl0ZW1cclxuICAgIGlmIChpc1N0YXRlT3BlcmF0b3Iob3BlcmF0b3JPclZhbHVlKSkge1xyXG4gICAgICB2YWx1ZSA9IG9wZXJhdG9yT3JWYWx1ZShleGlzdGluZ1tpbmRleF0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsdWUgPSBvcGVyYXRvck9yVmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHZhbHVlIGhhc24ndCBiZWVuIG11dGF0ZWRcclxuICAgIC8vIHRoZW4gd2UganVzdCByZXR1cm4gYGV4aXN0aW5nYCBhcnJheVxyXG4gICAgaWYgKHZhbHVlID09PSBleGlzdGluZ1tpbmRleF0pIHtcclxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNsb25lID0gWy4uLmV4aXN0aW5nXTtcclxuICAgIGNsb25lW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIGNsb25lO1xyXG4gIH07XHJcbn1cclxuIl19