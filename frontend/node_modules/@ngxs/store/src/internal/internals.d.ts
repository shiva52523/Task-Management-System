import { ActionOptions, META_KEY, META_OPTIONS_KEY, NgxsConfig, StoreOptions } from '../symbols';
import { Observable } from 'rxjs';
export interface ObjectKeyMap<T> {
    [key: string]: T;
}
export interface StateClass<T = any, U = any> {
    [META_KEY]?: MetaDataModel;
    [META_OPTIONS_KEY]?: StoreOptions<U>;
    new (...args: any[]): T;
}
export declare type StateKeyGraph = ObjectKeyMap<string[]>;
export declare type StatesByName = ObjectKeyMap<StateClass>;
export interface ActionHandlerMetaData {
    fn: string | symbol;
    options: ActionOptions;
    type: string;
}
export interface StateOperations<T> {
    getState(): T;
    setState(val: T): T;
    dispatch(actions: any | any[]): Observable<void>;
}
export interface MetaDataModel {
    name: string | null;
    actions: ObjectKeyMap<ActionHandlerMetaData[]>;
    defaults: any;
    path: string | null;
    selectFromAppState: SelectFromState | null;
    children?: StateClass[];
    instance: any;
}
export declare type SelectFromState = (state: any) => any;
export interface SelectorMetaDataModel {
    selectFromAppState: SelectFromState | null;
    originalFn: Function | null;
    containerClass: any;
    selectorName: string | null;
}
export interface MappedStore {
    name: string;
    actions: ObjectKeyMap<ActionHandlerMetaData[]>;
    defaults: any;
    instance: any;
    depth: string;
}
export interface StatesAndDefaults {
    defaults: any;
    states: MappedStore[];
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 */
export declare function ensureStoreMetadata(target: StateClass): MetaDataModel;
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 */
export declare function getStoreMetadata(target: StateClass): MetaDataModel;
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 */
export declare function ensureSelectorMetadata(target: Function): SelectorMetaDataModel;
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 */
export declare function getSelectorMetadata(target: any): SelectorMetaDataModel;
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 */
export declare function propGetter(paths: string[], config: NgxsConfig): (x: any) => any;
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 */
export declare function buildGraph(stateClasses: StateClass[]): StateKeyGraph;
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 */
export declare function nameToState(states: StateClass[]): ObjectKeyMap<StateClass>;
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 */
export declare function findFullParentPath(obj: StateKeyGraph, newObj?: ObjectKeyMap<string>): ObjectKeyMap<string>;
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 */
export declare function topologicalSort(graph: StateKeyGraph): string[];
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 */
export declare function isObject(obj: any): boolean;
/**
 * If `foo$` => make it just `foo`
 *
 * @ignore
 */
export declare function removeDollarAtTheEnd(name: string): string;
