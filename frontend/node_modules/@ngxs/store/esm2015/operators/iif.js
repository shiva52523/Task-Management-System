/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { isStateOperator, isUndefined, isPredicate } from './utils';
/**
 * @template T
 * @param {?} operatorOrValue
 * @param {?=} existing
 * @return {?}
 */
function retrieveValue(operatorOrValue, existing) {
    // If state operator is a function
    // then call it with an original value
    if (isStateOperator(operatorOrValue)) {
        return operatorOrValue((/** @type {?} */ (existing)));
    }
    // If operator or value was not provided
    // e.g. `elseOperatorOrValue` is `undefined`
    // then we just return an original value
    if (isUndefined(operatorOrValue)) {
        return (/** @type {?} */ (existing));
    }
    return operatorOrValue;
}
/**
 * @template T
 * @param {?} condition - Condition can be a plain boolean value or a function,
 * that returns boolean, also this function can take a value as an argument
 * to which this state operator applies
 * @param {?} trueOperatorOrValue - Any value or a state operator
 * @param {?=} elseOperatorOrValue - Any value or a state operator
 * @return {?}
 */
export function iif(condition, trueOperatorOrValue, elseOperatorOrValue) {
    return (/**
     * @param {?} existing
     * @return {?}
     */
    function iifOperator(existing) {
        // Convert the value to a boolean
        /** @type {?} */
        let result = !!condition;
        // but if it is a function then run it to get the result
        if (isPredicate(condition)) {
            result = condition(existing);
        }
        if (result) {
            return retrieveValue(trueOperatorOrValue, existing);
        }
        return retrieveValue((/** @type {?} */ (elseOperatorOrValue)), existing);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWlmLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvb3BlcmF0b3JzLyIsInNvdXJjZXMiOlsiaWlmLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsTUFBTSxTQUFTLENBQUM7Ozs7Ozs7QUFHcEUsU0FBUyxhQUFhLENBQUksZUFBcUMsRUFBRSxRQUFzQjtJQUNyRixrQ0FBa0M7SUFDbEMsc0NBQXNDO0lBQ3RDLElBQUksZUFBZSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1FBQ3BDLE9BQU8sZUFBZSxDQUFDLG1CQUFBLFFBQVEsRUFBQyxDQUFDLENBQUM7S0FDbkM7SUFFRCx3Q0FBd0M7SUFDeEMsNENBQTRDO0lBQzVDLHdDQUF3QztJQUN4QyxJQUFJLFdBQVcsQ0FBQyxlQUFlLENBQUMsRUFBRTtRQUNoQyxPQUFPLG1CQUFBLFFBQVEsRUFBQyxDQUFDO0tBQ2xCO0lBRUQsT0FBTyxlQUFlLENBQUM7QUFDekIsQ0FBQzs7Ozs7Ozs7OztBQVNELE1BQU0sVUFBVSxHQUFHLENBQ2pCLFNBQWlDLEVBQ2pDLG1CQUF5QyxFQUN6QyxtQkFBMEM7SUFFMUM7Ozs7SUFBTyxTQUFTLFdBQVcsQ0FBQyxRQUFxQjs7O1lBRTNDLE1BQU0sR0FBRyxDQUFDLENBQUMsU0FBUztRQUN4Qix3REFBd0Q7UUFDeEQsSUFBSSxXQUFXLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDMUIsTUFBTSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM5QjtRQUVELElBQUksTUFBTSxFQUFFO1lBQ1YsT0FBTyxhQUFhLENBQUMsbUJBQW1CLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDckQ7UUFFRCxPQUFPLGFBQWEsQ0FBQyxtQkFBQSxtQkFBbUIsRUFBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3ZELENBQUMsRUFBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdGF0ZU9wZXJhdG9yIH0gZnJvbSAnQG5neHMvc3RvcmUnO1xyXG5cclxuaW1wb3J0IHsgaXNTdGF0ZU9wZXJhdG9yLCBpc1VuZGVmaW5lZCwgaXNQcmVkaWNhdGUgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgUHJlZGljYXRlIH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xyXG5cclxuZnVuY3Rpb24gcmV0cmlldmVWYWx1ZTxUPihvcGVyYXRvck9yVmFsdWU6IFN0YXRlT3BlcmF0b3I8VD4gfCBULCBleGlzdGluZz86IFJlYWRvbmx5PFQ+KTogVCB7XHJcbiAgLy8gSWYgc3RhdGUgb3BlcmF0b3IgaXMgYSBmdW5jdGlvblxyXG4gIC8vIHRoZW4gY2FsbCBpdCB3aXRoIGFuIG9yaWdpbmFsIHZhbHVlXHJcbiAgaWYgKGlzU3RhdGVPcGVyYXRvcihvcGVyYXRvck9yVmFsdWUpKSB7XHJcbiAgICByZXR1cm4gb3BlcmF0b3JPclZhbHVlKGV4aXN0aW5nISk7XHJcbiAgfVxyXG5cclxuICAvLyBJZiBvcGVyYXRvciBvciB2YWx1ZSB3YXMgbm90IHByb3ZpZGVkXHJcbiAgLy8gZS5nLiBgZWxzZU9wZXJhdG9yT3JWYWx1ZWAgaXMgYHVuZGVmaW5lZGBcclxuICAvLyB0aGVuIHdlIGp1c3QgcmV0dXJuIGFuIG9yaWdpbmFsIHZhbHVlXHJcbiAgaWYgKGlzVW5kZWZpbmVkKG9wZXJhdG9yT3JWYWx1ZSkpIHtcclxuICAgIHJldHVybiBleGlzdGluZyE7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gb3BlcmF0b3JPclZhbHVlO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIGNvbmRpdGlvbiAtIENvbmRpdGlvbiBjYW4gYmUgYSBwbGFpbiBib29sZWFuIHZhbHVlIG9yIGEgZnVuY3Rpb24sXHJcbiAqIHRoYXQgcmV0dXJucyBib29sZWFuLCBhbHNvIHRoaXMgZnVuY3Rpb24gY2FuIHRha2UgYSB2YWx1ZSBhcyBhbiBhcmd1bWVudFxyXG4gKiB0byB3aGljaCB0aGlzIHN0YXRlIG9wZXJhdG9yIGFwcGxpZXNcclxuICogQHBhcmFtIHRydWVPcGVyYXRvck9yVmFsdWUgLSBBbnkgdmFsdWUgb3IgYSBzdGF0ZSBvcGVyYXRvclxyXG4gKiBAcGFyYW0gZWxzZU9wZXJhdG9yT3JWYWx1ZSAtIEFueSB2YWx1ZSBvciBhIHN0YXRlIG9wZXJhdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaWlmPFQ+KFxyXG4gIGNvbmRpdGlvbjogUHJlZGljYXRlPFQ+IHwgYm9vbGVhbixcclxuICB0cnVlT3BlcmF0b3JPclZhbHVlOiBTdGF0ZU9wZXJhdG9yPFQ+IHwgVCxcclxuICBlbHNlT3BlcmF0b3JPclZhbHVlPzogU3RhdGVPcGVyYXRvcjxUPiB8IFRcclxuKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGlpZk9wZXJhdG9yKGV4aXN0aW5nOiBSZWFkb25seTxUPik6IFQge1xyXG4gICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBib29sZWFuXHJcbiAgICBsZXQgcmVzdWx0ID0gISFjb25kaXRpb247XHJcbiAgICAvLyBidXQgaWYgaXQgaXMgYSBmdW5jdGlvbiB0aGVuIHJ1biBpdCB0byBnZXQgdGhlIHJlc3VsdFxyXG4gICAgaWYgKGlzUHJlZGljYXRlKGNvbmRpdGlvbikpIHtcclxuICAgICAgcmVzdWx0ID0gY29uZGl0aW9uKGV4aXN0aW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgIHJldHVybiByZXRyaWV2ZVZhbHVlKHRydWVPcGVyYXRvck9yVmFsdWUsIGV4aXN0aW5nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0cmlldmVWYWx1ZShlbHNlT3BlcmF0b3JPclZhbHVlISwgZXhpc3RpbmcpO1xyXG4gIH07XHJcbn1cclxuIl19