/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { isStateOperator, isPredicate, isNumber, invalidIndex } from './utils';
/**
 * @template T
 * @param {?} selector - Index of item in the array or a predicate function
 * that can be provided in `Array.prototype.findIndex`
 * @param {?} operatorOrValue - New value under the `selector` index or a
 * function that can be applied to an existing value
 * @return {?}
 */
export function updateItem(selector, operatorOrValue) {
    return (/**
     * @param {?} existing
     * @return {?}
     */
    function updateItemOperator(existing) {
        /** @type {?} */
        let index = -1;
        if (isPredicate(selector)) {
            index = existing.findIndex(selector);
        }
        else if (isNumber(selector)) {
            index = selector;
        }
        if (invalidIndex(index)) {
            return existing;
        }
        /** @type {?} */
        let value = (/** @type {?} */ (null));
        // Need to check if the new item value will change the existing item value
        // then, only if it will change it then clone the array and set the item
        if (isStateOperator(operatorOrValue)) {
            value = operatorOrValue(existing[index]);
        }
        else {
            value = operatorOrValue;
        }
        // If the value hasn't been mutated
        // then we just return `existing` array
        if (value === existing[index]) {
            return existing;
        }
        /** @type {?} */
        const clone = [...existing];
        clone[index] = value;
        return clone;
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlLWl0ZW0uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS9vcGVyYXRvcnMvIiwic291cmNlcyI6WyJ1cGRhdGUtaXRlbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBRUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxNQUFNLFNBQVMsQ0FBQzs7Ozs7Ozs7O0FBUy9FLE1BQU0sVUFBVSxVQUFVLENBQ3hCLFFBQStCLEVBQy9CLGVBQXFDO0lBRXJDOzs7O0lBQU8sU0FBUyxrQkFBa0IsQ0FBQyxRQUF1Qjs7WUFDcEQsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUVkLElBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ3pCLEtBQUssR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3RDO2FBQU0sSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDN0IsS0FBSyxHQUFHLFFBQVEsQ0FBQztTQUNsQjtRQUVELElBQUksWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3ZCLE9BQU8sUUFBUSxDQUFDO1NBQ2pCOztZQUVHLEtBQUssR0FBTSxtQkFBQSxJQUFJLEVBQUM7UUFDcEIsMEVBQTBFO1FBQzFFLHdFQUF3RTtRQUN4RSxJQUFJLGVBQWUsQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUNwQyxLQUFLLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQzFDO2FBQU07WUFDTCxLQUFLLEdBQUcsZUFBZSxDQUFDO1NBQ3pCO1FBRUQsbUNBQW1DO1FBQ25DLHVDQUF1QztRQUN2QyxJQUFJLEtBQUssS0FBSyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTyxRQUFRLENBQUM7U0FDakI7O2NBRUssS0FBSyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUM7UUFDM0IsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUNyQixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUMsRUFBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdGF0ZU9wZXJhdG9yIH0gZnJvbSAnQG5neHMvc3RvcmUnO1xyXG5cclxuaW1wb3J0IHsgaXNTdGF0ZU9wZXJhdG9yLCBpc1ByZWRpY2F0ZSwgaXNOdW1iZXIsIGludmFsaWRJbmRleCB9IGZyb20gJy4vdXRpbHMnO1xyXG5pbXBvcnQgeyBQcmVkaWNhdGUgfSBmcm9tICcuL2ludGVybmFscyc7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHNlbGVjdG9yIC0gSW5kZXggb2YgaXRlbSBpbiB0aGUgYXJyYXkgb3IgYSBwcmVkaWNhdGUgZnVuY3Rpb25cclxuICogdGhhdCBjYW4gYmUgcHJvdmlkZWQgaW4gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgXHJcbiAqIEBwYXJhbSBvcGVyYXRvck9yVmFsdWUgLSBOZXcgdmFsdWUgdW5kZXIgdGhlIGBzZWxlY3RvcmAgaW5kZXggb3IgYVxyXG4gKiBmdW5jdGlvbiB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlSXRlbTxUPihcclxuICBzZWxlY3RvcjogbnVtYmVyIHwgUHJlZGljYXRlPFQ+LFxyXG4gIG9wZXJhdG9yT3JWYWx1ZTogVCB8IFN0YXRlT3BlcmF0b3I8VD5cclxuKTogU3RhdGVPcGVyYXRvcjxUW10+IHtcclxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlSXRlbU9wZXJhdG9yKGV4aXN0aW5nOiBSZWFkb25seTxUW10+KSB7XHJcbiAgICBsZXQgaW5kZXggPSAtMTtcclxuXHJcbiAgICBpZiAoaXNQcmVkaWNhdGUoc2VsZWN0b3IpKSB7XHJcbiAgICAgIGluZGV4ID0gZXhpc3RpbmcuZmluZEluZGV4KHNlbGVjdG9yKTtcclxuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoc2VsZWN0b3IpKSB7XHJcbiAgICAgIGluZGV4ID0gc2VsZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGludmFsaWRJbmRleChpbmRleCkpIHtcclxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB2YWx1ZTogVCA9IG51bGwhO1xyXG4gICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgbmV3IGl0ZW0gdmFsdWUgd2lsbCBjaGFuZ2UgdGhlIGV4aXN0aW5nIGl0ZW0gdmFsdWVcclxuICAgIC8vIHRoZW4sIG9ubHkgaWYgaXQgd2lsbCBjaGFuZ2UgaXQgdGhlbiBjbG9uZSB0aGUgYXJyYXkgYW5kIHNldCB0aGUgaXRlbVxyXG4gICAgaWYgKGlzU3RhdGVPcGVyYXRvcihvcGVyYXRvck9yVmFsdWUpKSB7XHJcbiAgICAgIHZhbHVlID0gb3BlcmF0b3JPclZhbHVlKGV4aXN0aW5nW2luZGV4XSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YWx1ZSA9IG9wZXJhdG9yT3JWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzbid0IGJlZW4gbXV0YXRlZFxyXG4gICAgLy8gdGhlbiB3ZSBqdXN0IHJldHVybiBgZXhpc3RpbmdgIGFycmF5XHJcbiAgICBpZiAodmFsdWUgPT09IGV4aXN0aW5nW2luZGV4XSkge1xyXG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2xvbmUgPSBbLi4uZXhpc3RpbmddO1xyXG4gICAgY2xvbmVbaW5kZXhdID0gdmFsdWU7XHJcbiAgICByZXR1cm4gY2xvbmU7XHJcbiAgfTtcclxufVxyXG4iXX0=