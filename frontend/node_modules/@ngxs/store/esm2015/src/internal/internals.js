/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { META_KEY, META_OPTIONS_KEY, SELECTOR_META_KEY } from '../symbols';
/**
 * @record
 * @template T
 */
export function ObjectKeyMap() { }
/**
 * @record
 * @template T, U
 */
export function StateClass() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
    /* Skipping unhandled member: new (...args: any[]): T;*/
}
/**
 * @record
 */
export function ActionHandlerMetaData() { }
if (false) {
    /** @type {?} */
    ActionHandlerMetaData.prototype.fn;
    /** @type {?} */
    ActionHandlerMetaData.prototype.options;
    /** @type {?} */
    ActionHandlerMetaData.prototype.type;
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.selectFromAppState;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
    /** @type {?} */
    MetaDataModel.prototype.instance;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectFromAppState;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.depth;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            selectFromAppState: null,
            children: [],
            instance: null
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            selectFromAppState: null,
            originalFn: null,
            containerClass: null,
            selectorName: null
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = [...paths];
    return (/**
     * @param {?} obj
     * @return {?}
     */
    obj => copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    (acc, part) => acc && acc[part]), obj));
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        g => g === stateClass));
        if (!meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        const { name, children } = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        /** @type {?} */
        const meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    });
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        (dep) => {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    k => visit(k)));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
/** @type {?} */
const DOLLAR_CHAR_CODE = 36;
/**
 * If `foo$` => make it just `foo`
 *
 * @ignore
 * @param {?} name
 * @return {?}
 */
export function removeDollarAtTheEnd(name) {
    /** @type {?} */
    const lastCharIndex = name.length - 1;
    /** @type {?} */
    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBRUwsUUFBUSxFQUNSLGdCQUFnQixFQUVoQixpQkFBaUIsRUFFbEIsTUFBTSxZQUFZLENBQUM7Ozs7O0FBR3BCLGtDQUVDOzs7OztBQUdELGdDQUtDOzs7Ozs7Ozs7OztBQUtELDJDQUlDOzs7SUFIQyxtQ0FBb0I7O0lBQ3BCLHdDQUF1Qjs7SUFDdkIscUNBQWE7Ozs7OztBQUdmLHFDQU1DOzs7OztJQUxDLHFEQUFjOzs7OztJQUVkLHdEQUFvQjs7Ozs7SUFFcEIsNERBQWlEOzs7OztBQUduRCxtQ0FRQzs7O0lBUEMsNkJBQW9COztJQUNwQixnQ0FBK0M7O0lBQy9DLGlDQUFjOztJQUNkLDZCQUFvQjs7SUFDcEIsMkNBQTJDOztJQUMzQyxpQ0FBd0I7O0lBQ3hCLGlDQUFjOzs7OztBQUtoQiwyQ0FLQzs7O0lBSkMsbURBQTJDOztJQUMzQywyQ0FBNEI7O0lBQzVCLCtDQUFvQjs7SUFDcEIsNkNBQTRCOzs7OztBQUc5QixpQ0FNQzs7O0lBTEMsMkJBQWE7O0lBQ2IsOEJBQStDOztJQUMvQywrQkFBYzs7SUFDZCwrQkFBYzs7SUFDZCw0QkFBYzs7Ozs7QUFHaEIsdUNBR0M7OztJQUZDLHFDQUFjOztJQUNkLG1DQUFzQjs7Ozs7Ozs7O0FBUXhCLE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxNQUFrQjtJQUNwRCxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTs7Y0FDOUIsZUFBZSxHQUFrQjtZQUNyQyxJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxFQUFFO1lBQ1gsUUFBUSxFQUFFLEVBQUU7WUFDWixJQUFJLEVBQUUsSUFBSTtZQUNWLGtCQUFrQixFQUFFLElBQUk7WUFDeEIsUUFBUSxFQUFFLEVBQUU7WUFD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LElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDOUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQWN0aW9uT3B0aW9ucyxcclxuICBNRVRBX0tFWSxcclxuICBNRVRBX09QVElPTlNfS0VZLFxyXG4gIE5neHNDb25maWcsXHJcbiAgU0VMRUNUT1JfTUVUQV9LRVksXHJcbiAgU3RvcmVPcHRpb25zXHJcbn0gZnJvbSAnLi4vc3ltYm9scyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT2JqZWN0S2V5TWFwPFQ+IHtcclxuICBba2V5OiBzdHJpbmddOiBUO1xyXG59XHJcblxyXG4vLyBpbnNwaXJlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MzY3NDM4OVxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3M8VCA9IGFueSwgVSA9IGFueT4ge1xyXG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xyXG4gIFtNRVRBX09QVElPTlNfS0VZXT86IFN0b3JlT3B0aW9uczxVPjtcclxuXHJcbiAgbmV3ICguLi5hcmdzOiBhbnlbXSk6IFQ7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFN0YXRlS2V5R3JhcGggPSBPYmplY3RLZXlNYXA8c3RyaW5nW10+O1xyXG5leHBvcnQgdHlwZSBTdGF0ZXNCeU5hbWUgPSBPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkhhbmRsZXJNZXRhRGF0YSB7XHJcbiAgZm46IHN0cmluZyB8IHN5bWJvbDtcclxuICBvcHRpb25zOiBBY3Rpb25PcHRpb25zO1xyXG4gIHR5cGU6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZU9wZXJhdGlvbnM8VD4ge1xyXG4gIGdldFN0YXRlKCk6IFQ7XHJcblxyXG4gIHNldFN0YXRlKHZhbDogVCk6IFQ7XHJcblxyXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXRhRGF0YU1vZGVsIHtcclxuICBuYW1lOiBzdHJpbmcgfCBudWxsO1xyXG4gIGFjdGlvbnM6IE9iamVjdEtleU1hcDxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XHJcbiAgZGVmYXVsdHM6IGFueTtcclxuICBwYXRoOiBzdHJpbmcgfCBudWxsO1xyXG4gIHNlbGVjdEZyb21BcHBTdGF0ZTogU2VsZWN0RnJvbVN0YXRlIHwgbnVsbDtcclxuICBjaGlsZHJlbj86IFN0YXRlQ2xhc3NbXTtcclxuICBpbnN0YW5jZTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTZWxlY3RGcm9tU3RhdGUgPSAoc3RhdGU6IGFueSkgPT4gYW55O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xyXG4gIHNlbGVjdEZyb21BcHBTdGF0ZTogU2VsZWN0RnJvbVN0YXRlIHwgbnVsbDtcclxuICBvcmlnaW5hbEZuOiBGdW5jdGlvbiB8IG51bGw7XHJcbiAgY29udGFpbmVyQ2xhc3M6IGFueTtcclxuICBzZWxlY3Rvck5hbWU6IHN0cmluZyB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFwcGVkU3RvcmUge1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBhY3Rpb25zOiBPYmplY3RLZXlNYXA8QWN0aW9uSGFuZGxlck1ldGFEYXRhW10+O1xyXG4gIGRlZmF1bHRzOiBhbnk7XHJcbiAgaW5zdGFuY2U6IGFueTtcclxuICBkZXB0aDogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlc0FuZERlZmF1bHRzIHtcclxuICBkZWZhdWx0czogYW55O1xyXG4gIHN0YXRlczogTWFwcGVkU3RvcmVbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIGNsYXNzIGFuZCByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQ6IFN0YXRlQ2xhc3MpOiBNZXRhRGF0YU1vZGVsIHtcclxuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShNRVRBX0tFWSkpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YTogTWV0YURhdGFNb2RlbCA9IHtcclxuICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgYWN0aW9uczoge30sXHJcbiAgICAgIGRlZmF1bHRzOiB7fSxcclxuICAgICAgcGF0aDogbnVsbCxcclxuICAgICAgc2VsZWN0RnJvbUFwcFN0YXRlOiBudWxsLFxyXG4gICAgICBjaGlsZHJlbjogW10sXHJcbiAgICAgIGluc3RhbmNlOiBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIE1FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBnZXRTdG9yZU1ldGFkYXRhKHRhcmdldCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBzdGF0ZSBjbGFzcyBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yZU1ldGFkYXRhKHRhcmdldDogU3RhdGVDbGFzcyk6IE1ldGFEYXRhTW9kZWwge1xyXG4gIHJldHVybiB0YXJnZXRbTUVUQV9LRVldITtcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQ6IEZ1bmN0aW9uKTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShTRUxFQ1RPUl9NRVRBX0tFWSkpIHtcclxuICAgIGNvbnN0IGRlZmF1bHRNZXRhZGF0YTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsID0ge1xyXG4gICAgICBzZWxlY3RGcm9tQXBwU3RhdGU6IG51bGwsXHJcbiAgICAgIG9yaWdpbmFsRm46IG51bGwsXHJcbiAgICAgIGNvbnRhaW5lckNsYXNzOiBudWxsLFxyXG4gICAgICBzZWxlY3Rvck5hbWU6IG51bGxcclxuICAgIH07XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgU0VMRUNUT1JfTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldDogYW55KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcclxuICByZXR1cm4gdGFyZ2V0W1NFTEVDVE9SX01FVEFfS0VZXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGRlZXBseSBuZXN0ZWQgdmFsdWUuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxyXG4gKlxyXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhcyBmYXN0IGFzIHRoZSBgZmFzdFByb3BHZXR0ZXJgIGJ1dCBpcyBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgY29tcGxpYW50LlxyXG4gKiBTZWUgcGVyZiBoaXQ6IGh0dHBzOi8vanNwZXJmLmNvbS9mYXN0LXZhbHVlLWdldHRlci1naXZlbi1wYXRoLzFcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGxpYW50UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IGNvcHlPZlBhdGhzID0gWy4uLnBhdGhzXTtcclxuICByZXR1cm4gb2JqID0+IGNvcHlPZlBhdGhzLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBnZW5lcmF0ZWQgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW46XHJcbiAqIC0gcGx1Y2sgKE9ic2VydmFibGUgb3BlcmF0b3IpXHJcbiAqIC0gbWVtb2l6ZVxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5mdW5jdGlvbiBmYXN0UHJvcEdldHRlcihwYXRoczogc3RyaW5nW10pOiAoeDogYW55KSA9PiBhbnkge1xyXG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aHM7XHJcbiAgbGV0IHNlZyA9ICdzdG9yZS4nICsgc2VnbWVudHNbMF07XHJcbiAgbGV0IGkgPSAwO1xyXG4gIGNvbnN0IGwgPSBzZWdtZW50cy5sZW5ndGg7XHJcblxyXG4gIGxldCBleHByID0gc2VnO1xyXG4gIHdoaWxlICgrK2kgPCBsKSB7XHJcbiAgICBleHByID0gZXhwciArICcgJiYgJyArIChzZWcgPSBzZWcgKyAnLicgKyBzZWdtZW50c1tpXSk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc3RvcmUnLCAncmV0dXJuICcgKyBleHByICsgJzsnKTtcclxuXHJcbiAgcmV0dXJuIDwoeDogYW55KSA9PiBhbnk+Zm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdLCBjb25maWc6IE5neHNDb25maWcpIHtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5ICYmIGNvbmZpZy5jb21wYXRpYmlsaXR5LnN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeSkge1xyXG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gZmFzdFByb3BHZXR0ZXIocGF0aHMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0YXRlcywgaXQgd2lsbCByZXR1cm4gYSBvYmplY3QgZ3JhcGguIEV4YW1wbGU6XHJcbiAqICAgIGNvbnN0IHN0YXRlcyA9IFtcclxuICogICAgICBDYXJ0LFxyXG4gKiAgICAgIENhcnRTYXZlZCxcclxuICogICAgICBDYXJ0U2F2ZWRJdGVtc1xyXG4gKiAgICBdXHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IGdyYXBoID0ge1xyXG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXHJcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXHJcbiAqICAgIGl0ZW1zOiBbXVxyXG4gKiAgfTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiBTdGF0ZUtleUdyYXBoIHtcclxuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzKSA9PiB7XHJcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcclxuICAgIGlmICghbWV0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfS4gXFxyXFxuWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBhZGQgc3RhdGVzIHRvIG1vZHVsZWBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWV0YVtNRVRBX0tFWV0hLm5hbWUhO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBzdGF0ZUNsYXNzZXMucmVkdWNlPFN0YXRlS2V5R3JhcGg+KFxyXG4gICAgKHJlc3VsdDogU3RhdGVLZXlHcmFwaCwgc3RhdGVDbGFzczogU3RhdGVDbGFzcykgPT4ge1xyXG4gICAgICBjb25zdCB7IG5hbWUsIGNoaWxkcmVuIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XHJcbiAgICAgIHJlc3VsdFtuYW1lIV0gPSAoY2hpbGRyZW4gfHwgW10pLm1hcChmaW5kTmFtZSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAge31cclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSBzdGF0ZXMgYXJyYXksIHJldHVybnMgb2JqZWN0IGdyYXBoXHJcbiAqIHJldHVybmluZyB0aGUgbmFtZSBhbmQgc3RhdGUgbWV0YWRhdGEuIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogeyBtZXRhZGF0YSB9XHJcbiAqICB9O1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbmFtZVRvU3RhdGUoc3RhdGVzOiBTdGF0ZUNsYXNzW10pOiBPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4ge1xyXG4gIHJldHVybiBzdGF0ZXMucmVkdWNlPE9iamVjdEtleU1hcDxTdGF0ZUNsYXNzPj4oXHJcbiAgICAocmVzdWx0OiBPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4sIHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3MpID0+IHtcclxuICAgICAgY29uc3QgbWV0YSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcclxuICAgICAgcmVzdWx0W21ldGEubmFtZSFdID0gc3RhdGVDbGFzcztcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICB7fVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCByZWxhdGlvbnNoaXAgZ3JhcGggd2lsbCByZXR1cm4gdGhlIGZ1bGwgcGF0aFxyXG4gKiBmb3IgdGhlIGNoaWxkIGl0ZW1zLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgY29uc3QgZ3JhcGggPSB7XHJcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcclxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcclxuICogICAgaXRlbXM6IFtdXHJcbiAqICB9O1xyXG4gKlxyXG4gKiB3b3VsZCByZXR1cm46XHJcbiAqXHJcbiAqICBjb25zdCByID0ge1xyXG4gKiAgICBjYXJ0OiAnY2FydCcsXHJcbiAqICAgIHNhdmVkOiAnY2FydC5zYXZlZCcsXHJcbiAqICAgIGl0ZW1zOiAnY2FydC5zYXZlZC5pdGVtcydcclxuICogIH07XHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnVsbFBhcmVudFBhdGgoXHJcbiAgb2JqOiBTdGF0ZUtleUdyYXBoLFxyXG4gIG5ld09iajogT2JqZWN0S2V5TWFwPHN0cmluZz4gPSB7fVxyXG4pOiBPYmplY3RLZXlNYXA8c3RyaW5nPiB7XHJcbiAgY29uc3QgdmlzaXQgPSAoY2hpbGQ6IFN0YXRlS2V5R3JhcGgsIGtleVRvRmluZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xyXG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQoY2hpbGQsIGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfTtcclxuXHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQob2JqLCBrZXkpO1xyXG4gICAgICBuZXdPYmpba2V5XSA9IHBhcmVudCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBuZXdPYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIG9iamVjdCBncmFwaCwgaXQgd2lsbCByZXR1cm4gdGhlIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkIEV4YW1wbGU6XHJcbiAqXHJcbiAqICBjb25zdCBncmFwaCA9IHtcclxuICogICAgY2FydDogWydzYXZlZCddLFxyXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxyXG4gKiAgICBpdGVtczogW11cclxuICogIH07XHJcbiAqXHJcbiAqIHdvdWxkIHJldHVybjpcclxuICpcclxuICogIGNvbnN0IHJlc3VsdHMgPSBbXHJcbiAqICAgICdpdGVtcycsXHJcbiAqICAgICdzYXZlZCcsXHJcbiAqICAgICdjYXJ0J1xyXG4gKiAgXTtcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRvcG9sb2dpY2FsU29ydChncmFwaDogU3RhdGVLZXlHcmFwaCk6IHN0cmluZ1tdIHtcclxuICBjb25zdCBzb3J0ZWQ6IHN0cmluZ1tdID0gW107XHJcbiAgY29uc3QgdmlzaXRlZDogT2JqZWN0S2V5TWFwPGJvb2xlYW4+ID0ge307XHJcblxyXG4gIGNvbnN0IHZpc2l0ID0gKG5hbWU6IHN0cmluZywgYW5jZXN0b3JzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xyXG4gICAgICBhbmNlc3RvcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhbmNlc3RvcnMucHVzaChuYW1lKTtcclxuICAgIHZpc2l0ZWRbbmFtZV0gPSB0cnVlO1xyXG5cclxuICAgIGdyYXBoW25hbWVdLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XHJcbiAgICAgIGlmIChhbmNlc3RvcnMuaW5kZXhPZihkZXApID49IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgQ2lyY3VsYXIgZGVwZW5kZW5jeSAnJHtkZXB9JyBpcyByZXF1aXJlZCBieSAnJHtuYW1lfSc6ICR7YW5jZXN0b3JzLmpvaW4oJyAtPiAnKX1gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZpc2l0ZWRbZGVwXSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmlzaXQoZGVwLCBhbmNlc3RvcnMuc2xpY2UoMCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHNvcnRlZC5pbmRleE9mKG5hbWUpIDwgMCkge1xyXG4gICAgICBzb3J0ZWQucHVzaChuYW1lKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBPYmplY3Qua2V5cyhncmFwaCkuZm9yRWFjaChrID0+IHZpc2l0KGspKTtcclxuXHJcbiAgcmV0dXJuIHNvcnRlZC5yZXZlcnNlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBvYmplY3Qgb3Igbm90LlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqOiBhbnkpIHtcclxuICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuY29uc3QgRE9MTEFSX0NIQVJfQ09ERSA9IDM2O1xyXG5cclxuLyoqXHJcbiAqIElmIGBmb28kYCA9PiBtYWtlIGl0IGp1c3QgYGZvb2BcclxuICpcclxuICogQGlnbm9yZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZURvbGxhckF0VGhlRW5kKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgY29uc3QgbGFzdENoYXJJbmRleCA9IG5hbWUubGVuZ3RoIC0gMTtcclxuICBjb25zdCBkb2xsYXJBdFRoZUVuZCA9IG5hbWUuY2hhckNvZGVBdChsYXN0Q2hhckluZGV4KSA9PT0gRE9MTEFSX0NIQVJfQ09ERTtcclxuICByZXR1cm4gZG9sbGFyQXRUaGVFbmQgPyBuYW1lLnNsaWNlKDAsIGxhc3RDaGFySW5kZXgpIDogbmFtZTtcclxufVxyXG4iXX0=