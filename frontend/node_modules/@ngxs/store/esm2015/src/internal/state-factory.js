/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Injector, Optional, SkipSelf } from '@angular/core';
import { forkJoin, from, Observable, of, throwError } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { InternalStateOperations } from '../internal/state-operations';
/**
 * State factory class
 * @ignore
 */
export class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     * @param {?} _internalStateOperations
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _internalStateOperations) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._internalStateOperations = _internalStateOperations;
        this._connected = false;
        this._states = [];
        this._statesByName = {};
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * @return {?}
     */
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    /**
     * @private
     * @return {?}
     */
    get stateTreeRef() {
        return this._internalStateOperations.getRootStateOperations().getState();
    }
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    static cloneDefaults(defaults) {
        /** @type {?} */
        let value = {};
        if (Array.isArray(defaults)) {
            value = [...defaults];
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    static checkStatesAreValid(stateClasses) {
        stateClasses.forEach(StoreValidators.getValidStateMeta);
    }
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    add(stateClasses) {
        StateFactory.checkStatesAreValid(stateClasses);
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        /** @type {?} */
        const stateGraph = buildGraph(newStates);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const depths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(newStates);
        /** @type {?} */
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            /** @type {?} */
            const depth = depths[name];
            /** @type {?} */
            const meta = (/** @type {?} */ (stateClass[META_KEY]));
            this.addRuntimeInfoToMeta(meta, depth);
            /** @type {?} */
            const stateMap = {
                name,
                depth,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, depth)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        /** @type {?} */
        const classes = stateClasses || [];
        /** @type {?} */
        const states = this.add(classes);
        /** @type {?} */
        const defaults = states.reduce((/**
         * @param {?} result
         * @param {?} meta
         * @return {?}
         */
        (result, meta) => setValue(result, meta.depth, meta.defaults)), {});
        return { defaults, states };
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._connected)
            return;
        this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => ctx.status === "DISPATCHED" /* Dispatched */)), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        ({ action }) => this.invokeActions(this._actions, (/** @type {?} */ (action))).pipe(map((/**
         * @return {?}
         */
        () => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ })))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError((/**
         * @param {?} error
         * @return {?}
         */
        error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error })))))))))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => this._actionResults.next(ctx)));
        this._connected = true;
    }
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    invokeActions(actions$, action) {
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const type = (/** @type {?} */ (getActionTypeFromInstance(action)));
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (result instanceof Observable) {
                            result = result.pipe(actionMeta.options.cancelUncompleted
                                ? // todo: ofActionDispatched should be used with action class
                                    takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action)))))
                                : map((/**
                                 * @param {?} r
                                 * @return {?}
                                 */
                                r => r))); // map acts like a noop
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    addToStatesMap(stateClasses) {
        /** @type {?} */
        const newStates = [];
        /** @type {?} */
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            /** @type {?} */
            const stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
            /** @type {?} */
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    /**
     * @private
     * @param {?} meta
     * @param {?} depth
     * @return {?}
     */
    addRuntimeInfoToMeta(meta, depth) {
        meta.path = depth;
        meta.selectFromAppState = propGetter(depth.split('.'), this._config);
    }
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    hasBeenMountedAndBootstrapped(name, path) {
        /** @type {?} */
        const valueIsBootstrapped = getValue(this.stateTreeRef, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrapped;
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory },
    { type: InternalStateOperations }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._internalStateOperations;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDekUsT0FBTyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEUsT0FBTyxFQUNMLFVBQVUsRUFDVixjQUFjLEVBQ2QsTUFBTSxFQUNOLEdBQUcsRUFDSCxRQUFRLEVBQ1IsV0FBVyxFQUNYLFNBQVMsRUFDVixNQUFNLGdCQUFnQixDQUFDO0FBRXhCLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2xELE9BQU8sRUFDTCxVQUFVLEVBQ1Ysa0JBQWtCLEVBQ2xCLFFBQVEsRUFHUixXQUFXLEVBRVgsVUFBVSxFQUtWLGVBQWUsRUFDaEIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQStCLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQzs7Ozs7QUFPdkUsTUFBTSxPQUFPLFlBQVk7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c291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIE9wdGlvbmFsLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBmb3JrSm9pbiwgZnJvbSwgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHtcclxuICBjYXRjaEVycm9yLFxyXG4gIGRlZmF1bHRJZkVtcHR5LFxyXG4gIGZpbHRlcixcclxuICBtYXAsXHJcbiAgbWVyZ2VNYXAsXHJcbiAgc2hhcmVSZXBsYXksXHJcbiAgdGFrZVVudGlsXHJcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgTUVUQV9LRVksIE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcclxuaW1wb3J0IHtcclxuICBidWlsZEdyYXBoLFxyXG4gIGZpbmRGdWxsUGFyZW50UGF0aCxcclxuICBpc09iamVjdCxcclxuICBNYXBwZWRTdG9yZSxcclxuICBNZXRhRGF0YU1vZGVsLFxyXG4gIG5hbWVUb1N0YXRlLFxyXG4gIE9iamVjdEtleU1hcCxcclxuICBwcm9wR2V0dGVyLFxyXG4gIFN0YXRlQ2xhc3MsXHJcbiAgU3RhdGVLZXlHcmFwaCxcclxuICBTdGF0ZXNBbmREZWZhdWx0cyxcclxuICBTdGF0ZXNCeU5hbWUsXHJcbiAgdG9wb2xvZ2ljYWxTb3J0XHJcbn0gZnJvbSAnLi9pbnRlcm5hbHMnO1xyXG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlLCBnZXRWYWx1ZSwgc2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xyXG5pbXBvcnQgeyBBY3Rpb25Db250ZXh0LCBBY3Rpb25TdGF0dXMsIEludGVybmFsQWN0aW9ucyB9IGZyb20gJy4uL2FjdGlvbnMtc3RyZWFtJztcclxuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xyXG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcclxuaW1wb3J0IHsgU3RvcmVWYWxpZGF0b3JzIH0gZnJvbSAnLi4vdXRpbHMvc3RvcmUtdmFsaWRhdG9ycyc7XHJcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XHJcblxyXG4vKipcclxuICogU3RhdGUgZmFjdG9yeSBjbGFzc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZUZhY3Rvcnkge1xyXG4gIHByaXZhdGUgX2Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xyXG4gIHByaXZhdGUgX3N0YXRlc0J5TmFtZTogU3RhdGVzQnlOYW1lID0ge307XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxyXG4gICAgcHJpdmF0ZSBfY29uZmlnOiBOZ3hzQ29uZmlnLFxyXG4gICAgQE9wdGlvbmFsKClcclxuICAgIEBTa2lwU2VsZigpXHJcbiAgICBwcml2YXRlIF9wYXJlbnRGYWN0b3J5OiBTdGF0ZUZhY3RvcnksXHJcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBJbnRlcm5hbEFjdGlvbnMsXHJcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxyXG4gICAgcHJpdmF0ZSBfc3RhdGVDb250ZXh0RmFjdG9yeTogU3RhdGVDb250ZXh0RmFjdG9yeSxcclxuICAgIHByaXZhdGUgX2ludGVybmFsU3RhdGVPcGVyYXRpb25zOiBJbnRlcm5hbFN0YXRlT3BlcmF0aW9uc1xyXG4gICkge31cclxuXHJcbiAgcHVibGljIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzIDogdGhpcy5fc3RhdGVzO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldCBzdGF0ZXNCeU5hbWUoKTogU3RhdGVzQnlOYW1lIHtcclxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXNCeU5hbWUgOiB0aGlzLl9zdGF0ZXNCeU5hbWU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldCBzdGF0ZVRyZWVSZWYoKTogT2JqZWN0S2V5TWFwPGFueT4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5nZXRTdGF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgY2xvbmVEZWZhdWx0cyhkZWZhdWx0czogYW55KTogYW55IHtcclxuICAgIGxldCB2YWx1ZSA9IHt9O1xyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xyXG4gICAgICB2YWx1ZSA9IFsuLi5kZWZhdWx0c107XHJcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRlZmF1bHRzKSkge1xyXG4gICAgICB2YWx1ZSA9IHsgLi4uZGVmYXVsdHMgfTtcclxuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YWx1ZSA9IHt9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsdWUgPSBkZWZhdWx0cztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXRpYyBjaGVja1N0YXRlc0FyZVZhbGlkKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc1tdKTogdm9pZCB7XHJcbiAgICBzdGF0ZUNsYXNzZXMuZm9yRWFjaChTdG9yZVZhbGlkYXRvcnMuZ2V0VmFsaWRTdGF0ZU1ldGEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIHRoZSBnbG9iYWwgZGVmcy5cclxuICAgKi9cclxuICBhZGQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiBNYXBwZWRTdG9yZVtdIHtcclxuICAgIFN0YXRlRmFjdG9yeS5jaGVja1N0YXRlc0FyZVZhbGlkKHN0YXRlQ2xhc3Nlcyk7XHJcbiAgICBjb25zdCB7IG5ld1N0YXRlcyB9ID0gdGhpcy5hZGRUb1N0YXRlc01hcChzdGF0ZUNsYXNzZXMpO1xyXG4gICAgaWYgKCFuZXdTdGF0ZXMubGVuZ3RoKSByZXR1cm4gW107XHJcblxyXG4gICAgY29uc3Qgc3RhdGVHcmFwaDogU3RhdGVLZXlHcmFwaCA9IGJ1aWxkR3JhcGgobmV3U3RhdGVzKTtcclxuICAgIGNvbnN0IHNvcnRlZFN0YXRlczogc3RyaW5nW10gPSB0b3BvbG9naWNhbFNvcnQoc3RhdGVHcmFwaCk7XHJcbiAgICBjb25zdCBkZXB0aHM6IE9iamVjdEtleU1hcDxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xyXG4gICAgY29uc3QgbmFtZUdyYXBoOiBPYmplY3RLZXlNYXA8U3RhdGVDbGFzcz4gPSBuYW1lVG9TdGF0ZShuZXdTdGF0ZXMpO1xyXG4gICAgY29uc3QgYm9vdHN0cmFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNvcnRlZFN0YXRlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzID0gbmFtZUdyYXBoW25hbWVdO1xyXG4gICAgICBjb25zdCBkZXB0aDogc3RyaW5nID0gZGVwdGhzW25hbWVdO1xyXG4gICAgICBjb25zdCBtZXRhOiBNZXRhRGF0YU1vZGVsID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xyXG5cclxuICAgICAgdGhpcy5hZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhLCBkZXB0aCk7XHJcblxyXG4gICAgICBjb25zdCBzdGF0ZU1hcDogTWFwcGVkU3RvcmUgPSB7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBkZXB0aCxcclxuICAgICAgICBhY3Rpb25zOiBtZXRhLmFjdGlvbnMsXHJcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMuX2luamVjdG9yLmdldChzdGF0ZUNsYXNzKSxcclxuICAgICAgICBkZWZhdWx0czogU3RhdGVGYWN0b3J5LmNsb25lRGVmYXVsdHMobWV0YS5kZWZhdWx0cylcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxyXG4gICAgICAvLyBidXQgZG9uJ3QgdGhyb3cgc2luY2UgaXQgY291bGQgYmUgbGF6eVxyXG4gICAgICAvLyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgcGF0aHNcclxuICAgICAgaWYgKCF0aGlzLmhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWUsIGRlcHRoKSkge1xyXG4gICAgICAgIGJvb3RzdHJhcHBlZFN0b3Jlcy5wdXNoKHN0YXRlTWFwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJvb3RzdHJhcHBlZFN0b3JlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHNldCBvZiBzdGF0ZXMgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gdGhlIGRlZmF1bHRzXHJcbiAgICovXHJcbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiBTdGF0ZXNBbmREZWZhdWx0cyB7XHJcbiAgICBjb25zdCBjbGFzc2VzOiBTdGF0ZUNsYXNzW10gPSBzdGF0ZUNsYXNzZXMgfHwgW107XHJcblxyXG4gICAgY29uc3Qgc3RhdGVzOiBNYXBwZWRTdG9yZVtdID0gdGhpcy5hZGQoY2xhc3Nlcyk7XHJcbiAgICBjb25zdCBkZWZhdWx0cyA9IHN0YXRlcy5yZWR1Y2UoXHJcbiAgICAgIChyZXN1bHQ6IGFueSwgbWV0YTogTWFwcGVkU3RvcmUpID0+IHNldFZhbHVlKHJlc3VsdCwgbWV0YS5kZXB0aCwgbWV0YS5kZWZhdWx0cyksXHJcbiAgICAgIHt9XHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHsgZGVmYXVsdHMsIHN0YXRlcyB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQmluZCB0aGUgYWN0aW9ucyB0byB0aGUgaGFuZGxlcnNcclxuICAgKi9cclxuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKSB7XHJcbiAgICBpZiAodGhpcy5fY29ubmVjdGVkKSByZXR1cm47XHJcbiAgICB0aGlzLl9hY3Rpb25zXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguc3RhdHVzID09PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXHJcbiAgICAgICAgbWVyZ2VNYXAoKHsgYWN0aW9uIH0pID0+XHJcbiAgICAgICAgICB0aGlzLmludm9rZUFjdGlvbnModGhpcy5fYWN0aW9ucywgYWN0aW9uISkucGlwZShcclxuICAgICAgICAgICAgbWFwKCgpID0+IDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsIH0pLFxyXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXHJcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT5cclxuICAgICAgICAgICAgICBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgICAuc3Vic2NyaWJlKGN0eCA9PiB0aGlzLl9hY3Rpb25SZXN1bHRzLm5leHQoY3R4KSk7XHJcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW52b2tlIGFjdGlvbnMgb24gdGhlIHN0YXRlcy5cclxuICAgKi9cclxuICBpbnZva2VBY3Rpb25zKGFjdGlvbnMkOiBJbnRlcm5hbEFjdGlvbnMsIGFjdGlvbjogYW55KSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiB0aGlzLnN0YXRlcykge1xyXG4gICAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pITtcclxuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xyXG5cclxuICAgICAgaWYgKGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XHJcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXHJcbiAgICAgICAgICAgICAgICBhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWRcclxuICAgICAgICAgICAgICAgICAgPyAvLyB0b2RvOiBvZkFjdGlvbkRpc3BhdGNoZWQgc2hvdWxkIGJlIHVzZWQgd2l0aCBhY3Rpb24gY2xhc3NcclxuICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwoYWN0aW9ucyQucGlwZShvZkFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uIGFzIGFueSkpKVxyXG4gICAgICAgICAgICAgICAgICA6IG1hcChyID0+IHIpXHJcbiAgICAgICAgICAgICAgKTsgLy8gbWFwIGFjdHMgbGlrZSBhIG5vb3BcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkVG9TdGF0ZXNNYXAoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzW10pOiB7IG5ld1N0YXRlczogU3RhdGVDbGFzc1tdIH0ge1xyXG4gICAgY29uc3QgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzW10gPSBbXTtcclxuICAgIGNvbnN0IHN0YXRlc01hcDogU3RhdGVzQnlOYW1lID0gdGhpcy5zdGF0ZXNCeU5hbWU7XHJcblxyXG4gICAgZm9yIChjb25zdCBzdGF0ZUNsYXNzIG9mIHN0YXRlQ2xhc3Nlcykge1xyXG4gICAgICBjb25zdCBzdGF0ZU5hbWU6IHN0cmluZyA9IFN0b3JlVmFsaWRhdG9ycy5jaGVja1N0YXRlTmFtZUlzVW5pcXVlKHN0YXRlQ2xhc3MsIHN0YXRlc01hcCk7XHJcbiAgICAgIGNvbnN0IHVubW91bnRlZFN0YXRlOiBib29sZWFuID0gIXN0YXRlc01hcFtzdGF0ZU5hbWVdO1xyXG4gICAgICBpZiAodW5tb3VudGVkU3RhdGUpIHtcclxuICAgICAgICBuZXdTdGF0ZXMucHVzaChzdGF0ZUNsYXNzKTtcclxuICAgICAgICBzdGF0ZXNNYXBbc3RhdGVOYW1lXSA9IHN0YXRlQ2xhc3M7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBuZXdTdGF0ZXMgfTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkUnVudGltZUluZm9Ub01ldGEobWV0YTogTWV0YURhdGFNb2RlbCwgZGVwdGg6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgbWV0YS5wYXRoID0gZGVwdGg7XHJcbiAgICBtZXRhLnNlbGVjdEZyb21BcHBTdGF0ZSA9IHByb3BHZXR0ZXIoZGVwdGguc3BsaXQoJy4nKSwgdGhpcy5fY29uZmlnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBkZXNjcmlwdGlvblxyXG4gICAqIHRoZSBtZXRob2QgY2hlY2tzIGlmIHRoZSBzdGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSB0cmVlXHJcbiAgICogYW5kIGNvbXBsZXRlZCB0aGUgbGlmZSBjeWNsZVxyXG4gICAqIEBwYXJhbSBuYW1lXHJcbiAgICogQHBhcmFtIHBhdGhcclxuICAgKi9cclxuICBwcml2YXRlIGhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCB2YWx1ZUlzQm9vdHN0cmFwcGVkOiBib29sZWFuID0gZ2V0VmFsdWUodGhpcy5zdGF0ZVRyZWVSZWYsIHBhdGgpICE9PSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZDtcclxuICB9XHJcbn1cclxuIl19