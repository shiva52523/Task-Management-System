/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ensureSelectorMetadata, getSelectorMetadata, getStoreMetadata } from '../internal/internals';
import { memoize } from '../utils/memoize';
/**
 * Function for creating a selector
 * @template T
 * @param {?} selectors The selectors to use to create the arguments of this function
 * @param {?} originalFn The original function being made into a selector
 * @param {?=} creationMetadata
 * @return {?}
 */
export function createSelector(selectors, originalFn, creationMetadata) {
    /** @type {?} */
    const wrappedFn = (/** @type {?} */ ((/**
     * @param {...?} args
     * @return {?}
     */
    function wrappedSelectorFn(...args) {
        /** @type {?} */
        const returnValue = originalFn(...args);
        if (returnValue instanceof Function) {
            /** @type {?} */
            const innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    })));
    /** @type {?} */
    const memoizedFn = memoize(wrappedFn);
    /** @type {?} */
    const containerClass = creationMetadata && creationMetadata.containerClass;
    /** @type {?} */
    const fn = (/**
     * @param {?} state
     * @return {?}
     */
    (state) => {
        /** @type {?} */
        const results = [];
        /** @type {?} */
        const selectorsToApply = [];
        if (containerClass) {
            // If we are on a state class, add it as the first selector parameter
            /** @type {?} */
            const metadata = getStoreMetadata(containerClass);
            if (metadata) {
                selectorsToApply.push(containerClass);
            }
        }
        if (selectors) {
            selectorsToApply.push(...selectors);
        }
        // Determine arguments from the app state using the selectors
        results.push(...selectorsToApply.map((/**
         * @param {?} a
         * @return {?}
         */
        a => getSelectorFn(a)(state))));
        // if the lambda tries to access a something on the
        // state that doesn't exist, it will throw a TypeError.
        // since this is quite usual behaviour, we simply return undefined if so.
        try {
            return memoizedFn(...results);
        }
        catch (ex) {
            if (ex instanceof TypeError) {
                return undefined;
            }
            throw ex;
        }
    });
    /** @type {?} */
    const selectorMetaData = ensureSelectorMetadata(memoizedFn);
    selectorMetaData.originalFn = originalFn;
    selectorMetaData.selectFromAppState = fn;
    if (creationMetadata) {
        selectorMetaData.containerClass = creationMetadata.containerClass;
        selectorMetaData.selectorName = creationMetadata.selectorName;
    }
    return memoizedFn;
}
/**
 * This function gets the selector function to be used to get the selected slice from the app state
 * @ignore
 * @param {?} selector
 * @return {?}
 */
export function getSelectorFn(selector) {
    /** @type {?} */
    const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.selectFromAppState) || selector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3ItdXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy91dGlscy9zZWxlY3Rvci11dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUVMLHNCQUFzQixFQUN0QixtQkFBbUIsRUFDbkIsZ0JBQWdCLEVBQ2pCLE1BQU0sdUJBQXVCLENBQUM7QUFDL0IsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7Ozs7Ozs7QUFRM0MsTUFBTSxVQUFVLGNBQWMsQ0FDNUIsU0FBNEIsRUFDNUIsVUFBYSxFQUNiLGdCQUFnRTs7VUFFMUQsU0FBUyxHQUFHOzs7O0lBQUEsU0FBUyxpQkFBaUIsQ0FBQyxHQUFHLElBQVc7O2NBQ25ELFdBQVcsR0FBRyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDdkMsSUFBSSxXQUFXLFlBQVksUUFBUSxFQUFFOztrQkFDN0IsZUFBZSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDMUQsT0FBTyxlQUFlLENBQUM7U0FDeEI7UUFDRCxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFDLEdBQUs7O1VBQ0EsVUFBVSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7O1VBQy9CLGNBQWMsR0FBRyxnQkFBZ0IsSUFBSSxnQkFBZ0IsQ0FBQyxjQUFjOztVQUVwRSxFQUFFOzs7O0lBQUcsQ0FBQyxLQUFVLEVBQUUsRUFBRTs7Y0FDbEIsT0FBTyxHQUFHLEVBQUU7O2NBRVosZ0JBQWdCLEdBQUcsRUFBRTtRQUUzQixJQUFJLGNBQWMsRUFBRTs7O2tCQUVaLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUM7WUFDakQsSUFBSSxRQUFRLEVBQUU7Z0JBQ1osZ0JBQWdCLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2FBQ3ZDO1NBQ0Y7UUFFRCxJQUFJLFNBQVMsRUFBRTtZQUNiLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsNkRBQTZEO1FBQzdELE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHOzs7O1FBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUMsQ0FBQyxDQUFDO1FBRXBFLG1EQUFtRDtRQUNuRCx1REFBdUQ7UUFDdkQseUVBQXlFO1FBQ3pFLElBQUk7WUFDRixPQUFPLFVBQVUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO1NBQy9CO1FBQUMsT0FBTyxFQUFFLEVBQUU7WUFDWCxJQUFJLEVBQUUsWUFBWSxTQUFTLEVBQUU7Z0JBQzNCLE9BQU8sU0FBUyxDQUFDO2FBQ2xCO1lBQ0QsTUFBTSxFQUFFLENBQUM7U0FDVjtJQUNILENBQUMsQ0FBQTs7VUFFSyxnQkFBZ0IsR0FBRyxzQkFBc0IsQ0FBQyxVQUFVLENBQUM7SUFDM0QsZ0JBQWdCLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztJQUN6QyxnQkFBZ0IsQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLENBQUM7SUFDekMsSUFBSSxnQkFBZ0IsRUFBRTtRQUNwQixnQkFBZ0IsQ0FBQyxjQUFjLEdBQUcsZ0JBQWdCLENBQUMsY0FBYyxDQUFDO1FBQ2xFLGdCQUFnQixDQUFDLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUM7S0FDL0Q7SUFDRCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDOzs7Ozs7O0FBTUQsTUFBTSxVQUFVLGFBQWEsQ0FBQyxRQUFhOztVQUNuQyxRQUFRLEdBQUcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLElBQUksZ0JBQWdCLENBQUMsUUFBUSxDQUFDO0lBQzVFLE9BQU8sQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLGtCQUFrQixDQUFDLElBQUksUUFBUSxDQUFDO0FBQy9ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIFNlbGVjdEZyb21TdGF0ZSxcclxuICBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhLFxyXG4gIGdldFNlbGVjdG9yTWV0YWRhdGEsXHJcbiAgZ2V0U3RvcmVNZXRhZGF0YVxyXG59IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XHJcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlscy9tZW1vaXplJztcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBzZWxlY3RvclxyXG4gKiBAcGFyYW0gc2VsZWN0b3JzIFRoZSBzZWxlY3RvcnMgdG8gdXNlIHRvIGNyZWF0ZSB0aGUgYXJndW1lbnRzIG9mIHRoaXMgZnVuY3Rpb25cclxuICogQHBhcmFtIG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlaW5nIG1hZGUgaW50byBhIHNlbGVjdG9yXHJcbiAqIEBwYXJhbSBjcmVhdGlvbk1ldGFkYXRhXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3I8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcclxuICBzZWxlY3RvcnM6IGFueVtdIHwgdW5kZWZpbmVkLFxyXG4gIG9yaWdpbmFsRm46IFQsXHJcbiAgY3JlYXRpb25NZXRhZGF0YT86IHsgY29udGFpbmVyQ2xhc3M6IGFueTsgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfVxyXG4pIHtcclxuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbiguLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvcmlnaW5hbEZuKC4uLmFyZ3MpO1xyXG4gICAgaWYgKHJldHVyblZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgY29uc3QgaW5uZXJNZW1vaXplZEZuID0gbWVtb2l6ZS5hcHBseShudWxsLCBbcmV0dXJuVmFsdWVdKTtcclxuICAgICAgcmV0dXJuIGlubmVyTWVtb2l6ZWRGbjtcclxuICAgIH1cclxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcclxuICB9IGFzIFQ7XHJcbiAgY29uc3QgbWVtb2l6ZWRGbiA9IG1lbW9pemUod3JhcHBlZEZuKTtcclxuICBjb25zdCBjb250YWluZXJDbGFzcyA9IGNyZWF0aW9uTWV0YWRhdGEgJiYgY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuXHJcbiAgY29uc3QgZm4gPSAoc3RhdGU6IGFueSkgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdG9yc1RvQXBwbHkgPSBbXTtcclxuXHJcbiAgICBpZiAoY29udGFpbmVyQ2xhc3MpIHtcclxuICAgICAgLy8gSWYgd2UgYXJlIG9uIGEgc3RhdGUgY2xhc3MsIGFkZCBpdCBhcyB0aGUgZmlyc3Qgc2VsZWN0b3IgcGFyYW1ldGVyXHJcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2V0U3RvcmVNZXRhZGF0YShjb250YWluZXJDbGFzcyk7XHJcbiAgICAgIGlmIChtZXRhZGF0YSkge1xyXG4gICAgICAgIHNlbGVjdG9yc1RvQXBwbHkucHVzaChjb250YWluZXJDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VsZWN0b3JzKSB7XHJcbiAgICAgIHNlbGVjdG9yc1RvQXBwbHkucHVzaCguLi5zZWxlY3RvcnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBhcmd1bWVudHMgZnJvbSB0aGUgYXBwIHN0YXRlIHVzaW5nIHRoZSBzZWxlY3RvcnNcclxuICAgIHJlc3VsdHMucHVzaCguLi5zZWxlY3RvcnNUb0FwcGx5Lm1hcChhID0+IGdldFNlbGVjdG9yRm4oYSkoc3RhdGUpKSk7XHJcblxyXG4gICAgLy8gaWYgdGhlIGxhbWJkYSB0cmllcyB0byBhY2Nlc3MgYSBzb21ldGhpbmcgb24gdGhlXHJcbiAgICAvLyBzdGF0ZSB0aGF0IGRvZXNuJ3QgZXhpc3QsIGl0IHdpbGwgdGhyb3cgYSBUeXBlRXJyb3IuXHJcbiAgICAvLyBzaW5jZSB0aGlzIGlzIHF1aXRlIHVzdWFsIGJlaGF2aW91ciwgd2Ugc2ltcGx5IHJldHVybiB1bmRlZmluZWQgaWYgc28uXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gbWVtb2l6ZWRGbiguLi5yZXN1bHRzKTtcclxuICAgIH0gY2F0Y2ggKGV4KSB7XHJcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgc2VsZWN0b3JNZXRhRGF0YSA9IGVuc3VyZVNlbGVjdG9yTWV0YWRhdGEobWVtb2l6ZWRGbik7XHJcbiAgc2VsZWN0b3JNZXRhRGF0YS5vcmlnaW5hbEZuID0gb3JpZ2luYWxGbjtcclxuICBzZWxlY3Rvck1ldGFEYXRhLnNlbGVjdEZyb21BcHBTdGF0ZSA9IGZuO1xyXG4gIGlmIChjcmVhdGlvbk1ldGFkYXRhKSB7XHJcbiAgICBzZWxlY3Rvck1ldGFEYXRhLmNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YS5jb250YWluZXJDbGFzcztcclxuICAgIHNlbGVjdG9yTWV0YURhdGEuc2VsZWN0b3JOYW1lID0gY3JlYXRpb25NZXRhZGF0YS5zZWxlY3Rvck5hbWU7XHJcbiAgfVxyXG4gIHJldHVybiBtZW1vaXplZEZuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBzZWxlY3RvciBmdW5jdGlvbiB0byBiZSB1c2VkIHRvIGdldCB0aGUgc2VsZWN0ZWQgc2xpY2UgZnJvbSB0aGUgYXBwIHN0YXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpOiBTZWxlY3RGcm9tU3RhdGUge1xyXG4gIGNvbnN0IG1ldGFkYXRhID0gZ2V0U2VsZWN0b3JNZXRhZGF0YShzZWxlY3RvcikgfHwgZ2V0U3RvcmVNZXRhZGF0YShzZWxlY3Rvcik7XHJcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5zZWxlY3RGcm9tQXBwU3RhdGUpIHx8IHNlbGVjdG9yO1xyXG59XHJcbiJdfQ==